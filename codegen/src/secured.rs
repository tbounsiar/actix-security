//! The `#[secured]` macro for role-based method security.
//!
//! # Spring Security Equivalent
//! `@Secured("ROLE_ADMIN")` or `@RolesAllowed("ADMIN")`

use proc_macro::TokenStream;
use quote::quote;
use syn::parse::{Parse, ParseStream};
use syn::punctuated::Punctuated;
use syn::{parse_macro_input, Expr, ExprLit, ItemFn, Lit, ReturnType, Token};

use crate::helpers::{find_user_param, missing_user_param_error};

/// Parses comma-separated string literals for #[secured("ADMIN", "USER")]
pub struct SecuredArgs {
    pub roles: Vec<String>,
}

impl Parse for SecuredArgs {
    fn parse(input: ParseStream) -> syn::Result<Self> {
        let args: Punctuated<Expr, Token![,]> = Punctuated::parse_terminated(input)?;

        if args.is_empty() {
            return Err(syn::Error::new(
                input.span(),
                r#"expected at least one role, e.g. #[secured("ADMIN")]"#,
            ));
        }

        let mut roles = Vec::new();
        for arg in args {
            match arg {
                Expr::Lit(ExprLit {
                    lit: Lit::Str(lit_str),
                    ..
                }) => {
                    roles.push(lit_str.value());
                }
                _ => {
                    return Err(syn::Error::new_spanned(
                        arg,
                        r#"expected string literal like "ADMIN""#,
                    ));
                }
            }
        }

        Ok(SecuredArgs { roles })
    }
}

/// Role-based method security annotation.
///
/// # Spring Security Equivalent
/// `@Secured("ROLE_ADMIN")` or `@RolesAllowed("ADMIN")`
///
/// # Usage
/// ```ignore
/// use actix_security_core::http::security::AuthenticatedUser;
/// use actix_security_codegen::secured;
///
/// // Single role
/// #[secured("ADMIN")]
/// #[get("/admin")]
/// async fn admin_only(user: AuthenticatedUser) -> impl Responder {
///     HttpResponse::Ok().body("Admin area")
/// }
///
/// // Multiple roles (OR logic - user needs ANY of these)
/// #[secured("ADMIN", "MANAGER")]
/// #[get("/management")]
/// async fn management(user: AuthenticatedUser) -> impl Responder {
///     HttpResponse::Ok().body("Management area")
/// }
/// ```
///
/// # Note
/// Unlike Spring Security, you don't need the "ROLE_" prefix.
/// The macro checks if the user has ANY of the specified roles.
pub fn secured_impl(attrs: TokenStream, input: TokenStream) -> TokenStream {
    let item_fn = parse_macro_input!(input as ItemFn);
    let args = parse_macro_input!(attrs as SecuredArgs);

    let roles = args.roles;

    let user_param = match find_user_param(&item_fn) {
        Some(param) => param,
        None => return missing_user_param_error(&item_fn, "secured"),
    };

    let attrs = &item_fn.attrs;
    let vis = &item_fn.vis;
    let sig = &item_fn.sig;
    let block = &item_fn.block;
    let fn_name = &sig.ident;
    let inputs = &sig.inputs;
    let asyncness = &sig.asyncness;
    let generics = &sig.generics;

    let original_return = match &sig.output {
        ReturnType::Default => quote! { () },
        ReturnType::Type(_, ty) => quote! { #ty },
    };

    let expanded = quote! {
        #(#attrs)*
        #vis #asyncness fn #fn_name #generics(#inputs) -> ::std::result::Result<#original_return, ::actix_security_core::http::error::AuthError> {
            // Role check generated by #[secured]
            {
                let __required_roles: &[&str] = &[#(#roles),*];
                if !#user_param.has_any_role(__required_roles) {
                    return ::std::result::Result::Err(::actix_security_core::http::error::AuthError::Forbidden);
                }
            }

            ::std::result::Result::Ok(#block)
        }
    };

    expanded.into()
}
