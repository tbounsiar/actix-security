<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Custom Expressions - Actix Security</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="Spring Security-inspired authentication and authorization for Actix Web">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../theme/pagetoc.css">

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "ayu" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item affix "><a href="../introduction.html">Introduction</a></li><li class="chapter-item affix "><li class="part-title">Getting Started</li><li class="chapter-item "><a href="../getting-started/quick-start.html"><strong aria-hidden="true">1.</strong> Quick Start</a></li><li class="chapter-item "><a href="../getting-started/installation.html"><strong aria-hidden="true">2.</strong> Installation</a></li><li class="chapter-item "><a href="../getting-started/first-app.html"><strong aria-hidden="true">3.</strong> Your First Secured App</a></li><li class="chapter-item affix "><li class="part-title">Core Concepts</li><li class="chapter-item "><a href="../authentication/index.html"><strong aria-hidden="true">4.</strong> Authentication</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../authentication/memory.html"><strong aria-hidden="true">4.1.</strong> In-Memory Authentication</a></li><li class="chapter-item "><a href="../authentication/password-encoding.html"><strong aria-hidden="true">4.2.</strong> Password Encoding</a></li><li class="chapter-item "><a href="../authentication/http-basic.html"><strong aria-hidden="true">4.3.</strong> HTTP Basic</a></li><li class="chapter-item "><a href="../authentication/jwt.html"><strong aria-hidden="true">4.4.</strong> JWT Authentication</a></li><li class="chapter-item "><a href="../authentication/session-auth.html"><strong aria-hidden="true">4.5.</strong> Session Authentication</a></li><li class="chapter-item "><a href="../authentication/oauth2.html"><strong aria-hidden="true">4.6.</strong> OAuth2 / OIDC</a></li><li class="chapter-item "><a href="../authentication/custom.html"><strong aria-hidden="true">4.7.</strong> Custom Authenticators</a></li></ol></li><li class="chapter-item "><a href="../authorization/index.html"><strong aria-hidden="true">5.</strong> Authorization</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../authorization/url-based.html"><strong aria-hidden="true">5.1.</strong> URL-Based Authorization</a></li><li class="chapter-item "><a href="../authorization/method-security.html"><strong aria-hidden="true">5.2.</strong> Method Security</a></li><li class="chapter-item "><a href="../authorization/roles-authorities.html"><strong aria-hidden="true">5.3.</strong> Roles vs Authorities</a></li><li class="chapter-item "><a href="../authorization/custom.html"><strong aria-hidden="true">5.4.</strong> Custom Authorizers</a></li></ol></li><li class="chapter-item "><li class="part-title">Macros & Annotations</li><li class="chapter-item "><a href="../macros/index.html"><strong aria-hidden="true">6.</strong> Overview</a></li><li class="chapter-item "><a href="../macros/secured.html"><strong aria-hidden="true">7.</strong> @secured</a></li><li class="chapter-item "><a href="../macros/pre-authorize.html"><strong aria-hidden="true">8.</strong> @pre_authorize</a></li><li class="chapter-item "><a href="../macros/permit-all.html"><strong aria-hidden="true">9.</strong> @permit_all</a></li><li class="chapter-item "><a href="../macros/deny-all.html"><strong aria-hidden="true">10.</strong> @deny_all</a></li><li class="chapter-item "><a href="../macros/roles-allowed.html"><strong aria-hidden="true">11.</strong> @roles_allowed</a></li><li class="chapter-item affix "><li class="part-title">Security Expressions</li><li class="chapter-item "><a href="../expressions/index.html"><strong aria-hidden="true">12.</strong> Expression Language</a></li><li class="chapter-item "><a href="../expressions/builtin.html"><strong aria-hidden="true">13.</strong> Built-in Functions</a></li><li class="chapter-item expanded "><a href="../expressions/custom.html" class="active"><strong aria-hidden="true">14.</strong> Custom Expressions</a></li><li class="chapter-item affix "><li class="part-title">Additional Features</li><li class="chapter-item "><a href="../features/security-headers.html"><strong aria-hidden="true">15.</strong> Security Headers</a></li><li class="chapter-item "><a href="../features/security-context.html"><strong aria-hidden="true">16.</strong> Security Context</a></li><li class="chapter-item "><a href="../features/csrf-protection.html"><strong aria-hidden="true">17.</strong> CSRF Protection</a></li><li class="chapter-item "><a href="../features/rate-limiting.html"><strong aria-hidden="true">18.</strong> Rate Limiting</a></li><li class="chapter-item "><a href="../features/account-locking.html"><strong aria-hidden="true">19.</strong> Account Locking</a></li><li class="chapter-item "><a href="../features/audit-logging.html"><strong aria-hidden="true">20.</strong> Audit Logging</a></li><li class="chapter-item "><a href="../features/remember-me.html"><strong aria-hidden="true">21.</strong> Remember-Me</a></li><li class="chapter-item "><a href="../features/channel-security.html"><strong aria-hidden="true">22.</strong> Channel Security</a></li><li class="chapter-item "><a href="../features/websocket.html"><strong aria-hidden="true">23.</strong> WebSocket Security</a></li><li class="chapter-item "><a href="../features/api-key.html"><strong aria-hidden="true">24.</strong> API Key Authentication</a></li><li class="chapter-item "><a href="../features/ldap.html"><strong aria-hidden="true">25.</strong> LDAP Authentication</a></li><li class="chapter-item "><a href="../features/saml.html"><strong aria-hidden="true">26.</strong> SAML 2.0 Authentication</a></li><li class="chapter-item affix "><li class="part-title">Advanced Topics</li><li class="chapter-item "><a href="../advanced/architecture.html"><strong aria-hidden="true">27.</strong> Architecture</a></li><li class="chapter-item "><a href="../advanced/extending.html"><strong aria-hidden="true">28.</strong> Extending the Framework</a></li><li class="chapter-item "><a href="../advanced/testing.html"><strong aria-hidden="true">29.</strong> Testing</a></li><li class="chapter-item affix "><li class="part-title">Reference</li><li class="chapter-item "><a href="../reference/api.html"><strong aria-hidden="true">30.</strong> API Documentation</a></li><li class="chapter-item "><a href="../reference/spring-comparison.html"><strong aria-hidden="true">31.</strong> Spring Security Comparison</a></li><li class="chapter-item "><a href="../reference/migration.html"><strong aria-hidden="true">32.</strong> Migration Guide</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Actix Security</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/tbounsiar/actix-security" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/tbounsiar/actix-security/edit/main/docs/src/expressions/custom.md" title="Suggest an edit" aria-label="Suggest an edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="custom-expressions"><a class="header" href="#custom-expressions">Custom Expressions</a></h1>
<p>Extend the security expression language with your own functions.</p>
<h2 id="custom-functions-with-parameter-references-v022"><a class="header" href="#custom-functions-with-parameter-references-v022">Custom Functions with Parameter References (v0.2.2+)</a></h2>
<p>The most powerful way to implement custom authorization is using async functions with parameter references. This approach allows you to reference handler parameters directly in your expressions, similar to Spring Security's SpEL:</p>
<h3 id="defining-custom-authorization-functions"><a class="header" href="#defining-custom-authorization-functions">Defining Custom Authorization Functions</a></h3>
<p>Create an async function that takes a user reference and any parameters you need:</p>
<pre><code class="language-rust">use actix_security::http::security::User;

/// Check if user is admin of a specific tenant
pub async fn is_tenant_admin(user: &amp;User, tenant_id: i64) -&gt; bool {
    // Admin users can access all tenants
    if user.has_role("ADMIN") {
        return true;
    }
    // Check tenant-specific authority
    user.has_authority(&amp;format!("tenant:{}:admin", tenant_id))
}

/// Check if user can access a specific resource
pub async fn can_access_resource(user: &amp;User, resource_id: String) -&gt; bool {
    // Your authorization logic here
    if user.has_role("ADMIN") {
        return true;
    }
    // Regular users can only access public resources
    resource_id.starts_with("public-")
}</code></pre>
<h3 id="using-parameter-references"><a class="header" href="#using-parameter-references">Using Parameter References</a></h3>
<p>Use <code>#param_name</code> to reference handler parameters in your expressions:</p>
<pre><code class="language-rust">use actix_web::{get, web::Path, HttpResponse, Responder};
use actix_security::pre_authorize;
use actix_security::http::security::AuthenticatedUser;

// Reference the tenant_id path parameter
#[pre_authorize("is_tenant_admin(#tenant_id)")]
#[get("/tenants/{tenant_id}")]
async fn get_tenant(
    tenant_id: Path&lt;i64&gt;,
    user: AuthenticatedUser,
) -&gt; impl Responder {
    HttpResponse::Ok().body(format!("Tenant {}", tenant_id.into_inner()))
}

// Reference a string path parameter
#[pre_authorize("can_access_resource(#resource_id)")]
#[get("/resources/{resource_id}")]
async fn get_resource(
    resource_id: Path&lt;String&gt;,
    user: AuthenticatedUser,
) -&gt; impl Responder {
    HttpResponse::Ok().body("Resource data")
}

// Combine with built-in functions
#[pre_authorize("hasRole('ADMIN') OR is_tenant_admin(#tenant_id)")]
#[get("/tenants/{tenant_id}/settings")]
async fn get_tenant_settings(
    tenant_id: Path&lt;i64&gt;,
    user: AuthenticatedUser,
) -&gt; impl Responder {
    HttpResponse::Ok().body("Settings")
}</code></pre>
<h3 id="supported-extractor-types"><a class="header" href="#supported-extractor-types">Supported Extractor Types</a></h3>
<p>Parameter references work with these Actix Web extractors:</p>
<div class="table-wrapper"><table><thead><tr><th>Extractor</th><th>Example</th><th>Description</th></tr></thead><tbody>
<tr><td><code>Path&lt;T&gt;</code></td><td><code>tenant_id: Path&lt;i64&gt;</code></td><td>URL path parameters</td></tr>
<tr><td><code>Query&lt;T&gt;</code></td><td><code>params: Query&lt;SearchParams&gt;</code></td><td>Query string parameters</td></tr>
<tr><td><code>Json&lt;T&gt;</code></td><td><code>body: Json&lt;CreateRequest&gt;</code></td><td>JSON request body</td></tr>
<tr><td><code>Form&lt;T&gt;</code></td><td><code>form: Form&lt;LoginForm&gt;</code></td><td>Form data</td></tr>
</tbody></table>
</div>
<p><strong>Important:</strong> For <code>Query&lt;T&gt;</code>, <code>Json&lt;T&gt;</code>, and <code>Form&lt;T&gt;</code>, the parameter reference must be the extractor parameter name, not individual fields within the struct. Your custom function should accept the full struct type:</p>
<pre><code class="language-rust">use serde::Deserialize;
use actix_web::{get, post, web};
use actix_security::pre_authorize;
use actix_security::http::security::{AuthenticatedUser, User};

// DTOs must implement Clone for parameter references
#[derive(Debug, Clone, Deserialize)]
pub struct SearchQuery {
    pub min_price: i32,
}

#[derive(Debug, Clone, Deserialize)]
pub struct CreateOrderRequest {
    pub amount: i64,
}

// Custom function accepts the full struct
pub async fn can_search_premium(user: &amp;User, query: SearchQuery) -&gt; bool {
    if user.has_role("ADMIN") {
        return true;
    }
    query.min_price &lt;= 100
}

pub async fn can_create_order(user: &amp;User, order: CreateOrderRequest) -&gt; bool {
    if user.has_role("ADMIN") {
        return true;
    }
    order.amount &lt;= 1000
}

// Reference the extractor parameter name (#query, not #min_price)
#[pre_authorize("can_search_premium(#query)")]
#[get("/products/search")]
async fn search_products(
    query: web::Query&lt;SearchQuery&gt;,
    user: AuthenticatedUser,
) -&gt; impl actix_web::Responder {
    actix_web::HttpResponse::Ok().body("Search results")
}

// Reference the extractor parameter name (#body, not #amount)
#[pre_authorize("can_create_order(#body)")]
#[post("/orders")]
async fn create_order(
    body: web::Json&lt;CreateOrderRequest&gt;,
    user: AuthenticatedUser,
) -&gt; impl actix_web::Responder {
    actix_web::HttpResponse::Created().body("Order created")
}</code></pre>
<h3 id="function-signature-requirements"><a class="header" href="#function-signature-requirements">Function Signature Requirements</a></h3>
<p>Custom authorization functions must:</p>
<ol>
<li>Be <code>async</code></li>
<li>Return <code>bool</code></li>
<li>Take <code>&amp;User</code> as the first parameter</li>
<li>Be in scope where the handler is defined</li>
</ol>
<pre><code class="language-rust">// ✓ Valid function signature
pub async fn my_check(user: &amp;User, param1: i64, param2: String) -&gt; bool {
    // ...
    true
}

// ✗ Invalid - not async
pub fn my_check(user: &amp;User, param: i64) -&gt; bool { true }

// ✗ Invalid - wrong return type
pub async fn my_check(user: &amp;User) -&gt; Result&lt;bool, Error&gt; { Ok(true) }

// ✗ Invalid - no user parameter
pub async fn my_check(param: i64) -&gt; bool { true }</code></pre>
<h3 id="spring-security-comparison"><a class="header" href="#spring-security-comparison">Spring Security Comparison</a></h3>
<p><strong>Spring Security (Java):</strong></p>
<pre><code class="language-java">@Service
public class TenantService {
    public boolean isTenantAdmin(Long tenantId) {
        // Uses SecurityContextHolder internally
        Authentication auth = SecurityContextHolder.getContext().getAuthentication();
        return checkTenantAdmin(auth, tenantId);
    }
}

@PreAuthorize("@tenantService.isTenantAdmin(#tenantId)")
@GetMapping("/tenants/{tenantId}")
public Tenant getTenant(@PathVariable Long tenantId) { }
</code></pre>
<p><strong>Actix Security (Rust):</strong></p>
<pre><code class="language-rust">pub async fn is_tenant_admin(user: &amp;User, tenant_id: i64) -&gt; bool {
    user.has_authority(&amp;format!("tenant:{}:admin", tenant_id))
}

#[pre_authorize("is_tenant_admin(#tenant_id)")]
#[get("/tenants/{tenant_id}")]
async fn get_tenant(tenant_id: Path&lt;i64&gt;, user: AuthenticatedUser) -&gt; impl Responder { }</code></pre>
<p>Key differences:</p>
<ul>
<li>In Rust, the user is passed explicitly (no thread-local storage)</li>
<li>Function name is used directly (no <code>@</code> prefix or bean reference)</li>
<li>Compile-time verification of parameter references</li>
</ul>
<hr />
<h2 id="the-expressionroot-trait"><a class="header" href="#the-expressionroot-trait">The ExpressionRoot Trait</a></h2>
<p>Custom expression functions are added by implementing <code>ExpressionRoot</code>:</p>
<pre><code class="language-rust">use actix_security::http::security::expression::ExpressionRoot;
use actix_security::http::security::User;

pub trait ExpressionRoot: Send + Sync {
    /// Evaluate a custom function.
    ///
    /// Returns:
    /// - `Some(true)` - Function matched and returned true
    /// - `Some(false)` - Function matched and returned false
    /// - `None` - Function not recognized, try default implementation
    fn evaluate_function(
        &amp;self,
        name: &amp;str,
        args: &amp;[String],
        user: Option&lt;&amp;User&gt;,
    ) -&gt; Option&lt;bool&gt;;
}</code></pre>
<h2 id="creating-a-custom-expressionroot"><a class="header" href="#creating-a-custom-expressionroot">Creating a Custom ExpressionRoot</a></h2>
<pre><code class="language-rust">use actix_security::http::security::expression::ExpressionRoot;
use actix_security::http::security::User;
use std::collections::HashSet;

#[derive(Clone)]
pub struct CustomExpressionRoot {
    premium_users: HashSet&lt;String&gt;,
    beta_features: HashSet&lt;String&gt;,
}

impl ExpressionRoot for CustomExpressionRoot {
    fn evaluate_function(
        &amp;self,
        name: &amp;str,
        args: &amp;[String],
        user: Option&lt;&amp;User&gt;,
    ) -&gt; Option&lt;bool&gt; {
        match name {
            // isPremium() - check if user has premium subscription
            "isPremium" =&gt; {
                let username = user?.username.clone();
                Some(self.premium_users.contains(&amp;username))
            }

            // hasBetaAccess('feature') - check beta feature access
            "hasBetaAccess" =&gt; {
                let feature = args.get(0)?;
                let user = user?;

                // Admins always have beta access
                if user.has_role("ADMIN") {
                    return Some(true);
                }

                // Check if feature is in beta and user has beta role
                Some(
                    self.beta_features.contains(feature)
                        &amp;&amp; user.has_role("BETA_TESTER"),
                )
            }

            // isOwner('resource_id') - check resource ownership
            "isOwner" =&gt; {
                let resource_id = args.get(0)?;
                let user = user?;
                // Your ownership logic
                Some(self.check_ownership(&amp;user.username, resource_id))
            }

            // Unknown function - return None to use default
            _ =&gt; None,
        }
    }
}

impl CustomExpressionRoot {
    fn check_ownership(&amp;self, username: &amp;str, resource_id: &amp;str) -&gt; bool {
        // Your database lookup logic
        true
    }
}</code></pre>
<h2 id="registering-custom-expressions"><a class="header" href="#registering-custom-expressions">Registering Custom Expressions</a></h2>
<p>Register your custom <code>ExpressionRoot</code> with the security configuration:</p>
<pre><code class="language-rust">use actix_security::http::security::expression::ExpressionEvaluator;

let custom_root = CustomExpressionRoot {
    premium_users: vec!["vip_user".to_string()].into_iter().collect(),
    beta_features: vec!["new_dashboard".to_string()].into_iter().collect(),
};

// Create evaluator with custom root
let evaluator = ExpressionEvaluator::with_root(Box::new(custom_root));</code></pre>
<h2 id="using-custom-functions"><a class="header" href="#using-custom-functions">Using Custom Functions</a></h2>
<p>Once registered, use your custom functions in expressions:</p>
<pre><code class="language-rust">// Check premium status
#[pre_authorize("isPremium()")]
#[get("/premium/content")]
async fn premium_content(user: AuthenticatedUser) -&gt; impl Responder {
    HttpResponse::Ok().body("Premium content")
}

// Check beta access
#[pre_authorize("hasBetaAccess('new_dashboard')")]
#[get("/beta/dashboard")]
async fn beta_dashboard(user: AuthenticatedUser) -&gt; impl Responder {
    HttpResponse::Ok().body("Beta dashboard")
}

// Combine with built-in functions
#[pre_authorize("hasRole('USER') AND isPremium()")]
#[get("/premium/profile")]
async fn premium_profile(user: AuthenticatedUser) -&gt; impl Responder {
    HttpResponse::Ok().body("Premium profile")
}

// Complex custom expression
#[pre_authorize("hasRole('ADMIN') OR (hasRole('USER') AND hasBetaAccess('feature'))")]
#[get("/feature")]
async fn feature(user: AuthenticatedUser) -&gt; impl Responder {
    HttpResponse::Ok().body("Feature")
}</code></pre>
<h2 id="spring-security-comparison-1"><a class="header" href="#spring-security-comparison-1">Spring Security Comparison</a></h2>
<p><strong>Spring Security:</strong></p>
<pre><code class="language-java">// Custom SecurityExpressionRoot
public class CustomSecurityExpressionRoot
    extends SecurityExpressionRoot
    implements MethodSecurityExpressionOperations {

    public boolean isPremium() {
        return premiumService.isPremium(getAuthentication().getName());
    }

    public boolean hasBetaAccess(String feature) {
        return betaService.hasAccess(getAuthentication(), feature);
    }
}

// Usage
@PreAuthorize("isPremium()")
public void premiumContent() {}

@PreAuthorize("hasBetaAccess('new_feature')")
public void betaFeature() {}
</code></pre>
<p><strong>Actix Security:</strong></p>
<pre><code class="language-rust">// Custom ExpressionRoot
impl ExpressionRoot for CustomExpressionRoot {
    fn evaluate_function(&amp;self, name: &amp;str, args: &amp;[String], user: Option&lt;&amp;User&gt;) -&gt; Option&lt;bool&gt; {
        match name {
            "isPremium" =&gt; Some(self.premium_service.is_premium(user?)),
            "hasBetaAccess" =&gt; Some(self.beta_service.has_access(user?, args.get(0)?)),
            _ =&gt; None,
        }
    }
}

// Usage
#[pre_authorize("isPremium()")]
async fn premium_content() {}

#[pre_authorize("hasBetaAccess('new_feature')")]
async fn beta_feature() {}</code></pre>
<h2 id="example-organization-based-access"><a class="header" href="#example-organization-based-access">Example: Organization-Based Access</a></h2>
<pre><code class="language-rust">#[derive(Clone)]
pub struct OrgExpressionRoot {
    org_service: OrgService,
}

impl ExpressionRoot for OrgExpressionRoot {
    fn evaluate_function(
        &amp;self,
        name: &amp;str,
        args: &amp;[String],
        user: Option&lt;&amp;User&gt;,
    ) -&gt; Option&lt;bool&gt; {
        match name {
            // belongsToOrg('org_id') - user belongs to organization
            "belongsToOrg" =&gt; {
                let org_id = args.get(0)?;
                let user = user?;
                Some(self.org_service.user_belongs_to(&amp;user.username, org_id))
            }

            // isOrgAdmin('org_id') - user is admin of organization
            "isOrgAdmin" =&gt; {
                let org_id = args.get(0)?;
                let user = user?;
                Some(self.org_service.is_org_admin(&amp;user.username, org_id))
            }

            // hasOrgPermission('org_id', 'permission')
            "hasOrgPermission" =&gt; {
                let org_id = args.get(0)?;
                let permission = args.get(1)?;
                let user = user?;
                Some(self.org_service.has_permission(&amp;user.username, org_id, permission))
            }

            _ =&gt; None,
        }
    }
}

// Usage
#[pre_authorize("belongsToOrg('acme-corp')")]
async fn org_dashboard() {}

#[pre_authorize("isOrgAdmin('acme-corp') OR hasRole('SUPER_ADMIN')")]
async fn org_settings() {}

#[pre_authorize("hasOrgPermission('acme-corp', 'billing:manage')")]
async fn billing() {}</code></pre>
<h2 id="best-practices"><a class="header" href="#best-practices">Best Practices</a></h2>
<h3 id="1-return-none-for-unknown-functions"><a class="header" href="#1-return-none-for-unknown-functions">1. Return None for Unknown Functions</a></h3>
<p>Allow fallback to default implementation:</p>
<pre><code class="language-rust">fn evaluate_function(&amp;self, name: &amp;str, args: &amp;[String], user: Option&lt;&amp;User&gt;) -&gt; Option&lt;bool&gt; {
    match name {
        "myFunction" =&gt; Some(/* ... */),
        _ =&gt; None,  // Important: let default handle unknown functions
    }
}</code></pre>
<h3 id="2-handle-missing-user"><a class="header" href="#2-handle-missing-user">2. Handle Missing User</a></h3>
<p>Return <code>false</code> or <code>None</code> when user is required but missing:</p>
<pre><code class="language-rust">"isPremium" =&gt; {
    let user = user?;  // Returns None if no user
    Some(self.check_premium(&amp;user.username))
}</code></pre>
<h3 id="3-validate-arguments"><a class="header" href="#3-validate-arguments">3. Validate Arguments</a></h3>
<p>Check for required arguments:</p>
<pre><code class="language-rust">"hasFeature" =&gt; {
    let feature = args.get(0)?;  // Returns None if missing
    Some(self.check_feature(feature))
}</code></pre>
<h3 id="4-keep-functions-simple"><a class="header" href="#4-keep-functions-simple">4. Keep Functions Simple</a></h3>
<p>Complex logic should live in services:</p>
<pre><code class="language-rust">// Good
"isPremium" =&gt; Some(self.premium_service.is_premium(user?))

// Bad - too much logic in expression root
"isPremium" =&gt; {
    let user = user?;
    let subscription = db.query_subscription(&amp;user.id)?;
    Some(subscription.tier == "premium" &amp;&amp; subscription.expires &gt; now())
}</code></pre>
<h3 id="5-document-your-functions"><a class="header" href="#5-document-your-functions">5. Document Your Functions</a></h3>
<pre><code class="language-rust">/// Custom expression functions for MyApp.
///
/// Available functions:
/// - `isPremium()` - Returns true if user has premium subscription
/// - `hasBetaAccess('feature')` - Returns true if user can access beta feature
/// - `isOrgMember('org_id')` - Returns true if user belongs to organization
impl ExpressionRoot for MyExpressionRoot { /* ... */ }</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../expressions/builtin.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../features/security-headers.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../expressions/builtin.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../features/security-headers.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>



        <script>
            window.playground_line_numbers = true;
        </script>

        <script>
            window.playground_copyable = true;
        </script>

        <script src="../ace.js"></script>
        <script src="../editor.js"></script>
        <script src="../mode-rust.js"></script>
        <script src="../theme-dawn.js"></script>
        <script src="../theme-tomorrow_night.js"></script>

        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->
        <script src="../theme/pagetoc.js"></script>
        <script src="../theme/version-selector.js"></script>


    </div>
    </body>
</html>
