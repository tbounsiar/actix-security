<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Actix Security</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="Spring Security-inspired authentication and authorization for Actix Web">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="theme/pagetoc.css">

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "ayu" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item affix "><a href="introduction.html">Introduction</a></li><li class="chapter-item affix "><li class="part-title">Getting Started</li><li class="chapter-item "><a href="getting-started/quick-start.html"><strong aria-hidden="true">1.</strong> Quick Start</a></li><li class="chapter-item "><a href="getting-started/installation.html"><strong aria-hidden="true">2.</strong> Installation</a></li><li class="chapter-item "><a href="getting-started/first-app.html"><strong aria-hidden="true">3.</strong> Your First Secured App</a></li><li class="chapter-item affix "><li class="part-title">Core Concepts</li><li class="chapter-item "><a href="authentication/index.html"><strong aria-hidden="true">4.</strong> Authentication</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="authentication/memory.html"><strong aria-hidden="true">4.1.</strong> In-Memory Authentication</a></li><li class="chapter-item "><a href="authentication/password-encoding.html"><strong aria-hidden="true">4.2.</strong> Password Encoding</a></li><li class="chapter-item "><a href="authentication/http-basic.html"><strong aria-hidden="true">4.3.</strong> HTTP Basic</a></li><li class="chapter-item "><a href="authentication/jwt.html"><strong aria-hidden="true">4.4.</strong> JWT Authentication</a></li><li class="chapter-item "><a href="authentication/session-auth.html"><strong aria-hidden="true">4.5.</strong> Session Authentication</a></li><li class="chapter-item "><a href="authentication/oauth2.html"><strong aria-hidden="true">4.6.</strong> OAuth2 / OIDC</a></li><li class="chapter-item "><a href="authentication/custom.html"><strong aria-hidden="true">4.7.</strong> Custom Authenticators</a></li></ol></li><li class="chapter-item "><a href="authorization/index.html"><strong aria-hidden="true">5.</strong> Authorization</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="authorization/url-based.html"><strong aria-hidden="true">5.1.</strong> URL-Based Authorization</a></li><li class="chapter-item "><a href="authorization/method-security.html"><strong aria-hidden="true">5.2.</strong> Method Security</a></li><li class="chapter-item "><a href="authorization/roles-authorities.html"><strong aria-hidden="true">5.3.</strong> Roles vs Authorities</a></li><li class="chapter-item "><a href="authorization/custom.html"><strong aria-hidden="true">5.4.</strong> Custom Authorizers</a></li></ol></li><li class="chapter-item "><li class="part-title">Macros & Annotations</li><li class="chapter-item "><a href="macros/index.html"><strong aria-hidden="true">6.</strong> Overview</a></li><li class="chapter-item "><a href="macros/secured.html"><strong aria-hidden="true">7.</strong> @secured</a></li><li class="chapter-item "><a href="macros/pre-authorize.html"><strong aria-hidden="true">8.</strong> @pre_authorize</a></li><li class="chapter-item "><a href="macros/permit-all.html"><strong aria-hidden="true">9.</strong> @permit_all</a></li><li class="chapter-item "><a href="macros/deny-all.html"><strong aria-hidden="true">10.</strong> @deny_all</a></li><li class="chapter-item "><a href="macros/roles-allowed.html"><strong aria-hidden="true">11.</strong> @roles_allowed</a></li><li class="chapter-item affix "><li class="part-title">Security Expressions</li><li class="chapter-item "><a href="expressions/index.html"><strong aria-hidden="true">12.</strong> Expression Language</a></li><li class="chapter-item "><a href="expressions/builtin.html"><strong aria-hidden="true">13.</strong> Built-in Functions</a></li><li class="chapter-item "><a href="expressions/custom.html"><strong aria-hidden="true">14.</strong> Custom Expressions</a></li><li class="chapter-item affix "><li class="part-title">Additional Features</li><li class="chapter-item "><a href="features/security-headers.html"><strong aria-hidden="true">15.</strong> Security Headers</a></li><li class="chapter-item "><a href="features/security-context.html"><strong aria-hidden="true">16.</strong> Security Context</a></li><li class="chapter-item "><a href="features/csrf-protection.html"><strong aria-hidden="true">17.</strong> CSRF Protection</a></li><li class="chapter-item "><a href="features/rate-limiting.html"><strong aria-hidden="true">18.</strong> Rate Limiting</a></li><li class="chapter-item "><a href="features/account-locking.html"><strong aria-hidden="true">19.</strong> Account Locking</a></li><li class="chapter-item "><a href="features/audit-logging.html"><strong aria-hidden="true">20.</strong> Audit Logging</a></li><li class="chapter-item "><a href="features/remember-me.html"><strong aria-hidden="true">21.</strong> Remember-Me</a></li><li class="chapter-item "><a href="features/channel-security.html"><strong aria-hidden="true">22.</strong> Channel Security</a></li><li class="chapter-item "><a href="features/websocket.html"><strong aria-hidden="true">23.</strong> WebSocket Security</a></li><li class="chapter-item "><a href="features/api-key.html"><strong aria-hidden="true">24.</strong> API Key Authentication</a></li><li class="chapter-item "><a href="features/ldap.html"><strong aria-hidden="true">25.</strong> LDAP Authentication</a></li><li class="chapter-item "><a href="features/saml.html"><strong aria-hidden="true">26.</strong> SAML 2.0 Authentication</a></li><li class="chapter-item affix "><li class="part-title">Advanced Topics</li><li class="chapter-item "><a href="advanced/architecture.html"><strong aria-hidden="true">27.</strong> Architecture</a></li><li class="chapter-item "><a href="advanced/extending.html"><strong aria-hidden="true">28.</strong> Extending the Framework</a></li><li class="chapter-item "><a href="advanced/testing.html"><strong aria-hidden="true">29.</strong> Testing</a></li><li class="chapter-item affix "><li class="part-title">Reference</li><li class="chapter-item "><a href="reference/api.html"><strong aria-hidden="true">30.</strong> API Documentation</a></li><li class="chapter-item "><a href="reference/spring-comparison.html"><strong aria-hidden="true">31.</strong> Spring Security Comparison</a></li><li class="chapter-item "><a href="reference/migration.html"><strong aria-hidden="true">32.</strong> Migration Guide</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Actix Security</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/tbounsiar/actix-security" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p><strong>Actix Security</strong> is a comprehensive authentication and authorization framework for <a href="https://actix.rs/">Actix Web</a>, inspired by <a href="https://spring.io/projects/spring-security">Spring Security</a>. It provides a familiar, declarative approach to securing your Rust web applications.</p>
<h2 id="why-actix-security"><a class="header" href="#why-actix-security">Why Actix Security?</a></h2>
<p>If you're coming from the Java/Spring ecosystem, you'll feel right at home. Actix Security brings Spring Security's powerful concepts to Rust:</p>
<ul>
<li><strong>Declarative Security</strong> - Use attribute macros like <code>#[secured]</code>, <code>#[pre_authorize]</code>, and <code>#[roles_allowed]</code></li>
<li><strong>Expression Language</strong> - Write security rules like <code>hasRole('ADMIN') OR hasAuthority('users:write')</code></li>
<li><strong>Pluggable Architecture</strong> - Easily swap authentication and authorization implementations</li>
<li><strong>Zero Runtime Overhead</strong> - Security expressions are compiled at build time</li>
</ul>
<h2 id="features"><a class="header" href="#features">Features</a></h2>
<h3 id="authentication"><a class="header" href="#authentication">Authentication</a></h3>
<ul>
<li>In-memory user store for development and testing</li>
<li>HTTP Basic authentication</li>
<li>Pluggable password encoders (Argon2, NoOp, Delegating)</li>
<li>Custom authenticator support via traits</li>
</ul>
<h3 id="authorization"><a class="header" href="#authorization">Authorization</a></h3>
<ul>
<li>URL pattern-based authorization (regex support)</li>
<li>Method-level security with attribute macros</li>
<li>Role-based access control (RBAC)</li>
<li>Fine-grained authority/permission checks</li>
<li>Spring Security Expression Language (SpEL-like)</li>
</ul>
<h3 id="security-macros"><a class="header" href="#security-macros">Security Macros</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Macro</th><th>Spring Equivalent</th><th>Description</th></tr></thead><tbody>
<tr><td><code>#[secured("ADMIN")]</code></td><td><code>@Secured("ROLE_ADMIN")</code></td><td>Role-based access</td></tr>
<tr><td><code>#[pre_authorize(...)]</code></td><td><code>@PreAuthorize(...)</code></td><td>Expression-based access</td></tr>
<tr><td><code>#[permit_all]</code></td><td><code>@PermitAll</code></td><td>Public access</td></tr>
<tr><td><code>#[deny_all]</code></td><td><code>@DenyAll</code></td><td>Deny all access</td></tr>
<tr><td><code>#[roles_allowed("ADMIN")]</code></td><td><code>@RolesAllowed("ADMIN")</code></td><td>Java EE style</td></tr>
</tbody></table>
</div>
<h3 id="additional-features"><a class="header" href="#additional-features">Additional Features</a></h3>
<ul>
<li>Security headers middleware (CSP, HSTS, X-Frame-Options, etc.)</li>
<li>Security context for accessing the current user anywhere</li>
<li>Extensible expression language</li>
</ul>
<h2 id="quick-example"><a class="header" href="#quick-example">Quick Example</a></h2>
<pre><code class="language-rust">use actix_web::{get, App, HttpServer, HttpResponse, Responder};
use actix_security::{secured, pre_authorize};
use actix_security::http::security::{
    AuthenticatedUser, AuthenticationManager, AuthorizationManager,
    Argon2PasswordEncoder, PasswordEncoder, User,
};
use actix_security::http::security::middleware::SecurityTransform;

// Role-based security
#[secured("ADMIN")]
#[get("/admin/dashboard")]
async fn admin_dashboard(user: AuthenticatedUser) -&gt; impl Responder {
    HttpResponse::Ok().body(format!("Welcome, Admin {}!", user.get_username()))
}

// Expression-based security
#[pre_authorize("hasRole('USER') AND hasAuthority('posts:write')")]
#[get("/posts/new")]
async fn create_post(user: AuthenticatedUser) -&gt; impl Responder {
    HttpResponse::Ok().body("Create a new post")
}

#[actix_web::main]
async fn main() -&gt; std::io::Result&lt;()&gt; {
    let encoder = Argon2PasswordEncoder::new();

    HttpServer::new(move || {
        let enc = encoder.clone();
        App::new()
            .wrap(
                SecurityTransform::new()
                    .config_authenticator(move || {
                        AuthenticationManager::in_memory_authentication()
                            .password_encoder(enc.clone())
                            .with_user(
                                User::with_encoded_password("admin", enc.encode("secret"))
                                    .roles(&amp;["ADMIN".into(), "USER".into()])
                                    .authorities(&amp;["posts:write".into()])
                            )
                    })
                    .config_authorizer(|| {
                        AuthorizationManager::request_matcher()
                            .login_url("/login")
                            .http_basic()
                    })
            )
            .service(admin_dashboard)
            .service(create_post)
    })
    .bind("127.0.0.1:8080")?
    .run()
    .await
}</code></pre>
<h2 id="getting-help"><a class="header" href="#getting-help">Getting Help</a></h2>
<ul>
<li><a href="https://github.com/your-org/actix-security/issues">GitHub Issues</a> - Bug reports and feature requests</li>
<li><a href="https://docs.rs/actix-security">API Documentation</a> - Detailed API reference</li>
</ul>
<h2 id="license"><a class="header" href="#license">License</a></h2>
<p>This project is licensed under the MIT License.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="quick-start"><a class="header" href="#quick-start">Quick Start</a></h1>
<p>Get up and running with Actix Security in 5 minutes.</p>
<h2 id="prerequisites"><a class="header" href="#prerequisites">Prerequisites</a></h2>
<ul>
<li>Rust 1.70 or later</li>
<li>Cargo</li>
</ul>
<h2 id="step-1-add-dependencies"><a class="header" href="#step-1-add-dependencies">Step 1: Add Dependencies</a></h2>
<p>Add the following to your <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[dependencies]
actix-web = "4"
actix-security = { version = "0.2", features = ["argon2", "http-basic"] }
tokio = { version = "1", features = ["macros", "rt-multi-thread"] }
</code></pre>
<h2 id="step-2-create-a-simple-secured-application"><a class="header" href="#step-2-create-a-simple-secured-application">Step 2: Create a Simple Secured Application</a></h2>
<pre><code class="language-rust">use actix_web::{get, web, App, HttpServer, HttpResponse, Responder};
use actix_security::secured;
use actix_security::http::security::{
    AuthenticatedUser, AuthenticationManager, AuthorizationManager,
    Argon2PasswordEncoder, PasswordEncoder, User,
};
use actix_security::http::security::middleware::SecurityTransform;

// Public endpoint
#[get("/")]
async fn index() -&gt; impl Responder {
    HttpResponse::Ok().body("Welcome! Login at /login")
}

// Secured endpoint - requires USER role
#[secured("USER")]
#[get("/profile")]
async fn profile(user: AuthenticatedUser) -&gt; impl Responder {
    HttpResponse::Ok().body(format!("Hello, {}!", user.get_username()))
}

// Admin-only endpoint
#[secured("ADMIN")]
#[get("/admin")]
async fn admin(user: AuthenticatedUser) -&gt; impl Responder {
    HttpResponse::Ok().body(format!("Admin Panel - Welcome {}!", user.get_username()))
}

#[actix_web::main]
async fn main() -&gt; std::io::Result&lt;()&gt; {
    println!("Starting server at http://127.0.0.1:8080");
    println!("Try: curl -u user:password http://127.0.0.1:8080/profile");
    println!("Try: curl -u admin:admin http://127.0.0.1:8080/admin");

    let encoder = Argon2PasswordEncoder::new();

    HttpServer::new(move || {
        let enc = encoder.clone();
        App::new()
            .wrap(
                SecurityTransform::new()
                    .config_authenticator(move || {
                        AuthenticationManager::in_memory_authentication()
                            .password_encoder(enc.clone())
                            .with_user(
                                User::with_encoded_password("user", enc.encode("password"))
                                    .roles(&amp;["USER".into()])
                            )
                            .with_user(
                                User::with_encoded_password("admin", enc.encode("admin"))
                                    .roles(&amp;["ADMIN".into(), "USER".into()])
                            )
                    })
                    .config_authorizer(|| {
                        AuthorizationManager::request_matcher()
                            .login_url("/login")
                            .http_basic()
                    })
            )
            .service(index)
            .service(profile)
            .service(admin)
    })
    .bind("127.0.0.1:8080")?
    .run()
    .await
}</code></pre>
<h2 id="step-3-test-your-application"><a class="header" href="#step-3-test-your-application">Step 3: Test Your Application</a></h2>
<pre><code class="language-bash"># Run the server
cargo run

# Test public endpoint
curl http://127.0.0.1:8080/

# Test with user credentials
curl -u user:password http://127.0.0.1:8080/profile
# Output: Hello, user!

# Test admin endpoint with user (should fail)
curl -u user:password http://127.0.0.1:8080/admin
# Output: 403 Forbidden

# Test admin endpoint with admin
curl -u admin:admin http://127.0.0.1:8080/admin
# Output: Admin Panel - Welcome admin!
</code></pre>
<h2 id="whats-next"><a class="header" href="#whats-next">What's Next?</a></h2>
<ul>
<li>Learn about <a href="getting-started/./installation.html">Installation</a> options</li>
<li>Build <a href="getting-started/./first-app.html">Your First Secured App</a> step by step</li>
<li>Explore <a href="getting-started/../authentication/index.html">Authentication</a> options</li>
<li>Understand <a href="getting-started/../authorization/index.html">Authorization</a> patterns</li>
<li>Master <a href="getting-started/../macros/index.html">Security Macros</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="installation"><a class="header" href="#installation">Installation</a></h1>
<h2 id="cargo-dependencies"><a class="header" href="#cargo-dependencies">Cargo Dependencies</a></h2>
<p>Add the following to your <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[dependencies]
actix-security = "0.2"
</code></pre>
<h2 id="feature-flags"><a class="header" href="#feature-flags">Feature Flags</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Feature</th><th>Default</th><th>Description</th></tr></thead><tbody>
<tr><td><code>macros</code></td><td>‚úì</td><td>Procedural macros (<code>#[secured]</code>, <code>#[pre_authorize]</code>, etc.)</td></tr>
<tr><td><code>argon2</code></td><td>‚úì</td><td>Enables Argon2 password encoding</td></tr>
<tr><td><code>http-basic</code></td><td>‚úì</td><td>Enables HTTP Basic authentication</td></tr>
<tr><td><code>jwt</code></td><td></td><td>Enables JWT authentication</td></tr>
<tr><td><code>session</code></td><td></td><td>Enables Session-based authentication</td></tr>
<tr><td><code>oauth2</code></td><td></td><td>Enables OAuth2/OIDC authentication</td></tr>
<tr><td><code>full</code></td><td></td><td>All features enabled</td></tr>
</tbody></table>
</div>
<h3 id="minimal-installation"><a class="header" href="#minimal-installation">Minimal Installation</a></h3>
<p>For a minimal installation without optional features:</p>
<pre><code class="language-toml">[dependencies]
actix-security = { version = "0.2", default-features = false }
</code></pre>
<h3 id="full-installation"><a class="header" href="#full-installation">Full Installation</a></h3>
<p>For all features:</p>
<pre><code class="language-toml">[dependencies]
actix-security = { version = "0.2", features = ["full"] }
</code></pre>
<h2 id="compatibility"><a class="header" href="#compatibility">Compatibility</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Actix Security</th><th>Actix Web</th><th>Rust</th></tr></thead><tbody>
<tr><td>0.2.x</td><td>4.x</td><td>1.78+</td></tr>
<tr><td>0.1.x</td><td>4.x</td><td>1.70+</td></tr>
</tbody></table>
</div>
<h2 id="crate-overview"><a class="header" href="#crate-overview">Crate Overview</a></h2>
<p>The <code>actix-security</code> crate provides:</p>
<p><strong>Core Features:</strong></p>
<ul>
<li>Security middleware (<code>SecurityTransform</code>)</li>
<li>Authentication (<code>MemoryAuthenticator</code>, <code>Authenticator</code> trait)</li>
<li>Authorization (<code>RequestMatcherAuthorizer</code>, <code>Authorizer</code> trait)</li>
<li>Password encoding (<code>Argon2PasswordEncoder</code>, <code>DelegatingPasswordEncoder</code>)</li>
<li>User model (<code>User</code>, <code>AuthenticatedUser</code>)</li>
<li>Security headers middleware (<code>SecurityHeaders</code>)</li>
<li>Security context (<code>SecurityContext</code>)</li>
<li>Expression evaluation</li>
</ul>
<p><strong>Procedural Macros (with <code>macros</code> feature):</strong></p>
<ul>
<li><code>#[secured]</code> - Role-based method security</li>
<li><code>#[pre_authorize]</code> - Expression-based method security</li>
<li><code>#[permit_all]</code> - Mark endpoints as public</li>
<li><code>#[deny_all]</code> - Block all access</li>
<li><code>#[roles_allowed]</code> - Java EE style role checks</li>
</ul>
<h2 id="verifying-installation"><a class="header" href="#verifying-installation">Verifying Installation</a></h2>
<p>Create a simple test to verify everything is working:</p>
<pre><code class="language-rust">use actix_security::http::security::{
    AuthenticationManager, Argon2PasswordEncoder, PasswordEncoder, User
};
use actix_security::secured;

#[test]
fn test_installation() {
    // Test password encoding
    let encoder = Argon2PasswordEncoder::new();
    let encoded = encoder.encode("test");
    assert!(encoder.matches("test", &amp;encoded));

    // Test user creation
    let user = User::with_encoded_password("test", encoded)
        .roles(&amp;["USER".into()]);
    assert_eq!(user.username, "test");
    assert!(user.roles.contains(&amp;"USER".into()));
}</code></pre>
<p>Run with:</p>
<pre><code class="language-bash">cargo test test_installation
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="your-first-secured-app"><a class="header" href="#your-first-secured-app">Your First Secured App</a></h1>
<p>This guide walks you through building a complete secured application step by step.</p>
<h2 id="what-well-build"><a class="header" href="#what-well-build">What We'll Build</a></h2>
<p>A simple REST API with:</p>
<ul>
<li>Public endpoints (no auth required)</li>
<li>User-only endpoints (requires USER role)</li>
<li>Admin-only endpoints (requires ADMIN role)</li>
<li>Authority-based endpoints (requires specific permissions)</li>
</ul>
<h2 id="project-setup"><a class="header" href="#project-setup">Project Setup</a></h2>
<pre><code class="language-bash">cargo new my-secured-app
cd my-secured-app
</code></pre>
<p>Update <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[package]
name = "my-secured-app"
version = "0.1.0"
edition = "2021"

[dependencies]
actix-web = "4"
actix-security = { version = "0.2", features = ["argon2", "http-basic"] }
tokio = { version = "1", features = ["macros", "rt-multi-thread"] }
</code></pre>
<h2 id="step-1-define-your-users"><a class="header" href="#step-1-define-your-users">Step 1: Define Your Users</a></h2>
<p>First, create a function that configures your user store:</p>
<pre><code class="language-rust">use actix_security::http::security::{
    AuthenticationManager, Argon2PasswordEncoder, PasswordEncoder, User,
};
use actix_security::http::security::web::MemoryAuthenticator;

fn create_authenticator(encoder: Argon2PasswordEncoder) -&gt; MemoryAuthenticator {
    AuthenticationManager::in_memory_authentication()
        .password_encoder(encoder.clone())
        // Admin user with full access
        .with_user(
            User::with_encoded_password("admin", encoder.encode("admin123"))
                .roles(&amp;["ADMIN".into(), "USER".into()])
                .authorities(&amp;[
                    "users:read".into(),
                    "users:write".into(),
                    "posts:read".into(),
                    "posts:write".into(),
                ])
        )
        // Regular user
        .with_user(
            User::with_encoded_password("user", encoder.encode("user123"))
                .roles(&amp;["USER".into()])
                .authorities(&amp;["posts:read".into()])
        )
        // Guest with limited access
        .with_user(
            User::with_encoded_password("guest", encoder.encode("guest123"))
                .roles(&amp;["GUEST".into()])
        )
}</code></pre>
<h2 id="step-2-configure-url-based-authorization"><a class="header" href="#step-2-configure-url-based-authorization">Step 2: Configure URL-Based Authorization</a></h2>
<p>Create rules for URL patterns:</p>
<pre><code class="language-rust">use actix_security::http::security::{AuthorizationManager, Access};
use actix_security::http::security::web::RequestMatcherAuthorizer;

fn create_authorizer() -&gt; RequestMatcherAuthorizer {
    AuthorizationManager::request_matcher()
        .login_url("/login")
        .http_basic()
        // Admin section requires ADMIN role
        .add_matcher("/admin/.*", Access::new().roles(vec!["ADMIN"]))
        // API requires authentication
        .add_matcher("/api/.*", Access::new().authenticated())
        // Everything else is public
}</code></pre>
<h2 id="step-3-create-your-handlers"><a class="header" href="#step-3-create-your-handlers">Step 3: Create Your Handlers</a></h2>
<pre><code class="language-rust">use actix_web::{get, post, web, HttpResponse, Responder};
use actix_security::{secured, pre_authorize, permit_all};
use actix_security::http::security::AuthenticatedUser;

// ============= Public Endpoints =============

#[permit_all]
#[get("/")]
async fn index() -&gt; impl Responder {
    HttpResponse::Ok().body("Welcome to My App!")
}

#[permit_all]
#[get("/health")]
async fn health() -&gt; impl Responder {
    HttpResponse::Ok().body("OK")
}

// ============= User Endpoints =============

#[secured("USER")]
#[get("/profile")]
async fn get_profile(user: AuthenticatedUser) -&gt; impl Responder {
    HttpResponse::Ok().body(format!(
        "Profile for: {}\nRoles: {:?}\nAuthorities: {:?}",
        user.get_username(),
        user.get_roles(),
        user.get_authorities()
    ))
}

#[pre_authorize("hasRole('USER') AND hasAuthority('posts:read')")]
#[get("/posts")]
async fn list_posts(user: AuthenticatedUser) -&gt; impl Responder {
    HttpResponse::Ok().body(format!("Posts for {}", user.get_username()))
}

#[pre_authorize(authority = "posts:write")]
#[post("/posts")]
async fn create_post(user: AuthenticatedUser) -&gt; impl Responder {
    HttpResponse::Created().body(format!("Post created by {}", user.get_username()))
}

// ============= Admin Endpoints =============

#[secured("ADMIN")]
#[get("/admin/dashboard")]
async fn admin_dashboard(user: AuthenticatedUser) -&gt; impl Responder {
    HttpResponse::Ok().body(format!("Admin Dashboard - Welcome {}!", user.get_username()))
}

#[pre_authorize("hasRole('ADMIN') AND hasAuthority('users:write')")]
#[post("/admin/users")]
async fn create_user(user: AuthenticatedUser) -&gt; impl Responder {
    HttpResponse::Created().body("User created")
}</code></pre>
<h2 id="step-4-wire-it-all-together"><a class="header" href="#step-4-wire-it-all-together">Step 4: Wire It All Together</a></h2>
<pre><code class="language-rust">use actix_web::{App, HttpServer};
use actix_security::http::security::middleware::SecurityTransform;
use actix_security::http::security::SecurityHeaders;

#[actix_web::main]
async fn main() -&gt; std::io::Result&lt;()&gt; {
    println!("üöÄ Starting secured server at http://127.0.0.1:8080");

    let encoder = Argon2PasswordEncoder::new();

    HttpServer::new(move || {
        let enc = encoder.clone();
        App::new()
            // Add security headers
            .wrap(SecurityHeaders::default())
            // Add authentication &amp; authorization
            .wrap(
                SecurityTransform::new()
                    .config_authenticator(move || create_authenticator(enc.clone()))
                    .config_authorizer(create_authorizer)
            )
            // Register routes
            .service(index)
            .service(health)
            .service(get_profile)
            .service(list_posts)
            .service(create_post)
            .service(admin_dashboard)
            .service(create_user)
    })
    .bind("127.0.0.1:8080")?
    .run()
    .await
}</code></pre>
<h2 id="step-5-test-your-application"><a class="header" href="#step-5-test-your-application">Step 5: Test Your Application</a></h2>
<pre><code class="language-bash"># Start the server
cargo run
</code></pre>
<h3 id="test-public-endpoints"><a class="header" href="#test-public-endpoints">Test Public Endpoints</a></h3>
<pre><code class="language-bash">curl http://127.0.0.1:8080/
# Output: Welcome to My App!

curl http://127.0.0.1:8080/health
# Output: OK
</code></pre>
<h3 id="test-user-endpoints"><a class="header" href="#test-user-endpoints">Test User Endpoints</a></h3>
<pre><code class="language-bash"># Guest can't access profile
curl -u guest:guest123 http://127.0.0.1:8080/profile
# Output: 403 Forbidden

# User can access profile
curl -u user:user123 http://127.0.0.1:8080/profile
# Output: Profile for: user...

# User can read posts
curl -u user:user123 http://127.0.0.1:8080/posts
# Output: Posts for user

# User can't create posts (no posts:write authority)
curl -X POST -u user:user123 http://127.0.0.1:8080/posts
# Output: 403 Forbidden
</code></pre>
<h3 id="test-admin-endpoints"><a class="header" href="#test-admin-endpoints">Test Admin Endpoints</a></h3>
<pre><code class="language-bash"># Admin can access everything
curl -u admin:admin123 http://127.0.0.1:8080/admin/dashboard
# Output: Admin Dashboard - Welcome admin!

curl -X POST -u admin:admin123 http://127.0.0.1:8080/posts
# Output: Post created by admin

curl -X POST -u admin:admin123 http://127.0.0.1:8080/admin/users
# Output: User created

# Regular user can't access admin
curl -u user:user123 http://127.0.0.1:8080/admin/dashboard
# Output: 403 Forbidden
</code></pre>
<h2 id="complete-source-code"><a class="header" href="#complete-source-code">Complete Source Code</a></h2>
<p>See the full working example in the <a href="https://github.com/your-org/actix-security/tree/main/test">test crate</a>.</p>
<h2 id="next-steps"><a class="header" href="#next-steps">Next Steps</a></h2>
<ul>
<li>Learn about different <a href="getting-started/../authentication/index.html">Authentication</a> methods</li>
<li>Explore <a href="getting-started/../authorization/index.html">Authorization</a> patterns</li>
<li>Master <a href="getting-started/../expressions/index.html">Security Expressions</a></li>
<li>Add <a href="getting-started/../features/security-headers.html">Security Headers</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="authentication-1"><a class="header" href="#authentication-1">Authentication</a></h1>
<p>Authentication is the process of verifying <strong>who</strong> a user is. Actix Security provides a flexible authentication system inspired by Spring Security.</p>
<h2 id="core-concepts"><a class="header" href="#core-concepts">Core Concepts</a></h2>
<h3 id="the-authenticator-trait"><a class="header" href="#the-authenticator-trait">The Authenticator Trait</a></h3>
<p>All authentication is handled through the <code>Authenticator</code> trait:</p>
<pre><code class="language-rust">pub trait Authenticator: Clone + Send + Sync + 'static {
    /// Authenticate a request and return the user if successful.
    fn get_user(&amp;self, req: &amp;ServiceRequest) -&gt; Option&lt;User&gt;;
}</code></pre>
<p>Implement this trait to create custom authentication mechanisms.</p>
<h3 id="the-user-model"><a class="header" href="#the-user-model">The User Model</a></h3>
<p>A <code>User</code> represents an authenticated identity:</p>
<pre><code class="language-rust">pub struct User {
    pub username: String,
    pub password: String,  // Encoded password
    pub roles: HashSet&lt;String&gt;,
    pub authorities: HashSet&lt;String&gt;,
}</code></pre>
<h3 id="authenticateduser-extractor"><a class="header" href="#authenticateduser-extractor">AuthenticatedUser Extractor</a></h3>
<p>In your handlers, use <code>AuthenticatedUser</code> to access the current user:</p>
<pre><code class="language-rust">use actix_security::http::security::AuthenticatedUser;

#[get("/profile")]
async fn profile(user: AuthenticatedUser) -&gt; impl Responder {
    HttpResponse::Ok().body(format!("Hello, {}!", user.get_username()))
}</code></pre>
<h2 id="built-in-authenticators"><a class="header" href="#built-in-authenticators">Built-in Authenticators</a></h2>
<h3 id="memoryauthenticator"><a class="header" href="#memoryauthenticator">MemoryAuthenticator</a></h3>
<p>An in-memory user store, perfect for development and testing:</p>
<pre><code class="language-rust">use actix_security::http::security::{
    AuthenticationManager, Argon2PasswordEncoder, PasswordEncoder, User
};

let encoder = Argon2PasswordEncoder::new();

let authenticator = AuthenticationManager::in_memory_authentication()
    .password_encoder(encoder.clone())
    .with_user(
        User::with_encoded_password("admin", encoder.encode("secret"))
            .roles(&amp;["ADMIN".into()])
    )
    .with_user(
        User::with_encoded_password("user", encoder.encode("password"))
            .roles(&amp;["USER".into()])
    );</code></pre>
<h3 id="jwtauthenticator"><a class="header" href="#jwtauthenticator">JwtAuthenticator</a></h3>
<p>Stateless JWT-based authentication for REST APIs (requires <code>jwt</code> feature):</p>
<pre><code class="language-rust">use actix_security::http::security::jwt::{JwtAuthenticator, JwtConfig};

let config = JwtConfig::new("your-256-bit-secret-key-minimum!")
    .issuer("my-app")
    .audience("my-api")
    .expiration_hours(24);

let authenticator = JwtAuthenticator::new(config);</code></pre>
<h3 id="sessionauthenticator"><a class="header" href="#sessionauthenticator">SessionAuthenticator</a></h3>
<p>Server-side session-based authentication (requires <code>session</code> feature):</p>
<pre><code class="language-rust">use actix_security::http::security::session::{SessionAuthenticator, SessionConfig};

let config = SessionConfig::new()
    .user_key("authenticated_user")
    .authenticated_key("is_authenticated");

let authenticator = SessionAuthenticator::new(config);</code></pre>
<h3 id="oauth2client"><a class="header" href="#oauth2client">OAuth2Client</a></h3>
<p>OAuth2/OIDC authentication for social login (requires <code>oauth2</code> feature):</p>
<pre><code class="language-rust">use actix_security::http::security::oauth2::{OAuth2Config, OAuth2Provider, OAuth2Client};

let config = OAuth2Config::new("client-id", "client-secret", "redirect-uri")
    .provider(OAuth2Provider::Google);

let client = OAuth2Client::new(config).await?;

// Generate authorization URL
let (auth_url, state, pkce_verifier, nonce) = client.authorization_url();</code></pre>
<h2 id="authentication-flow"><a class="header" href="#authentication-flow">Authentication Flow</a></h2>
<pre><code>Request ‚Üí SecurityTransform ‚Üí Authenticator.authenticate()
                                    ‚Üì
                            ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
                            ‚îÇ User found?   ‚îÇ
                            ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                                    ‚îÇ
                    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
                    ‚Üì                               ‚Üì
              [Yes: User]                    [No: None]
                    ‚Üì                               ‚Üì
           Continue to Authorizer           401 Unauthorized
                                          or redirect to login
</code></pre>
<h2 id="spring-security-comparison"><a class="header" href="#spring-security-comparison">Spring Security Comparison</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Spring Security</th><th>Actix Security</th></tr></thead><tbody>
<tr><td><code>AuthenticationManager</code></td><td><code>Authenticator</code> trait</td></tr>
<tr><td><code>UserDetailsService</code></td><td><code>Authenticator::get_user()</code></td></tr>
<tr><td><code>UserDetails</code></td><td><code>User</code></td></tr>
<tr><td><code>Authentication</code></td><td><code>AuthenticatedUser</code></td></tr>
<tr><td><code>InMemoryUserDetailsManager</code></td><td><code>MemoryAuthenticator</code></td></tr>
<tr><td><code>JwtDecoder</code></td><td><code>JwtAuthenticator</code></td></tr>
<tr><td><code>SessionRegistry</code></td><td><code>SessionAuthenticator</code></td></tr>
<tr><td><code>ClientRegistrationRepository</code></td><td><code>OAuth2ClientRepository</code></td></tr>
<tr><td><code>OAuth2User</code></td><td><code>OAuth2User</code></td></tr>
<tr><td><code>PasswordEncoder</code></td><td><code>PasswordEncoder</code> trait</td></tr>
</tbody></table>
</div>
<h2 id="sections"><a class="header" href="#sections">Sections</a></h2>
<ul>
<li><a href="authentication/./memory.html">In-Memory Authentication</a> - Quick setup with <code>MemoryAuthenticator</code></li>
<li><a href="authentication/./password-encoding.html">Password Encoding</a> - Secure password storage</li>
<li><a href="authentication/./http-basic.html">HTTP Basic</a> - HTTP Basic authentication</li>
<li><a href="authentication/./jwt.html">JWT Authentication</a> - Stateless token-based authentication for APIs</li>
<li><a href="authentication/./session-auth.html">Session Authentication</a> - Server-side session management</li>
<li><a href="authentication/./oauth2.html">OAuth2 / OIDC</a> - Social login and enterprise SSO</li>
<li><a href="authentication/./custom.html">Custom Authenticators</a> - Build your own</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="in-memory-authentication"><a class="header" href="#in-memory-authentication">In-Memory Authentication</a></h1>
<p>The <code>MemoryAuthenticator</code> stores users in memory. It's ideal for:</p>
<ul>
<li>Development and testing</li>
<li>Small applications with static user lists</li>
<li>Prototyping</li>
</ul>
<blockquote>
<p><strong>Note</strong>: For production applications with many users, implement a custom authenticator backed by a database.</p>
</blockquote>
<h2 id="basic-usage"><a class="header" href="#basic-usage">Basic Usage</a></h2>
<pre><code class="language-rust">use actix_security::http::security::{
    AuthenticationManager, Argon2PasswordEncoder, PasswordEncoder, User
};

let encoder = Argon2PasswordEncoder::new();

let authenticator = AuthenticationManager::in_memory_authentication()
    .password_encoder(encoder.clone())
    .with_user(
        User::with_encoded_password("admin", encoder.encode("admin"))
            .roles(&amp;["ADMIN".into(), "USER".into()])
    )
    .with_user(
        User::with_encoded_password("user", encoder.encode("password"))
            .roles(&amp;["USER".into()])
    );</code></pre>
<h2 id="creating-users"><a class="header" href="#creating-users">Creating Users</a></h2>
<h3 id="with-roles-only"><a class="header" href="#with-roles-only">With Roles Only</a></h3>
<pre><code class="language-rust">User::with_encoded_password("username", encoder.encode("password"))
    .roles(&amp;["ROLE1".into(), "ROLE2".into()])</code></pre>
<h3 id="with-authorities-only"><a class="header" href="#with-authorities-only">With Authorities Only</a></h3>
<pre><code class="language-rust">User::with_encoded_password("username", encoder.encode("password"))
    .authorities(&amp;["read".into(), "write".into()])</code></pre>
<h3 id="with-both-roles-and-authorities"><a class="header" href="#with-both-roles-and-authorities">With Both Roles and Authorities</a></h3>
<pre><code class="language-rust">User::with_encoded_password("admin", encoder.encode("admin"))
    .roles(&amp;["ADMIN".into()])
    .authorities(&amp;[
        "users:read".into(),
        "users:write".into(),
        "posts:read".into(),
        "posts:write".into(),
    ])</code></pre>
<h2 id="integration-with-securitytransform"><a class="header" href="#integration-with-securitytransform">Integration with SecurityTransform</a></h2>
<pre><code class="language-rust">use actix_security::http::security::middleware::SecurityTransform;

let encoder = Argon2PasswordEncoder::new();

App::new()
    .wrap(
        SecurityTransform::new()
            .config_authenticator(move || {
                let enc = encoder.clone();
                AuthenticationManager::in_memory_authentication()
                    .password_encoder(enc.clone())
                    .with_user(
                        User::with_encoded_password("admin", enc.encode("admin"))
                            .roles(&amp;["ADMIN".into()])
                    )
            })
            .config_authorizer(|| {
                AuthorizationManager::request_matcher()
                    .http_basic()
            })
    )</code></pre>
<h2 id="spring-security-comparison-1"><a class="header" href="#spring-security-comparison-1">Spring Security Comparison</a></h2>
<p><strong>Spring Security:</strong></p>
<pre><code class="language-java">@Bean
public InMemoryUserDetailsManager userDetailsService() {
    UserDetails admin = User.withDefaultPasswordEncoder()
        .username("admin")
        .password("admin")
        .roles("ADMIN", "USER")
        .build();

    UserDetails user = User.withDefaultPasswordEncoder()
        .username("user")
        .password("password")
        .roles("USER")
        .build();

    return new InMemoryUserDetailsManager(admin, user);
}
</code></pre>
<p><strong>Actix Security:</strong></p>
<pre><code class="language-rust">let encoder = Argon2PasswordEncoder::new();

AuthenticationManager::in_memory_authentication()
    .password_encoder(encoder.clone())
    .with_user(
        User::with_encoded_password("admin", encoder.encode("admin"))
            .roles(&amp;["ADMIN".into(), "USER".into()])
    )
    .with_user(
        User::with_encoded_password("user", encoder.encode("password"))
            .roles(&amp;["USER".into()])
    )</code></pre>
<h2 id="thread-safety"><a class="header" href="#thread-safety">Thread Safety</a></h2>
<p><code>MemoryAuthenticator</code> is thread-safe and can be shared across multiple worker threads. It implements <code>Clone + Send + Sync</code>.</p>
<h2 id="limitations"><a class="header" href="#limitations">Limitations</a></h2>
<ul>
<li>Users are stored in memory (lost on restart)</li>
<li>Not suitable for large user bases</li>
<li>No dynamic user management at runtime</li>
</ul>
<p>For production use cases, consider implementing a <a href="authentication/./custom.html">Custom Authenticator</a> backed by a database.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="password-encoding"><a class="header" href="#password-encoding">Password Encoding</a></h1>
<p>Never store passwords in plain text. Actix Security provides secure password encoding out of the box.</p>
<h2 id="the-passwordencoder-trait"><a class="header" href="#the-passwordencoder-trait">The PasswordEncoder Trait</a></h2>
<pre><code class="language-rust">pub trait PasswordEncoder: Clone + Send + Sync + 'static {
    /// Encode a raw password.
    fn encode(&amp;self, raw_password: &amp;str) -&gt; String;

    /// Check if a raw password matches an encoded password.
    fn matches(&amp;self, raw_password: &amp;str, encoded_password: &amp;str) -&gt; bool;
}</code></pre>
<h2 id="available-encoders"><a class="header" href="#available-encoders">Available Encoders</a></h2>
<h3 id="argon2passwordencoder-recommended"><a class="header" href="#argon2passwordencoder-recommended">Argon2PasswordEncoder (Recommended)</a></h3>
<p>Uses the Argon2id algorithm, winner of the Password Hashing Competition.</p>
<pre><code class="language-rust">use actix_security::http::security::{Argon2PasswordEncoder, PasswordEncoder};

let encoder = Argon2PasswordEncoder::new();

// Encode a password
let encoded = encoder.encode("my_secure_password");
// Output: $argon2id$v=19$m=19456,t=2,p=1$...

// Verify a password
assert!(encoder.matches("my_secure_password", &amp;encoded));
assert!(!encoder.matches("wrong_password", &amp;encoded));</code></pre>
<p><strong>Features:</strong></p>
<ul>
<li>Memory-hard (resistant to GPU attacks)</li>
<li>Configurable parameters</li>
<li>Recommended by OWASP</li>
</ul>
<blockquote>
<p>Requires the <code>argon2</code> feature flag (enabled by default).</p>
</blockquote>
<h3 id="nooppasswordencoder"><a class="header" href="#nooppasswordencoder">NoOpPasswordEncoder</a></h3>
<p>Stores passwords in plain text. <strong>Only use for testing!</strong></p>
<pre><code class="language-rust">use actix_security::http::security::{NoOpPasswordEncoder, PasswordEncoder};

let encoder = NoOpPasswordEncoder::new();

let encoded = encoder.encode("password");
assert_eq!(encoded, "password"); // No encoding!

assert!(encoder.matches("password", "password"));</code></pre>
<blockquote>
<p>‚ö†Ô∏è <strong>Warning</strong>: Never use <code>NoOpPasswordEncoder</code> in production!</p>
</blockquote>
<h3 id="delegatingpasswordencoder"><a class="header" href="#delegatingpasswordencoder">DelegatingPasswordEncoder</a></h3>
<p>Supports multiple encoding formats, useful for password migration.</p>
<pre><code class="language-rust">use actix_security::http::security::{
    DelegatingPasswordEncoder, Argon2PasswordEncoder, NoOpPasswordEncoder, PasswordEncoder
};

let encoder = DelegatingPasswordEncoder::new()
    .with_encoder("argon2", Box::new(Argon2PasswordEncoder::new()))
    .with_encoder("noop", Box::new(NoOpPasswordEncoder::new()))
    .default_encoder("argon2");

// New passwords use argon2
let encoded = encoder.encode("password");
// Output: {argon2}$argon2id$v=19$...

// Can still verify old noop passwords
assert!(encoder.matches("old_password", "{noop}old_password"));

// Can verify new argon2 passwords
assert!(encoder.matches("password", &amp;encoded));</code></pre>
<h2 id="best-practices"><a class="header" href="#best-practices">Best Practices</a></h2>
<h3 id="1-use-argon2-for-new-applications"><a class="header" href="#1-use-argon2-for-new-applications">1. Use Argon2 for New Applications</a></h3>
<pre><code class="language-rust">let encoder = Argon2PasswordEncoder::new();</code></pre>
<h3 id="2-migrate-existing-passwords"><a class="header" href="#2-migrate-existing-passwords">2. Migrate Existing Passwords</a></h3>
<p>Use <code>DelegatingPasswordEncoder</code> to gradually migrate:</p>
<pre><code class="language-rust">let encoder = DelegatingPasswordEncoder::new()
    .with_encoder("argon2", Box::new(Argon2PasswordEncoder::new()))
    .with_encoder("bcrypt", Box::new(BcryptEncoder::new())) // Your old encoder
    .default_encoder("argon2"); // New passwords use argon2</code></pre>
<h3 id="3-never-log-or-display-passwords"><a class="header" href="#3-never-log-or-display-passwords">3. Never Log or Display Passwords</a></h3>
<pre><code class="language-rust">// Bad - logs the password
log::info!("User {} with password {}", username, password);

// Good - only log non-sensitive data
log::info!("User {} logged in", username);</code></pre>
<h2 id="spring-security-comparison-2"><a class="header" href="#spring-security-comparison-2">Spring Security Comparison</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Spring Security</th><th>Actix Security</th></tr></thead><tbody>
<tr><td><code>PasswordEncoder</code></td><td><code>PasswordEncoder</code> trait</td></tr>
<tr><td><code>BCryptPasswordEncoder</code></td><td><code>Argon2PasswordEncoder</code></td></tr>
<tr><td><code>NoOpPasswordEncoder</code></td><td><code>NoOpPasswordEncoder</code></td></tr>
<tr><td><code>DelegatingPasswordEncoder</code></td><td><code>DelegatingPasswordEncoder</code></td></tr>
</tbody></table>
</div>
<p><strong>Spring Security:</strong></p>
<pre><code class="language-java">@Bean
public PasswordEncoder passwordEncoder() {
    return new BCryptPasswordEncoder();
}
</code></pre>
<p><strong>Actix Security:</strong></p>
<pre><code class="language-rust">let encoder = Argon2PasswordEncoder::new();</code></pre>
<h2 id="implementing-custom-encoders"><a class="header" href="#implementing-custom-encoders">Implementing Custom Encoders</a></h2>
<pre><code class="language-rust">use actix_security::http::security::PasswordEncoder;

#[derive(Clone)]
pub struct MyCustomEncoder;

impl PasswordEncoder for MyCustomEncoder {
    fn encode(&amp;self, raw_password: &amp;str) -&gt; String {
        // Your encoding logic
        format!("{{custom}}{}", some_hash_function(raw_password))
    }

    fn matches(&amp;self, raw_password: &amp;str, encoded_password: &amp;str) -&gt; bool {
        // Your verification logic
        let expected = self.encode(raw_password);
        constant_time_eq(expected.as_bytes(), encoded_password.as_bytes())
    }
}</code></pre>
<h2 id="security-considerations"><a class="header" href="#security-considerations">Security Considerations</a></h2>
<ol>
<li><strong>Use strong algorithms</strong> - Argon2id is currently recommended</li>
<li><strong>Use constant-time comparison</strong> - Prevents timing attacks</li>
<li><strong>Salt passwords</strong> - Argon2 does this automatically</li>
<li><strong>Tune parameters</strong> - Adjust memory/time cost based on your hardware</li>
<li><strong>Re-hash on login</strong> - Upgrade old hashes when users log in</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="http-basic-authentication"><a class="header" href="#http-basic-authentication">HTTP Basic Authentication</a></h1>
<p>HTTP Basic Authentication sends credentials in the <code>Authorization</code> header.</p>
<h2 id="how-it-works"><a class="header" href="#how-it-works">How It Works</a></h2>
<pre><code>Authorization: Basic base64(username:password)
</code></pre>
<p>Example:</p>
<pre><code>Authorization: Basic YWRtaW46YWRtaW4=  // admin:admin
</code></pre>
<h2 id="enabling-http-basic"><a class="header" href="#enabling-http-basic">Enabling HTTP Basic</a></h2>
<p>Configure your authorizer to use HTTP Basic:</p>
<pre><code class="language-rust">use actix_security::http::security::AuthorizationManager;

let authorizer = AuthorizationManager::request_matcher()
    .http_basic()  // Enable HTTP Basic
    .login_url("/login");</code></pre>
<h2 id="full-example"><a class="header" href="#full-example">Full Example</a></h2>
<pre><code class="language-rust">use actix_web::{get, App, HttpServer, HttpResponse, Responder};
use actix_security::secured;
use actix_security::http::security::{
    AuthenticatedUser, AuthenticationManager, AuthorizationManager,
    Argon2PasswordEncoder, PasswordEncoder, User,
};
use actix_security::http::security::middleware::SecurityTransform;

#[secured("USER")]
#[get("/api/data")]
async fn get_data(user: AuthenticatedUser) -&gt; impl Responder {
    HttpResponse::Ok().body(format!("Data for {}", user.get_username()))
}

#[actix_web::main]
async fn main() -&gt; std::io::Result&lt;()&gt; {
    let encoder = Argon2PasswordEncoder::new();

    HttpServer::new(move || {
        let enc = encoder.clone();
        App::new()
            .wrap(
                SecurityTransform::new()
                    .config_authenticator(move || {
                        AuthenticationManager::in_memory_authentication()
                            .password_encoder(enc.clone())
                            .with_user(
                                User::with_encoded_password("api_user", enc.encode("api_secret"))
                                    .roles(&amp;["USER".into()])
                            )
                    })
                    .config_authorizer(|| {
                        AuthorizationManager::request_matcher()
                            .http_basic()  // Enable HTTP Basic
                    })
            )
            .service(get_data)
    })
    .bind("127.0.0.1:8080")?
    .run()
    .await
}</code></pre>
<h2 id="testing-with-curl"><a class="header" href="#testing-with-curl">Testing with cURL</a></h2>
<pre><code class="language-bash"># Using -u flag (automatic base64 encoding)
curl -u api_user:api_secret http://127.0.0.1:8080/api/data

# Manual header
curl -H "Authorization: Basic YXBpX3VzZXI6YXBpX3NlY3JldA==" http://127.0.0.1:8080/api/data
</code></pre>
<h2 id="testing-in-rust"><a class="header" href="#testing-in-rust">Testing in Rust</a></h2>
<pre><code class="language-rust">use actix_web::test;
use base64::prelude::*;

fn basic_auth(username: &amp;str, password: &amp;str) -&gt; String {
    let credentials = format!("{}:{}", username, password);
    format!("Basic {}", BASE64_STANDARD.encode(credentials))
}

#[actix_web::test]
async fn test_http_basic() {
    let app = create_test_app().await;

    let req = test::TestRequest::get()
        .uri("/api/data")
        .insert_header(("Authorization", basic_auth("api_user", "api_secret")))
        .to_request();

    let resp = test::call_service(&amp;app, req).await;
    assert_eq!(resp.status(), StatusCode::OK);
}</code></pre>
<h2 id="401-response"><a class="header" href="#401-response">401 Response</a></h2>
<p>When authentication fails, the server returns:</p>
<pre><code>HTTP/1.1 401 Unauthorized
WWW-Authenticate: Basic realm="Restricted"
</code></pre>
<h2 id="security-considerations-1"><a class="header" href="#security-considerations-1">Security Considerations</a></h2>
<h3 id="use-https"><a class="header" href="#use-https">Use HTTPS</a></h3>
<p>HTTP Basic sends credentials in <strong>base64 encoding</strong> (not encryption). Always use HTTPS in production.</p>
<pre><code class="language-rust">// In production, bind to HTTPS
HttpServer::new(|| App::new())
    .bind_openssl("0.0.0.0:443", ssl_builder)?
    .run()
    .await</code></pre>
<h3 id="consider-token-based-auth"><a class="header" href="#consider-token-based-auth">Consider Token-Based Auth</a></h3>
<p>For APIs, consider using:</p>
<ul>
<li>JWT tokens</li>
<li>API keys</li>
<li>OAuth2</li>
</ul>
<p>HTTP Basic is simple but has limitations:</p>
<ul>
<li>Credentials sent with every request</li>
<li>No built-in expiration</li>
<li>Harder to revoke access</li>
</ul>
<h2 id="spring-security-comparison-3"><a class="header" href="#spring-security-comparison-3">Spring Security Comparison</a></h2>
<p><strong>Spring Security:</strong></p>
<pre><code class="language-java">@Configuration
public class SecurityConfig {
    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http
            .httpBasic(Customizer.withDefaults())
            .authorizeHttpRequests(auth -&gt; auth
                .anyRequest().authenticated()
            );
        return http.build();
    }
}
</code></pre>
<p><strong>Actix Security:</strong></p>
<pre><code class="language-rust">SecurityTransform::new()
    .config_authenticator(|| /* ... */)
    .config_authorizer(|| {
        AuthorizationManager::request_matcher()
            .http_basic()
    })</code></pre>
<h2 id="feature-flag"><a class="header" href="#feature-flag">Feature Flag</a></h2>
<p>HTTP Basic authentication requires the <code>http-basic</code> feature flag:</p>
<pre><code class="language-toml">[dependencies]
actix-security = { version = "0.2", features = ["http-basic"] }
</code></pre>
<p>This feature is enabled by default.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="jwt-authentication"><a class="header" href="#jwt-authentication">JWT Authentication</a></h1>
<p>JSON Web Token (JWT) authentication for stateless API security.</p>
<h2 id="overview"><a class="header" href="#overview">Overview</a></h2>
<p>JWT authentication is ideal for:</p>
<ul>
<li>REST APIs</li>
<li>Microservices</li>
<li>Single Page Applications (SPAs)</li>
<li>Mobile applications</li>
</ul>
<h2 id="feature-flag-1"><a class="header" href="#feature-flag-1">Feature Flag</a></h2>
<p>Enable JWT support in your <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[dependencies]
actix-security = { version = "0.2", features = ["jwt"] }
</code></pre>
<h2 id="quick-start-1"><a class="header" href="#quick-start-1">Quick Start</a></h2>
<pre><code class="language-rust">use actix_security::http::security::jwt::{JwtAuthenticator, JwtConfig};
use actix_security::http::security::middleware::SecurityTransform;

// Configure JWT
let config = JwtConfig::new("your-256-bit-secret-key-minimum!")
    .issuer("my-app")
    .audience("my-api")
    .expiration_hours(24);

let authenticator = JwtAuthenticator::new(config);

// Use with SecurityTransform
App::new()
    .wrap(
        SecurityTransform::new()
            .config_authenticator(move || authenticator.clone())
            .config_authorizer(|| AuthorizationManager::request_matcher())
    )</code></pre>
<h2 id="configuration-options"><a class="header" href="#configuration-options">Configuration Options</a></h2>
<pre><code class="language-rust">let config = JwtConfig::new("your-secret-key")
    // Algorithm (default: HS256)
    .algorithm(Algorithm::HS512)

    // Issuer claim validation
    .issuer("my-app")

    // Audience claim validation
    .audience("my-api")

    // Token expiration
    .expiration_secs(3600)      // or
    .expiration_hours(1)        // or
    .expiration_days(7)

    // Validation leeway (for clock skew)
    .leeway_secs(60)

    // Custom header (default: "Authorization")
    .header_name("X-Auth-Token")

    // Custom prefix (default: "Bearer ")
    .header_prefix("Token ");</code></pre>
<h2 id="token-generation"><a class="header" href="#token-generation">Token Generation</a></h2>
<h3 id="generate-token-for-user"><a class="header" href="#generate-token-for-user">Generate Token for User</a></h3>
<pre><code class="language-rust">use actix_security::http::security::jwt::{JwtAuthenticator, JwtConfig};
use actix_security::http::security::User;

let config = JwtConfig::new("secret").expiration_hours(24);
let authenticator = JwtAuthenticator::new(config);

// Create user
let user = User::new("john".to_string(), "".to_string())
    .roles(&amp;["USER".into()])
    .authorities(&amp;["posts:read".into()]);

// Generate token
let token = authenticator.generate_token(&amp;user)?;
// Returns: "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."</code></pre>
<h3 id="generate-token-with-custom-claims"><a class="header" href="#generate-token-with-custom-claims">Generate Token with Custom Claims</a></h3>
<pre><code class="language-rust">use actix_security::http::security::jwt::Claims;

let claims = Claims::new("john", 3600)
    .issuer("my-app")
    .audience("my-api")
    .roles(vec!["USER".to_string()])
    .authorities(vec!["posts:read".to_string()])
    .custom(serde_json::json!({
        "tenant_id": "acme",
        "department": "engineering"
    }));

let token = authenticator.generate_token_with_claims(&amp;claims)?;</code></pre>
<h2 id="token-validation"><a class="header" href="#token-validation">Token Validation</a></h2>
<pre><code class="language-rust">// Validate and get claims
let token_data = authenticator.validate_token(&amp;token)?;
let claims = token_data.claims;

println!("Username: {}", claims.sub);
println!("Roles: {:?}", claims.roles);
println!("Expires: {}", claims.exp);</code></pre>
<h2 id="token-service-access--refresh-tokens"><a class="header" href="#token-service-access--refresh-tokens">Token Service (Access + Refresh Tokens)</a></h2>
<pre><code class="language-rust">use actix_security::http::security::jwt::JwtTokenService;

let service = JwtTokenService::new(config)
    .refresh_expiration_days(7);

// Generate access token (short-lived, includes roles)
let access_token = service.generate_token(&amp;user)?;

// Generate refresh token (long-lived, minimal claims)
let refresh_token = service.generate_refresh_token(&amp;user)?;</code></pre>
<h2 id="complete-example"><a class="header" href="#complete-example">Complete Example</a></h2>
<h3 id="login-endpoint"><a class="header" href="#login-endpoint">Login Endpoint</a></h3>
<pre><code class="language-rust">use actix_web::{post, web, HttpResponse, Responder};
use actix_security::http::security::jwt::{JwtAuthenticator, JwtConfig};
use actix_security::http::security::{
    AuthenticationManager, Argon2PasswordEncoder, PasswordEncoder, User
};

#[derive(Deserialize)]
struct LoginRequest {
    username: String,
    password: String,
}

#[derive(Serialize)]
struct LoginResponse {
    access_token: String,
    token_type: String,
    expires_in: u64,
}

#[post("/auth/login")]
async fn login(
    form: web::Json&lt;LoginRequest&gt;,
    authenticator: web::Data&lt;JwtAuthenticator&gt;,
    users: web::Data&lt;MemoryAuthenticator&gt;,
) -&gt; impl Responder {
    // Validate credentials
    let user = match users.find_user(&amp;form.username) {
        Some(u) if encoder.matches(&amp;form.password, u.get_password()) =&gt; u,
        _ =&gt; return HttpResponse::Unauthorized().body("Invalid credentials"),
    };

    // Generate token
    match authenticator.generate_token(&amp;user) {
        Ok(token) =&gt; HttpResponse::Ok().json(LoginResponse {
            access_token: token,
            token_type: "Bearer".to_string(),
            expires_in: 3600,
        }),
        Err(_) =&gt; HttpResponse::InternalServerError().body("Token generation failed"),
    }
}</code></pre>
<h3 id="protected-endpoint"><a class="header" href="#protected-endpoint">Protected Endpoint</a></h3>
<pre><code class="language-rust">use actix_security::secured;
use actix_security::http::security::AuthenticatedUser;

#[secured("USER")]
#[get("/api/profile")]
async fn profile(user: AuthenticatedUser) -&gt; impl Responder {
    HttpResponse::Ok().json(serde_json::json!({
        "username": user.get_username(),
        "roles": user.get_roles(),
    }))
}</code></pre>
<h3 id="client-usage"><a class="header" href="#client-usage">Client Usage</a></h3>
<pre><code class="language-bash"># Login
curl -X POST http://localhost:8080/auth/login \
  -H "Content-Type: application/json" \
  -d '{"username": "john", "password": "secret"}'

# Response: {"access_token": "eyJ...", "token_type": "Bearer", "expires_in": 3600}

# Access protected resource
curl http://localhost:8080/api/profile \
  -H "Authorization: Bearer eyJ..."
</code></pre>
<h2 id="jwt-claims-structure"><a class="header" href="#jwt-claims-structure">JWT Claims Structure</a></h2>
<pre><code class="language-json">{
  "sub": "username",
  "iss": "my-app",
  "aud": "my-api",
  "exp": 1735689600,
  "iat": 1735686000,
  "roles": ["USER", "ADMIN"],
  "authorities": ["posts:read", "posts:write"]
}
</code></pre>
<h2 id="algorithms"><a class="header" href="#algorithms">Algorithms</a></h2>
<p>Supported algorithms:</p>
<div class="table-wrapper"><table><thead><tr><th>Algorithm</th><th>Description</th></tr></thead><tbody>
<tr><td><code>HS256</code></td><td>HMAC-SHA256 (default)</td></tr>
<tr><td><code>HS384</code></td><td>HMAC-SHA384</td></tr>
<tr><td><code>HS512</code></td><td>HMAC-SHA512</td></tr>
<tr><td><code>RS256</code></td><td>RSA-SHA256</td></tr>
<tr><td><code>RS384</code></td><td>RSA-SHA384</td></tr>
<tr><td><code>RS512</code></td><td>RSA-SHA512</td></tr>
<tr><td><code>ES256</code></td><td>ECDSA-SHA256</td></tr>
<tr><td><code>ES384</code></td><td>ECDSA-SHA384</td></tr>
</tbody></table>
</div>
<h2 id="security-best-practices"><a class="header" href="#security-best-practices">Security Best Practices</a></h2>
<ol>
<li><strong>Use strong secrets</strong> - At least 256 bits (32 characters) for HMAC</li>
<li><strong>Set appropriate expiration</strong> - Short-lived tokens (15 min - 1 hour)</li>
<li><strong>Use HTTPS</strong> - Always transmit tokens over HTTPS</li>
<li><strong>Validate claims</strong> - Always validate issuer and audience</li>
<li><strong>Store tokens securely</strong> - Never store in localStorage for web apps</li>
<li><strong>Implement token refresh</strong> - Use refresh tokens for long sessions</li>
</ol>
<h2 id="spring-security-comparison-4"><a class="header" href="#spring-security-comparison-4">Spring Security Comparison</a></h2>
<p><strong>Spring Security:</strong></p>
<pre><code class="language-java">@Bean
public JwtDecoder jwtDecoder() {
    return NimbusJwtDecoder.withSecretKey(secretKey).build();
}

@Bean
public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
    http.oauth2ResourceServer(oauth2 -&gt; oauth2.jwt(Customizer.withDefaults()));
    return http.build();
}
</code></pre>
<p><strong>Actix Security:</strong></p>
<pre><code class="language-rust">let config = JwtConfig::new("secret-key")
    .issuer("my-app")
    .expiration_hours(1);

let authenticator = JwtAuthenticator::new(config);

SecurityTransform::new()
    .config_authenticator(move || authenticator.clone())</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="session-authentication"><a class="header" href="#session-authentication">Session Authentication</a></h1>
<p>Traditional session-based authentication using cookies.</p>
<h2 id="overview-1"><a class="header" href="#overview-1">Overview</a></h2>
<p>Session authentication is ideal for:</p>
<ul>
<li>Traditional web applications</li>
<li>Server-rendered pages</li>
<li>Applications requiring logout/session invalidation</li>
</ul>
<h2 id="feature-flag-2"><a class="header" href="#feature-flag-2">Feature Flag</a></h2>
<p>Enable session support in your <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[dependencies]
actix-security = { version = "0.2", features = ["session"] }
actix-session = { version = "0.10", features = ["cookie-session"] }
</code></pre>
<h2 id="quick-start-2"><a class="header" href="#quick-start-2">Quick Start</a></h2>
<pre><code class="language-rust">use actix_session::{SessionMiddleware, storage::CookieSessionStore};
use actix_session::config::CookieContentSecurity;
use actix_web::cookie::Key;
use actix_security::http::security::session::{SessionAuthenticator, SessionConfig};
use actix_security::http::security::middleware::SecurityTransform;

// Generate a secure key (in production, load from environment)
let secret_key = Key::generate();

// Session middleware
let session_middleware = SessionMiddleware::builder(
    CookieSessionStore::default(),
    secret_key.clone()
)
.cookie_secure(true)  // HTTPS only in production
.cookie_content_security(CookieContentSecurity::Private)
.build();

// Session authenticator
let session_config = SessionConfig::new();
let authenticator = SessionAuthenticator::new(session_config.clone());

App::new()
    .wrap(session_middleware)
    .wrap(
        SecurityTransform::new()
            .config_authenticator(move || authenticator.clone())
            .config_authorizer(|| AuthorizationManager::request_matcher())
    )
    .app_data(web::Data::new(session_config))</code></pre>
<h2 id="configuration"><a class="header" href="#configuration">Configuration</a></h2>
<pre><code class="language-rust">let config = SessionConfig::new()
    // Custom session key for user data (default: "security_user")
    .user_key("my_user")
    // Custom session key for auth flag (default: "security_authenticated")
    .authenticated_key("my_auth");</code></pre>
<h2 id="loginlogout"><a class="header" href="#loginlogout">Login/Logout</a></h2>
<h3 id="login-handler"><a class="header" href="#login-handler">Login Handler</a></h3>
<pre><code class="language-rust">use actix_session::Session;
use actix_security::http::security::session::{SessionAuthenticator, SessionConfig};
use actix_security::http::security::User;

#[derive(Deserialize)]
struct LoginForm {
    username: String,
    password: String,
}

#[post("/login")]
async fn login(
    session: Session,
    form: web::Form&lt;LoginForm&gt;,
    config: web::Data&lt;SessionConfig&gt;,
    users: web::Data&lt;MemoryAuthenticator&gt;,
    encoder: web::Data&lt;Argon2PasswordEncoder&gt;,
) -&gt; impl Responder {
    // Find user
    let user = match users.find_user(&amp;form.username) {
        Some(u) =&gt; u,
        None =&gt; return HttpResponse::Unauthorized().body("Invalid credentials"),
    };

    // Verify password
    if !encoder.matches(&amp;form.password, user.get_password()) {
        return HttpResponse::Unauthorized().body("Invalid credentials");
    }

    // Store user in session
    match SessionAuthenticator::login(&amp;session, &amp;user, &amp;config) {
        Ok(_) =&gt; HttpResponse::Ok().body(format!("Welcome, {}!", user.get_username())),
        Err(e) =&gt; HttpResponse::InternalServerError().body(format!("Login failed: {}", e)),
    }
}</code></pre>
<h3 id="logout-handler"><a class="header" href="#logout-handler">Logout Handler</a></h3>
<pre><code class="language-rust">#[post("/logout")]
async fn logout(session: Session, config: web::Data&lt;SessionConfig&gt;) -&gt; impl Responder {
    SessionAuthenticator::logout(&amp;session, &amp;config);
    HttpResponse::Ok().body("Logged out")
}

// Or clear entire session
#[post("/logout/all")]
async fn logout_all(session: Session) -&gt; impl Responder {
    SessionAuthenticator::clear_session(&amp;session);
    HttpResponse::Ok().body("Session cleared")
}</code></pre>
<h2 id="session-utilities"><a class="header" href="#session-utilities">Session Utilities</a></h2>
<h3 id="check-authentication"><a class="header" href="#check-authentication">Check Authentication</a></h3>
<pre><code class="language-rust">#[get("/status")]
async fn auth_status(session: Session, config: web::Data&lt;SessionConfig&gt;) -&gt; impl Responder {
    if SessionAuthenticator::is_authenticated(&amp;session, &amp;config) {
        let user = SessionAuthenticator::get_session_user(&amp;session, &amp;config);
        HttpResponse::Ok().json(serde_json::json!({
            "authenticated": true,
            "username": user.map(|u| u.get_username().to_string())
        }))
    } else {
        HttpResponse::Ok().json(serde_json::json!({
            "authenticated": false
        }))
    }
}</code></pre>
<h2 id="complete-example-1"><a class="header" href="#complete-example-1">Complete Example</a></h2>
<pre><code class="language-rust">use actix_web::{get, post, web, App, HttpResponse, HttpServer, Responder};
use actix_session::{Session, SessionMiddleware, storage::CookieSessionStore};
use actix_web::cookie::Key;
use actix_security::secured;
use actix_security::http::security::{
    AuthenticatedUser, AuthenticationManager, AuthorizationManager,
    Argon2PasswordEncoder, PasswordEncoder, User,
};
use actix_security::http::security::session::{SessionAuthenticator, SessionConfig};
use actix_security::http::security::middleware::SecurityTransform;

#[derive(Deserialize)]
struct LoginForm {
    username: String,
    password: String,
}

#[get("/")]
async fn index() -&gt; impl Responder {
    HttpResponse::Ok().body("Welcome! Please login at /login")
}

#[get("/login")]
async fn login_page() -&gt; impl Responder {
    HttpResponse::Ok()
        .content_type("text/html")
        .body(r#"
            &lt;form method="post" action="/login"&gt;
                &lt;input name="username" placeholder="Username"&gt;
                &lt;input name="password" type="password" placeholder="Password"&gt;
                &lt;button type="submit"&gt;Login&lt;/button&gt;
            &lt;/form&gt;
        "#)
}

#[post("/login")]
async fn do_login(
    session: Session,
    form: web::Form&lt;LoginForm&gt;,
    config: web::Data&lt;SessionConfig&gt;,
) -&gt; impl Responder {
    // In real app, validate against database
    if form.username == "admin" &amp;&amp; form.password == "admin" {
        let user = User::new("admin".to_string(), "".to_string())
            .roles(&amp;["ADMIN".into(), "USER".into()]);

        SessionAuthenticator::login(&amp;session, &amp;user, &amp;config).unwrap();
        HttpResponse::Found()
            .insert_header(("Location", "/dashboard"))
            .finish()
    } else {
        HttpResponse::Unauthorized().body("Invalid credentials")
    }
}

#[post("/logout")]
async fn logout(session: Session, config: web::Data&lt;SessionConfig&gt;) -&gt; impl Responder {
    SessionAuthenticator::logout(&amp;session, &amp;config);
    HttpResponse::Found()
        .insert_header(("Location", "/"))
        .finish()
}

#[secured("USER")]
#[get("/dashboard")]
async fn dashboard(user: AuthenticatedUser) -&gt; impl Responder {
    HttpResponse::Ok().body(format!("Welcome to dashboard, {}!", user.get_username()))
}

#[secured("ADMIN")]
#[get("/admin")]
async fn admin(user: AuthenticatedUser) -&gt; impl Responder {
    HttpResponse::Ok().body(format!("Admin panel for {}", user.get_username()))
}

#[actix_web::main]
async fn main() -&gt; std::io::Result&lt;()&gt; {
    let secret_key = Key::generate();
    let session_config = SessionConfig::new();

    HttpServer::new(move || {
        let config = session_config.clone();
        let authenticator = SessionAuthenticator::new(config.clone());

        App::new()
            .wrap(
                SessionMiddleware::builder(CookieSessionStore::default(), secret_key.clone())
                    .build()
            )
            .wrap(
                SecurityTransform::new()
                    .config_authenticator(move || authenticator.clone())
                    .config_authorizer(|| {
                        AuthorizationManager::request_matcher()
                            .login_url("/login")
                    })
            )
            .app_data(web::Data::new(config))
            .service(index)
            .service(login_page)
            .service(do_login)
            .service(logout)
            .service(dashboard)
            .service(admin)
    })
    .bind("127.0.0.1:8080")?
    .run()
    .await
}</code></pre>
<h2 id="session-storage-options"><a class="header" href="#session-storage-options">Session Storage Options</a></h2>
<h3 id="cookie-session-default"><a class="header" href="#cookie-session-default">Cookie Session (Default)</a></h3>
<pre><code class="language-rust">use actix_session::storage::CookieSessionStore;

SessionMiddleware::new(CookieSessionStore::default(), secret_key)</code></pre>
<h3 id="redis-session"><a class="header" href="#redis-session">Redis Session</a></h3>
<pre><code class="language-toml">[dependencies]
actix-session = { version = "0.10", features = ["redis-session"] }
</code></pre>
<pre><code class="language-rust">use actix_session::storage::RedisSessionStore;

let redis_store = RedisSessionStore::new("redis://127.0.0.1:6379").await?;
SessionMiddleware::new(redis_store, secret_key)</code></pre>
<h2 id="security-best-practices-1"><a class="header" href="#security-best-practices-1">Security Best Practices</a></h2>
<ol>
<li><strong>Use secure cookies</strong> - Set <code>cookie_secure(true)</code> in production</li>
<li><strong>Use HTTP-only cookies</strong> - Prevents JavaScript access</li>
<li><strong>Set appropriate expiration</strong> - Balance security and UX</li>
<li><strong>Regenerate session on login</strong> - Prevent session fixation</li>
<li><strong>Use HTTPS</strong> - Always use HTTPS in production</li>
<li><strong>Implement CSRF protection</strong> - For form submissions</li>
</ol>
<h2 id="spring-security-comparison-5"><a class="header" href="#spring-security-comparison-5">Spring Security Comparison</a></h2>
<p><strong>Spring Security:</strong></p>
<pre><code class="language-java">@Configuration
public class SecurityConfig {
    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http
            .formLogin(form -&gt; form
                .loginPage("/login")
                .defaultSuccessUrl("/dashboard"))
            .logout(logout -&gt; logout
                .logoutUrl("/logout")
                .logoutSuccessUrl("/"));
        return http.build();
    }
}
</code></pre>
<p><strong>Actix Security:</strong></p>
<pre><code class="language-rust">// Session middleware handles cookie management
SessionMiddleware::new(CookieSessionStore::default(), secret_key)

// Login/logout handled in handlers
SessionAuthenticator::login(&amp;session, &amp;user, &amp;config)?;
SessionAuthenticator::logout(&amp;session, &amp;config);</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="oauth2--openid-connect-authentication"><a class="header" href="#oauth2--openid-connect-authentication">OAuth2 / OpenID Connect Authentication</a></h1>
<p>OAuth2 and OpenID Connect (OIDC) authentication for social login and enterprise SSO.</p>
<h2 id="overview-2"><a class="header" href="#overview-2">Overview</a></h2>
<p>OAuth2/OIDC authentication is ideal for:</p>
<ul>
<li>Social login (Google, GitHub, Facebook, etc.)</li>
<li>Enterprise SSO (Okta, Auth0, Keycloak, Azure AD)</li>
<li>Single Sign-On across multiple applications</li>
<li>Delegated authentication</li>
</ul>
<h2 id="feature-flag-3"><a class="header" href="#feature-flag-3">Feature Flag</a></h2>
<p>Enable OAuth2 support in your <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[dependencies]
actix-security = { version = "0.2", features = ["oauth2"] }
</code></pre>
<h2 id="quick-start-3"><a class="header" href="#quick-start-3">Quick Start</a></h2>
<h3 id="google-oauth2"><a class="header" href="#google-oauth2">Google OAuth2</a></h3>
<pre><code class="language-rust">use actix_security::http::security::oauth2::{
    OAuth2Config, OAuth2Provider, OAuth2Client
};

// Configure Google OAuth2
let config = OAuth2Config::new(
    std::env::var("GOOGLE_CLIENT_ID").unwrap(),
    std::env::var("GOOGLE_CLIENT_SECRET").unwrap(),
    "http://localhost:8080/oauth2/callback/google"
)
.provider(OAuth2Provider::Google);

// Create client (async - performs OIDC discovery)
let client = OAuth2Client::new(config).await?;

// Generate authorization URL
let (auth_url, state, pkce_verifier, nonce) = client.authorization_url();

// Redirect user to auth_url...
// Store state, pkce_verifier, and nonce in session for callback verification</code></pre>
<h3 id="github-oauth2"><a class="header" href="#github-oauth2">GitHub OAuth2</a></h3>
<pre><code class="language-rust">let config = OAuth2Config::new(
    std::env::var("GITHUB_CLIENT_ID").unwrap(),
    std::env::var("GITHUB_CLIENT_SECRET").unwrap(),
    "http://localhost:8080/oauth2/callback/github"
)
.provider(OAuth2Provider::GitHub);

// GitHub doesn't support OIDC, so no discovery needed
let client = OAuth2Client::new_basic(config)?;</code></pre>
<h2 id="supported-providers"><a class="header" href="#supported-providers">Supported Providers</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Provider</th><th>OIDC Support</th><th>PKCE Support</th></tr></thead><tbody>
<tr><td>Google</td><td>Yes</td><td>Yes</td></tr>
<tr><td>GitHub</td><td>No</td><td>No</td></tr>
<tr><td>Microsoft</td><td>Yes</td><td>Yes</td></tr>
<tr><td>Facebook</td><td>No</td><td>No</td></tr>
<tr><td>Apple</td><td>Yes</td><td>Yes</td></tr>
<tr><td>Okta</td><td>Yes</td><td>Yes</td></tr>
<tr><td>Auth0</td><td>Yes</td><td>Yes</td></tr>
<tr><td>Keycloak</td><td>Yes</td><td>Yes</td></tr>
</tbody></table>
</div>
<h2 id="configuration-options-1"><a class="header" href="#configuration-options-1">Configuration Options</a></h2>
<pre><code class="language-rust">let config = OAuth2Config::new("client-id", "client-secret", "redirect-uri")
    // Use a pre-configured provider
    .provider(OAuth2Provider::Google)

    // Or configure custom endpoints
    .authorization_uri("https://auth.example.com/authorize")
    .token_uri("https://auth.example.com/token")
    .userinfo_uri("https://auth.example.com/userinfo")

    // OIDC issuer for auto-discovery
    .issuer_uri("https://auth.example.com")

    // Scopes
    .scopes(vec!["openid", "email", "profile"])
    .add_scope("custom_scope")

    // PKCE (enabled by default for supported providers)
    .use_pkce(true)

    // Username attribute extraction
    .username_attribute("email")  // Use email as username

    // Custom authorization parameters
    .authorization_param("prompt", "consent");</code></pre>
<h2 id="authorization-code-flow"><a class="header" href="#authorization-code-flow">Authorization Code Flow</a></h2>
<h3 id="step-1-generate-authorization-url"><a class="header" href="#step-1-generate-authorization-url">Step 1: Generate Authorization URL</a></h3>
<pre><code class="language-rust">use actix_web::{get, web, HttpResponse};
use actix_session::Session;

#[get("/oauth2/authorize/{provider}")]
async fn authorize(
    provider: web::Path&lt;String&gt;,
    session: Session,
    clients: web::Data&lt;OAuth2ClientRepository&gt;,
) -&gt; HttpResponse {
    let client = clients.get_client(&amp;provider).unwrap();

    // Generate authorization URL with PKCE and nonce
    let (auth_url, state, pkce_verifier, nonce) = client.authorization_url();

    // Store state in session for CSRF protection
    session.insert("oauth2_state", state.secret()).unwrap();

    // Store PKCE verifier for token exchange
    if let Some(verifier) = pkce_verifier {
        session.insert("oauth2_pkce", verifier.secret()).unwrap();
    }

    // Store nonce for OIDC token validation
    if let Some(n) = nonce {
        session.insert("oauth2_nonce", n.secret()).unwrap();
    }

    HttpResponse::Found()
        .append_header(("Location", auth_url.to_string()))
        .finish()
}</code></pre>
<h3 id="step-2-handle-callback"><a class="header" href="#step-2-handle-callback">Step 2: Handle Callback</a></h3>
<pre><code class="language-rust">use oauth2::{CsrfToken, PkceCodeVerifier};
use openidconnect::Nonce;

#[derive(Deserialize)]
struct CallbackQuery {
    code: String,
    state: String,
}

#[get("/oauth2/callback/{provider}")]
async fn callback(
    provider: web::Path&lt;String&gt;,
    query: web::Query&lt;CallbackQuery&gt;,
    session: Session,
    clients: web::Data&lt;OAuth2ClientRepository&gt;,
) -&gt; HttpResponse {
    let client = clients.get_client(&amp;provider).unwrap();

    // Verify state (CSRF protection)
    let stored_state: String = session.get("oauth2_state").unwrap().unwrap();
    if query.state != stored_state {
        return HttpResponse::BadRequest().body("Invalid state");
    }

    // Retrieve PKCE verifier
    let pkce_verifier = session
        .get::&lt;String&gt;("oauth2_pkce")
        .unwrap()
        .map(|s| PkceCodeVerifier::new(s));

    // Retrieve nonce for OIDC
    let nonce = session
        .get::&lt;String&gt;("oauth2_nonce")
        .unwrap()
        .map(|s| Nonce::new(s));

    // Exchange code for tokens
    let (oauth2_user, oidc_user) = client
        .exchange_code(&amp;query.code, pkce_verifier, nonce.as_ref())
        .await
        .map_err(|e| HttpResponse::InternalServerError().body(e.to_string()))?;

    // Convert to authenticated user
    let user = oauth2_user.to_user();

    // Store user in session
    session.insert("user", serde_json::to_string(&amp;oauth2_user).unwrap()).unwrap();

    HttpResponse::Found()
        .append_header(("Location", "/"))
        .finish()
}</code></pre>
<h2 id="oauth2user"><a class="header" href="#oauth2user">OAuth2User</a></h2>
<p>The <code>OAuth2User</code> contains information retrieved from the OAuth2 provider:</p>
<pre><code class="language-rust">pub struct OAuth2User {
    pub sub: String,              // Unique identifier
    pub name: Option&lt;String&gt;,
    pub email: Option&lt;String&gt;,
    pub email_verified: Option&lt;bool&gt;,
    pub picture: Option&lt;String&gt;,
    pub locale: Option&lt;String&gt;,
    pub attributes: HashMap&lt;String, Value&gt;,  // Provider-specific
    pub access_token: Option&lt;String&gt;,
    pub refresh_token: Option&lt;String&gt;,
    pub expires_at: Option&lt;i64&gt;,
    pub provider: String,
}

// Get username (prefers email, falls back to sub)
let username = oauth2_user.username();

// Convert to security User
let user = oauth2_user.to_user();
// User has role "USER" and authority "OAUTH2_USER_GOOGLE"</code></pre>
<h2 id="oidcuser"><a class="header" href="#oidcuser">OidcUser</a></h2>
<p>For OIDC providers, you also get ID token claims:</p>
<pre><code class="language-rust">pub struct OidcUser {
    pub oauth2_user: OAuth2User,
    pub id_token_claims: Option&lt;IdTokenClaims&gt;,
    pub id_token: Option&lt;String&gt;,  // Raw JWT
}

pub struct IdTokenClaims {
    pub iss: String,    // Issuer
    pub sub: String,    // Subject
    pub aud: Vec&lt;String&gt;,  // Audience
    pub exp: i64,       // Expiration
    pub iat: i64,       // Issued at
    pub auth_time: Option&lt;i64&gt;,
    pub nonce: Option&lt;String&gt;,
    pub at_hash: Option&lt;String&gt;,
}</code></pre>
<h2 id="multiple-providers"><a class="header" href="#multiple-providers">Multiple Providers</a></h2>
<p>Use <code>OAuth2ClientRepository</code> to manage multiple providers:</p>
<pre><code class="language-rust">use actix_security::http::security::oauth2::OAuth2ClientRepository;

// Build repository from configs
let configs = vec![
    OAuth2Config::new(google_id, google_secret, google_redirect)
        .provider(OAuth2Provider::Google),
    OAuth2Config::new(github_id, github_secret, github_redirect)
        .provider(OAuth2Provider::GitHub),
];

let repository = OAuth2ClientRepository::from_configs(configs).await?;

// Use in Actix Web
App::new()
    .app_data(web::Data::new(repository))
    .service(authorize)
    .service(callback)</code></pre>
<h2 id="custom-provider"><a class="header" href="#custom-provider">Custom Provider</a></h2>
<p>Configure a custom OAuth2/OIDC provider:</p>
<pre><code class="language-rust">let config = OAuth2Config::new("client-id", "secret", "redirect-uri")
    .registration_id("custom")
    .authorization_uri("https://custom.example.com/oauth/authorize")
    .token_uri("https://custom.example.com/oauth/token")
    .userinfo_uri("https://custom.example.com/oauth/userinfo")
    // For OIDC with discovery:
    .issuer_uri("https://custom.example.com")
    .scopes(vec!["openid", "email", "profile"]);</code></pre>
<h2 id="complete-example-2"><a class="header" href="#complete-example-2">Complete Example</a></h2>
<pre><code class="language-rust">use actix_web::{get, web, App, HttpServer, HttpResponse};
use actix_session::{Session, SessionMiddleware, storage::CookieSessionStore};
use actix_web::cookie::Key;
use actix_security::http::security::oauth2::{
    OAuth2Config, OAuth2Provider, OAuth2Client, OAuth2ClientRepository
};

#[actix_web::main]
async fn main() -&gt; std::io::Result&lt;()&gt; {
    // Configure OAuth2 providers
    let google_config = OAuth2Config::new(
        std::env::var("GOOGLE_CLIENT_ID").unwrap(),
        std::env::var("GOOGLE_CLIENT_SECRET").unwrap(),
        "http://localhost:8080/oauth2/callback/google"
    )
    .provider(OAuth2Provider::Google);

    let repository = OAuth2ClientRepository::from_configs(vec![google_config])
        .await
        .expect("Failed to create OAuth2 repository");

    let secret_key = Key::generate();

    HttpServer::new(move || {
        App::new()
            .wrap(SessionMiddleware::new(
                CookieSessionStore::default(),
                secret_key.clone()
            ))
            .app_data(web::Data::new(repository.clone()))
            .service(login_page)
            .service(authorize)
            .service(callback)
            .service(profile)
    })
    .bind("127.0.0.1:8080")?
    .run()
    .await
}

#[get("/login")]
async fn login_page() -&gt; HttpResponse {
    HttpResponse::Ok().body(r#"
        &lt;a href="/oauth2/authorize/google"&gt;Login with Google&lt;/a&gt;
    "#)
}

#[get("/profile")]
async fn profile(session: Session) -&gt; HttpResponse {
    if let Some(user_json) = session.get::&lt;String&gt;("user").unwrap() {
        HttpResponse::Ok().body(format!("Logged in as: {}", user_json))
    } else {
        HttpResponse::Found()
            .append_header(("Location", "/login"))
            .finish()
    }
}</code></pre>
<h2 id="security-best-practices-2"><a class="header" href="#security-best-practices-2">Security Best Practices</a></h2>
<ol>
<li><strong>Always validate state</strong> - Prevents CSRF attacks</li>
<li><strong>Use PKCE</strong> - Prevents authorization code interception</li>
<li><strong>Validate nonce for OIDC</strong> - Prevents replay attacks</li>
<li><strong>Use HTTPS</strong> - Always in production</li>
<li><strong>Validate redirect URIs</strong> - Prevent open redirects</li>
<li><strong>Store tokens securely</strong> - Use encrypted sessions</li>
<li><strong>Handle token expiration</strong> - Implement refresh token flow</li>
</ol>
<h2 id="spring-security-comparison-6"><a class="header" href="#spring-security-comparison-6">Spring Security Comparison</a></h2>
<p><strong>Spring Security:</strong></p>
<pre><code class="language-java">@Configuration
public class OAuth2Config {
    @Bean
    public ClientRegistrationRepository clientRegistrationRepository() {
        return new InMemoryClientRegistrationRepository(
            CommonOAuth2Provider.GOOGLE.getBuilder("google")
                .clientId("client-id")
                .clientSecret("client-secret")
                .build()
        );
    }
}
</code></pre>
<p><strong>Actix Security:</strong></p>
<pre><code class="language-rust">let config = OAuth2Config::new("client-id", "client-secret", "redirect-uri")
    .provider(OAuth2Provider::Google);

let repository = OAuth2ClientRepository::from_configs(vec![config]).await?;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="custom-authenticators"><a class="header" href="#custom-authenticators">Custom Authenticators</a></h1>
<p>Create custom authenticators for database-backed user stores, OAuth, JWT, and more.</p>
<h2 id="implementing-the-authenticator-trait"><a class="header" href="#implementing-the-authenticator-trait">Implementing the Authenticator Trait</a></h2>
<pre><code class="language-rust">use actix_security::http::security::config::Authenticator;
use actix_security::http::security::User;
use actix_web::dev::ServiceRequest;

#[derive(Clone)]
pub struct DatabaseAuthenticator {
    pool: sqlx::PgPool,  // Your database connection pool
}

impl Authenticator for DatabaseAuthenticator {
    fn authenticate(&amp;self, req: &amp;ServiceRequest) -&gt; Option&lt;User&gt; {
        // 1. Extract credentials from request
        let auth_header = req.headers().get("Authorization")?;
        let (username, password) = parse_basic_auth(auth_header)?;

        // 2. Look up user in database
        // Note: This is sync, consider using block_on or async authenticator
        let user_record = self.find_user(&amp;username)?;

        // 3. Verify password
        if !self.verify_password(&amp;password, &amp;user_record.password_hash) {
            return None;
        }

        // 4. Build and return User
        Some(User {
            username: user_record.username,
            password: user_record.password_hash,
            roles: user_record.roles.into_iter().collect(),
            authorities: user_record.authorities.into_iter().collect(),
        })
    }
}</code></pre>
<h2 id="example-jwt-authentication"><a class="header" href="#example-jwt-authentication">Example: JWT Authentication</a></h2>
<pre><code class="language-rust">use actix_security::http::security::config::Authenticator;
use actix_security::http::security::User;
use actix_web::dev::ServiceRequest;
use jsonwebtoken::{decode, DecodingKey, Validation};

#[derive(Clone)]
pub struct JwtAuthenticator {
    secret: String,
}

#[derive(Debug, Deserialize)]
struct Claims {
    sub: String,  // username
    roles: Vec&lt;String&gt;,
    authorities: Vec&lt;String&gt;,
    exp: usize,
}

impl Authenticator for JwtAuthenticator {
    fn authenticate(&amp;self, req: &amp;ServiceRequest) -&gt; Option&lt;User&gt; {
        // Extract Bearer token
        let auth_header = req.headers().get("Authorization")?.to_str().ok()?;
        let token = auth_header.strip_prefix("Bearer ")?;

        // Decode and validate JWT
        let token_data = decode::&lt;Claims&gt;(
            token,
            &amp;DecodingKey::from_secret(self.secret.as_bytes()),
            &amp;Validation::default(),
        ).ok()?;

        let claims = token_data.claims;

        // Build User from claims
        Some(User {
            username: claims.sub,
            password: String::new(),  // Not needed for JWT
            roles: claims.roles.into_iter().collect(),
            authorities: claims.authorities.into_iter().collect(),
        })
    }
}</code></pre>
<h2 id="example-api-key-authentication"><a class="header" href="#example-api-key-authentication">Example: API Key Authentication</a></h2>
<pre><code class="language-rust">use actix_security::http::security::config::Authenticator;
use actix_security::http::security::User;
use actix_web::dev::ServiceRequest;
use std::collections::HashMap;

#[derive(Clone)]
pub struct ApiKeyAuthenticator {
    api_keys: HashMap&lt;String, User&gt;,  // API key -&gt; User
}

impl ApiKeyAuthenticator {
    pub fn new() -&gt; Self {
        let mut api_keys = HashMap::new();

        // Register API keys
        api_keys.insert(
            "sk_live_abc123".to_string(),
            User::new("service_a".to_string(), String::new())
                .roles(&amp;["SERVICE".into()])
                .authorities(&amp;["api:read".into(), "api:write".into()]),
        );

        Self { api_keys }
    }
}

impl Authenticator for ApiKeyAuthenticator {
    fn authenticate(&amp;self, req: &amp;ServiceRequest) -&gt; Option&lt;User&gt; {
        // Check X-API-Key header
        let api_key = req.headers()
            .get("X-API-Key")?
            .to_str()
            .ok()?;

        self.api_keys.get(api_key).cloned()
    }
}</code></pre>
<h2 id="example-session-based-authentication"><a class="header" href="#example-session-based-authentication">Example: Session-Based Authentication</a></h2>
<pre><code class="language-rust">use actix_security::http::security::config::Authenticator;
use actix_security::http::security::User;
use actix_session::SessionExt;
use actix_web::dev::ServiceRequest;

#[derive(Clone)]
pub struct SessionAuthenticator {
    user_service: UserService,  // Your user service
}

impl Authenticator for SessionAuthenticator {
    fn authenticate(&amp;self, req: &amp;ServiceRequest) -&gt; Option&lt;User&gt; {
        // Get session
        let session = req.get_session();

        // Get user ID from session
        let user_id: i64 = session.get("user_id").ok()??;

        // Load user from database
        self.user_service.find_by_id(user_id)
    }
}</code></pre>
<h2 id="combining-multiple-authenticators"><a class="header" href="#combining-multiple-authenticators">Combining Multiple Authenticators</a></h2>
<pre><code class="language-rust">#[derive(Clone)]
pub struct CompositeAuthenticator {
    authenticators: Vec&lt;Box&lt;dyn Authenticator&gt;&gt;,
}

impl Authenticator for CompositeAuthenticator {
    fn authenticate(&amp;self, req: &amp;ServiceRequest) -&gt; Option&lt;User&gt; {
        // Try each authenticator in order
        for auth in &amp;self.authenticators {
            if let Some(user) = auth.authenticate(req) {
                return Some(user);
            }
        }
        None
    }
}

// Usage
let authenticator = CompositeAuthenticator {
    authenticators: vec![
        Box::new(JwtAuthenticator::new()),
        Box::new(ApiKeyAuthenticator::new()),
        Box::new(BasicAuthenticator::new()),
    ],
};</code></pre>
<h2 id="using-with-securitytransform"><a class="header" href="#using-with-securitytransform">Using with SecurityTransform</a></h2>
<pre><code class="language-rust">use actix_security::http::security::middleware::SecurityTransform;

let jwt_auth = JwtAuthenticator {
    secret: "your-secret-key".to_string(),
};

App::new()
    .wrap(
        SecurityTransform::new()
            .config_authenticator(move || jwt_auth.clone())
            .config_authorizer(|| {
                AuthorizationManager::request_matcher()
                    // No http_basic() needed for JWT
            })
    )</code></pre>
<h2 id="best-practices-1"><a class="header" href="#best-practices-1">Best Practices</a></h2>
<h3 id="1-handle-errors-gracefully"><a class="header" href="#1-handle-errors-gracefully">1. Handle Errors Gracefully</a></h3>
<pre><code class="language-rust">fn authenticate(&amp;self, req: &amp;ServiceRequest) -&gt; Option&lt;User&gt; {
    // Return None on any error - don't panic
    let header = req.headers().get("Authorization")?;
    let header_str = header.to_str().ok()?;  // Use ok()? for Result
    // ...
}</code></pre>
<h3 id="2-use-constant-time-comparison"><a class="header" href="#2-use-constant-time-comparison">2. Use Constant-Time Comparison</a></h3>
<pre><code class="language-rust">use subtle::ConstantTimeEq;

fn verify_api_key(provided: &amp;str, expected: &amp;str) -&gt; bool {
    provided.as_bytes().ct_eq(expected.as_bytes()).into()
}</code></pre>
<h3 id="3-log-security-events"><a class="header" href="#3-log-security-events">3. Log Security Events</a></h3>
<pre><code class="language-rust">fn authenticate(&amp;self, req: &amp;ServiceRequest) -&gt; Option&lt;User&gt; {
    let result = self.do_authenticate(req);

    match &amp;result {
        Some(user) =&gt; log::info!("User {} authenticated", user.username),
        None =&gt; log::warn!("Authentication failed for request to {}", req.path()),
    }

    result
}</code></pre>
<h3 id="4-rate-limit-authentication"><a class="header" href="#4-rate-limit-authentication">4. Rate Limit Authentication</a></h3>
<p>Consider rate limiting authentication attempts to prevent brute force attacks.</p>
<h2 id="spring-security-comparison-7"><a class="header" href="#spring-security-comparison-7">Spring Security Comparison</a></h2>
<p><strong>Spring Security:</strong></p>
<pre><code class="language-java">@Component
public class CustomAuthenticationProvider implements AuthenticationProvider {
    @Override
    public Authentication authenticate(Authentication authentication) {
        String username = authentication.getName();
        String password = authentication.getCredentials().toString();

        // Your authentication logic

        return new UsernamePasswordAuthenticationToken(
            username, password, authorities);
    }
}
</code></pre>
<p><strong>Actix Security:</strong></p>
<pre><code class="language-rust">impl Authenticator for CustomAuthenticator {
    fn authenticate(&amp;self, req: &amp;ServiceRequest) -&gt; Option&lt;User&gt; {
        // Your authentication logic
        Some(User { /* ... */ })
    }
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="authorization-1"><a class="header" href="#authorization-1">Authorization</a></h1>
<p>Authorization determines <strong>what</strong> an authenticated user can do. Actix Security provides two complementary approaches:</p>
<ol>
<li><strong>URL-Based Authorization</strong> - Configure access rules for URL patterns</li>
<li><strong>Method Security</strong> - Protect individual handlers with attribute macros</li>
</ol>
<h2 id="core-concepts-1"><a class="header" href="#core-concepts-1">Core Concepts</a></h2>
<h3 id="the-authorizer-trait"><a class="header" href="#the-authorizer-trait">The Authorizer Trait</a></h3>
<pre><code class="language-rust">pub trait Authorizer: Clone + Send + Sync + 'static {
    /// Check if the user can access the requested resource.
    fn authorize(&amp;self, user: Option&lt;&amp;User&gt;, req: &amp;ServiceRequest) -&gt; AuthorizationResult;
}

pub enum AuthorizationResult {
    Granted,           // Access allowed
    Denied,            // 403 Forbidden
    LoginRequired,     // 401 Unauthorized / redirect to login
}</code></pre>
<h3 id="roles-vs-authorities"><a class="header" href="#roles-vs-authorities">Roles vs Authorities</a></h3>
<p>Both are permission types, but serve different purposes:</p>
<div class="table-wrapper"><table><thead><tr><th>Concept</th><th>Purpose</th><th>Example</th></tr></thead><tbody>
<tr><td><strong>Roles</strong></td><td>Coarse-grained access</td><td><code>ADMIN</code>, <code>USER</code>, <code>GUEST</code></td></tr>
<tr><td><strong>Authorities</strong></td><td>Fine-grained permissions</td><td><code>users:read</code>, <code>posts:write</code></td></tr>
</tbody></table>
</div>
<p>See <a href="authorization/./roles-authorities.html">Roles vs Authorities</a> for detailed guidance.</p>
<h2 id="url-based-authorization"><a class="header" href="#url-based-authorization">URL-Based Authorization</a></h2>
<p>Configure access rules by URL pattern:</p>
<pre><code class="language-rust">use actix_security::http::security::{AuthorizationManager, Access};

let authorizer = AuthorizationManager::request_matcher()
    .login_url("/login")
    .http_basic()
    // Admin section
    .add_matcher("/admin/.*", Access::new().roles(vec!["ADMIN"]))
    // API requires authentication
    .add_matcher("/api/.*", Access::new().authenticated())
    // User section
    .add_matcher("/user/.*", Access::new().roles(vec!["USER", "ADMIN"]))
    // Everything else is public</code></pre>
<h2 id="method-security"><a class="header" href="#method-security">Method Security</a></h2>
<p>Protect individual handlers with macros:</p>
<pre><code class="language-rust">use actix_security::{secured, pre_authorize};

// Simple role check
#[secured("ADMIN")]
#[get("/admin/users")]
async fn list_users(user: AuthenticatedUser) -&gt; impl Responder { /* ... */ }

// Expression-based
#[pre_authorize("hasRole('USER') AND hasAuthority('posts:write')")]
#[post("/posts")]
async fn create_post(user: AuthenticatedUser) -&gt; impl Responder { /* ... */ }</code></pre>
<h2 id="authorization-flow"><a class="header" href="#authorization-flow">Authorization Flow</a></h2>
<pre><code>Request ‚Üí Authenticator ‚Üí Authorizer
                              ‚Üì
                    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
                    ‚îÇ URL Pattern Match?  ‚îÇ
                    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                              ‚îÇ
           ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
           ‚Üì                  ‚Üì                  ‚Üì
      [Matched]          [No Match]          [Public]
           ‚Üì                  ‚Üì                  ‚Üì
    Check roles/auth    Continue to       Allow request
           ‚Üì             handler
    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
    ‚Üì             ‚Üì
[Granted]    [Denied]
    ‚Üì             ‚Üì
Handler      403 Forbidden
    ‚Üì
Method security
(if applicable)
</code></pre>
<h2 id="spring-security-comparison-8"><a class="header" href="#spring-security-comparison-8">Spring Security Comparison</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Spring Security</th><th>Actix Security</th></tr></thead><tbody>
<tr><td><code>authorizeHttpRequests()</code></td><td><code>RequestMatcherAuthorizer</code></td></tr>
<tr><td><code>hasRole("ADMIN")</code></td><td><code>.roles(vec!["ADMIN"])</code></td></tr>
<tr><td><code>hasAuthority("read")</code></td><td><code>.authorities(vec!["read"])</code></td></tr>
<tr><td><code>authenticated()</code></td><td><code>.authenticated()</code></td></tr>
<tr><td><code>permitAll()</code></td><td>No matcher (default allow)</td></tr>
<tr><td><code>denyAll()</code></td><td><code>Access::new().deny_all()</code></td></tr>
<tr><td><code>@PreAuthorize</code></td><td><code>#[pre_authorize]</code></td></tr>
<tr><td><code>@Secured</code></td><td><code>#[secured]</code></td></tr>
</tbody></table>
</div>
<h2 id="sections-1"><a class="header" href="#sections-1">Sections</a></h2>
<ul>
<li><a href="authorization/./url-based.html">URL-Based Authorization</a> - Configure access by URL pattern</li>
<li><a href="authorization/./method-security.html">Method Security</a> - Protect handlers with macros</li>
<li><a href="authorization/./roles-authorities.html">Roles vs Authorities</a> - When to use each</li>
<li><a href="authorization/./custom.html">Custom Authorizers</a> - Build your own</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="url-based-authorization-1"><a class="header" href="#url-based-authorization-1">URL-Based Authorization</a></h1>
<p>Configure access rules for URL patterns using <code>RequestMatcherAuthorizer</code>.</p>
<h2 id="basic-usage-1"><a class="header" href="#basic-usage-1">Basic Usage</a></h2>
<pre><code class="language-rust">use actix_security::http::security::{AuthorizationManager, Access};

let authorizer = AuthorizationManager::request_matcher()
    .login_url("/login")
    .http_basic()
    .add_matcher("/admin/.*", Access::new().roles(vec!["ADMIN"]))
    .add_matcher("/api/.*", Access::new().authenticated())
    .add_matcher("/user/.*", Access::new().roles(vec!["USER", "ADMIN"]));</code></pre>
<h2 id="url-patterns"><a class="header" href="#url-patterns">URL Patterns</a></h2>
<p>Patterns use <strong>regex</strong> syntax:</p>
<div class="table-wrapper"><table><thead><tr><th>Pattern</th><th>Matches</th></tr></thead><tbody>
<tr><td><code>/admin/.*</code></td><td><code>/admin/</code>, <code>/admin/users</code>, <code>/admin/settings/security</code></td></tr>
<tr><td><code>/api/v[0-9]+/.*</code></td><td><code>/api/v1/users</code>, <code>/api/v2/posts</code></td></tr>
<tr><td><code>/user/[^/]+/profile</code></td><td><code>/user/john/profile</code>, <code>/user/123/profile</code></td></tr>
<tr><td><code>.*\\.json</code></td><td>Any URL ending in <code>.json</code></td></tr>
</tbody></table>
</div>
<h2 id="access-rules"><a class="header" href="#access-rules">Access Rules</a></h2>
<h3 id="role-based-access"><a class="header" href="#role-based-access">Role-Based Access</a></h3>
<pre><code class="language-rust">// Single role
Access::new().roles(vec!["ADMIN"])

// Multiple roles (OR logic - any role grants access)
Access::new().roles(vec!["ADMIN", "MANAGER", "SUPERVISOR"])</code></pre>
<h3 id="authority-based-access"><a class="header" href="#authority-based-access">Authority-Based Access</a></h3>
<pre><code class="language-rust">// Single authority
Access::new().authorities(vec!["users:read"])

// Multiple authorities (OR logic)
Access::new().authorities(vec!["users:read", "users:write"])</code></pre>
<h3 id="combined-rules"><a class="header" href="#combined-rules">Combined Rules</a></h3>
<pre><code class="language-rust">// Require role AND authority
Access::new()
    .roles(vec!["USER"])
    .authorities(vec!["premium:access"])</code></pre>
<h3 id="authentication-only"><a class="header" href="#authentication-only">Authentication Only</a></h3>
<pre><code class="language-rust">// Any authenticated user
Access::new().authenticated()</code></pre>
<h3 id="deny-all"><a class="header" href="#deny-all">Deny All</a></h3>
<pre><code class="language-rust">// Block all access (useful for deprecated endpoints)
Access::new().deny_all()</code></pre>
<h2 id="pattern-order"><a class="header" href="#pattern-order">Pattern Order</a></h2>
<p>Patterns are matched in the order they're added. First match wins.</p>
<pre><code class="language-rust">AuthorizationManager::request_matcher()
    .add_matcher("/admin/public/.*", Access::new().authenticated())  // First
    .add_matcher("/admin/.*", Access::new().roles(vec!["ADMIN"]))    // Second</code></pre>
<p>With this configuration:</p>
<ul>
<li><code>/admin/public/info</code> ‚Üí Any authenticated user</li>
<li><code>/admin/users</code> ‚Üí Only ADMIN role</li>
</ul>
<h2 id="complete-example-3"><a class="header" href="#complete-example-3">Complete Example</a></h2>
<pre><code class="language-rust">use actix_web::{get, web, App, HttpServer, HttpResponse, Responder};
use actix_security::http::security::{
    AuthenticatedUser, AuthenticationManager, AuthorizationManager,
    Argon2PasswordEncoder, PasswordEncoder, User, Access,
};
use actix_security::http::security::middleware::SecurityTransform;

#[get("/")]
async fn index() -&gt; impl Responder {
    HttpResponse::Ok().body("Home - Public")
}

#[get("/admin/dashboard")]
async fn admin_dashboard(user: AuthenticatedUser) -&gt; impl Responder {
    HttpResponse::Ok().body(format!("Admin: {}", user.get_username()))
}

#[get("/api/users")]
async fn api_users(user: AuthenticatedUser) -&gt; impl Responder {
    HttpResponse::Ok().json(vec!["user1", "user2"])
}

#[get("/user/profile")]
async fn user_profile(user: AuthenticatedUser) -&gt; impl Responder {
    HttpResponse::Ok().body(format!("Profile: {}", user.get_username()))
}

fn create_authorizer() -&gt; RequestMatcherAuthorizer {
    AuthorizationManager::request_matcher()
        .login_url("/login")
        .http_basic()
        // Public paths (no matcher = public)
        // Admin section
        .add_matcher("/admin/.*", Access::new().roles(vec!["ADMIN"]))
        // API requires authentication + specific authority
        .add_matcher("/api/.*", Access::new().authorities(vec!["api:access"]))
        // User section
        .add_matcher("/user/.*", Access::new().roles(vec!["USER", "ADMIN"]))
}

#[actix_web::main]
async fn main() -&gt; std::io::Result&lt;()&gt; {
    let encoder = Argon2PasswordEncoder::new();

    HttpServer::new(move || {
        let enc = encoder.clone();
        App::new()
            .wrap(
                SecurityTransform::new()
                    .config_authenticator(move || {
                        AuthenticationManager::in_memory_authentication()
                            .password_encoder(enc.clone())
                            .with_user(
                                User::with_encoded_password("admin", enc.encode("admin"))
                                    .roles(&amp;["ADMIN".into()])
                                    .authorities(&amp;["api:access".into()])
                            )
                            .with_user(
                                User::with_encoded_password("user", enc.encode("user"))
                                    .roles(&amp;["USER".into()])
                            )
                    })
                    .config_authorizer(create_authorizer)
            )
            .service(index)
            .service(admin_dashboard)
            .service(api_users)
            .service(user_profile)
    })
    .bind("127.0.0.1:8080")?
    .run()
    .await
}</code></pre>
<h2 id="testing-url-authorization"><a class="header" href="#testing-url-authorization">Testing URL Authorization</a></h2>
<pre><code class="language-bash"># Public - no auth needed
curl http://127.0.0.1:8080/
# Output: Home - Public

# Admin section - requires ADMIN role
curl -u admin:admin http://127.0.0.1:8080/admin/dashboard
# Output: Admin: admin

curl -u user:user http://127.0.0.1:8080/admin/dashboard
# Output: 403 Forbidden

# API - requires api:access authority
curl -u admin:admin http://127.0.0.1:8080/api/users
# Output: ["user1","user2"]

curl -u user:user http://127.0.0.1:8080/api/users
# Output: 403 Forbidden (user doesn't have api:access)

# User section - requires USER or ADMIN role
curl -u user:user http://127.0.0.1:8080/user/profile
# Output: Profile: user
</code></pre>
<h2 id="spring-security-comparison-9"><a class="header" href="#spring-security-comparison-9">Spring Security Comparison</a></h2>
<p><strong>Spring Security:</strong></p>
<pre><code class="language-java">http.authorizeHttpRequests(auth -&gt; auth
    .requestMatchers("/admin/**").hasRole("ADMIN")
    .requestMatchers("/api/**").hasAuthority("api:access")
    .requestMatchers("/user/**").hasAnyRole("USER", "ADMIN")
    .anyRequest().permitAll()
);
</code></pre>
<p><strong>Actix Security:</strong></p>
<pre><code class="language-rust">AuthorizationManager::request_matcher()
    .add_matcher("/admin/.*", Access::new().roles(vec!["ADMIN"]))
    .add_matcher("/api/.*", Access::new().authorities(vec!["api:access"]))
    .add_matcher("/user/.*", Access::new().roles(vec!["USER", "ADMIN"]))
    // No matcher = permit all</code></pre>
<h2 id="best-practices-2"><a class="header" href="#best-practices-2">Best Practices</a></h2>
<ol>
<li><strong>Order patterns from specific to general</strong></li>
<li><strong>Use method security for complex rules</strong> - URL patterns are best for simple role checks</li>
<li><strong>Don't over-complicate patterns</strong> - Keep regex simple and readable</li>
<li><strong>Document your security rules</strong> - Complex patterns can be hard to maintain</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="method-security-1"><a class="header" href="#method-security-1">Method Security</a></h1>
<p>Protect individual handlers with attribute macros for fine-grained access control.</p>
<h2 id="overview-3"><a class="header" href="#overview-3">Overview</a></h2>
<p>Method security complements URL-based authorization by adding checks directly to handlers. This is useful when:</p>
<ul>
<li>Different endpoints at similar URLs need different permissions</li>
<li>You want self-documenting security rules</li>
<li>Complex authorization logic is needed</li>
</ul>
<h2 id="available-macros"><a class="header" href="#available-macros">Available Macros</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Macro</th><th>Spring Equivalent</th><th>Use Case</th></tr></thead><tbody>
<tr><td><code>#[secured("ROLE")]</code></td><td><code>@Secured</code></td><td>Simple role check</td></tr>
<tr><td><code>#[pre_authorize(...)]</code></td><td><code>@PreAuthorize</code></td><td>Expression-based access</td></tr>
<tr><td><code>#[permit_all]</code></td><td><code>@PermitAll</code></td><td>Explicitly public</td></tr>
<tr><td><code>#[deny_all]</code></td><td><code>@DenyAll</code></td><td>Block all access</td></tr>
<tr><td><code>#[roles_allowed("ROLE")]</code></td><td><code>@RolesAllowed</code></td><td>Java EE style</td></tr>
</tbody></table>
</div>
<h2 id="secured"><a class="header" href="#secured">@secured</a></h2>
<p>Simple role-based access control:</p>
<pre><code class="language-rust">use actix_security::secured;
use actix_security::http::security::AuthenticatedUser;

// Single role
#[secured("ADMIN")]
#[get("/admin/users")]
async fn list_users(user: AuthenticatedUser) -&gt; impl Responder {
    HttpResponse::Ok().body("User list")
}

// Multiple roles (OR logic - any role grants access)
#[secured("ADMIN", "MANAGER")]
#[get("/reports")]
async fn view_reports(user: AuthenticatedUser) -&gt; impl Responder {
    HttpResponse::Ok().body("Reports")
}</code></pre>
<h2 id="pre_authorize"><a class="header" href="#pre_authorize">@pre_authorize</a></h2>
<p>Expression-based access control with full expression language support:</p>
<pre><code class="language-rust">use actix_security::pre_authorize;

// Role check
#[pre_authorize(role = "ADMIN")]
#[get("/admin")]
async fn admin_only(user: AuthenticatedUser) -&gt; impl Responder { /* ... */ }

// Authority check
#[pre_authorize(authority = "users:write")]
#[post("/users")]
async fn create_user(user: AuthenticatedUser) -&gt; impl Responder { /* ... */ }

// Multiple authorities (OR logic)
#[pre_authorize(authorities = ["users:read", "users:write"])]
#[get("/users")]
async fn list_users(user: AuthenticatedUser) -&gt; impl Responder { /* ... */ }

// Authenticated only
#[pre_authorize(authenticated)]
#[get("/profile")]
async fn get_profile(user: AuthenticatedUser) -&gt; impl Responder { /* ... */ }

// Full expression
#[pre_authorize("hasRole('USER') AND hasAuthority('posts:write')")]
#[post("/posts")]
async fn create_post(user: AuthenticatedUser) -&gt; impl Responder { /* ... */ }</code></pre>
<p>See <a href="authorization/../expressions/index.html">Security Expressions</a> for full expression syntax.</p>
<h2 id="permit_all"><a class="header" href="#permit_all">@permit_all</a></h2>
<p>Mark endpoints as explicitly public:</p>
<pre><code class="language-rust">use actix_security::permit_all;

#[permit_all]
#[get("/health")]
async fn health_check() -&gt; impl Responder {
    HttpResponse::Ok().body("OK")
}</code></pre>
<blockquote>
<p><strong>Note</strong>: The handler doesn't receive <code>AuthenticatedUser</code> since no auth is required.</p>
</blockquote>
<h2 id="deny_all"><a class="header" href="#deny_all">@deny_all</a></h2>
<p>Block all access (useful for deprecated endpoints):</p>
<pre><code class="language-rust">use actix_security::deny_all;

#[deny_all]
#[get("/deprecated/endpoint")]
async fn deprecated_endpoint(_user: AuthenticatedUser) -&gt; impl Responder {
    // This code is never reached
    HttpResponse::Ok().body("Never executed")
}</code></pre>
<h2 id="roles_allowed"><a class="header" href="#roles_allowed">@roles_allowed</a></h2>
<p>Java EE style role checking (alias for <code>@secured</code>):</p>
<pre><code class="language-rust">use actix_security::roles_allowed;

#[roles_allowed("ADMIN")]
#[get("/admin")]
async fn admin_panel(user: AuthenticatedUser) -&gt; impl Responder {
    HttpResponse::Ok().body("Admin Panel")
}

#[roles_allowed("ADMIN", "MANAGER")]
#[get("/management")]
async fn management(user: AuthenticatedUser) -&gt; impl Responder {
    HttpResponse::Ok().body("Management")
}</code></pre>
<h2 id="macro-placement"><a class="header" href="#macro-placement">Macro Placement</a></h2>
<p><strong>Important</strong>: Security macros must be placed <strong>before</strong> the route macro:</p>
<pre><code class="language-rust">// ‚úì Correct
#[secured("ADMIN")]
#[get("/admin")]
async fn admin() -&gt; impl Responder { /* ... */ }

// ‚úó Wrong - won't work
#[get("/admin")]
#[secured("ADMIN")]
async fn admin() -&gt; impl Responder { /* ... */ }</code></pre>
<h2 id="combining-with-url-authorization"><a class="header" href="#combining-with-url-authorization">Combining with URL Authorization</a></h2>
<p>Method security and URL authorization work together:</p>
<pre><code class="language-rust">// URL authorization
let authorizer = AuthorizationManager::request_matcher()
    .add_matcher("/api/.*", Access::new().authenticated());

// Method security adds additional checks
#[pre_authorize(authority = "posts:write")]
#[post("/api/posts")]  // URL requires authentication, method requires authority
async fn create_post(user: AuthenticatedUser) -&gt; impl Responder { /* ... */ }</code></pre>
<h2 id="error-handling"><a class="header" href="#error-handling">Error Handling</a></h2>
<p>When access is denied, the macro returns <code>403 Forbidden</code>:</p>
<pre><code class="language-rust">#[secured("ADMIN")]
#[get("/admin")]
async fn admin(user: AuthenticatedUser) -&gt; impl Responder {
    // If user doesn't have ADMIN role, this code never runs
    // A 403 Forbidden response is returned instead
    HttpResponse::Ok().body("Admin")
}</code></pre>
<p>The actual implementation wraps your handler:</p>
<pre><code class="language-rust">// Your code:
#[secured("ADMIN")]
async fn admin(user: AuthenticatedUser) -&gt; impl Responder { /* ... */ }

// Expands to (simplified):
async fn admin(user: AuthenticatedUser) -&gt; Result&lt;impl Responder, AuthError&gt; {
    if !user.has_role("ADMIN") {
        return Err(AuthError::Forbidden);
    }
    Ok(/* your original code */)
}</code></pre>
<h2 id="complete-example-4"><a class="header" href="#complete-example-4">Complete Example</a></h2>
<pre><code class="language-rust">use actix_web::{get, post, delete, App, HttpServer, HttpResponse, Responder};
use actix_security::{secured, pre_authorize, permit_all, deny_all};
use actix_security::http::security::AuthenticatedUser;

// Public endpoints
#[permit_all]
#[get("/")]
async fn index() -&gt; impl Responder {
    HttpResponse::Ok().body("Welcome!")
}

// Authenticated users
#[pre_authorize(authenticated)]
#[get("/dashboard")]
async fn dashboard(user: AuthenticatedUser) -&gt; impl Responder {
    HttpResponse::Ok().body(format!("Hello, {}!", user.get_username()))
}

// Role-based
#[secured("USER")]
#[get("/profile")]
async fn profile(user: AuthenticatedUser) -&gt; impl Responder {
    HttpResponse::Ok().body("Profile")
}

// Authority-based
#[pre_authorize(authority = "posts:write")]
#[post("/posts")]
async fn create_post(user: AuthenticatedUser) -&gt; impl Responder {
    HttpResponse::Created().body("Post created")
}

// Complex expression
#[pre_authorize("hasRole('ADMIN') OR (hasRole('USER') AND hasAuthority('posts:delete'))")]
#[delete("/posts/{id}")]
async fn delete_post(user: AuthenticatedUser) -&gt; impl Responder {
    HttpResponse::Ok().body("Post deleted")
}

// Deprecated
#[deny_all]
#[get("/old-api")]
async fn old_api(_user: AuthenticatedUser) -&gt; impl Responder {
    HttpResponse::Ok().body("Never reached")
}</code></pre>
<h2 id="spring-security-comparison-10"><a class="header" href="#spring-security-comparison-10">Spring Security Comparison</a></h2>
<p><strong>Spring Security:</strong></p>
<pre><code class="language-java">@Secured("ROLE_ADMIN")
@GetMapping("/admin")
public String admin() { return "admin"; }

@PreAuthorize("hasRole('USER') and hasAuthority('posts:write')")
@PostMapping("/posts")
public String createPost() { return "created"; }

@PermitAll
@GetMapping("/public")
public String publicEndpoint() { return "public"; }

@DenyAll
@GetMapping("/deprecated")
public String deprecated() { return "never"; }

@RolesAllowed({"ADMIN", "MANAGER"})
@GetMapping("/management")
public String management() { return "management"; }
</code></pre>
<p><strong>Actix Security:</strong></p>
<pre><code class="language-rust">#[secured("ADMIN")]
#[get("/admin")]
async fn admin() -&gt; impl Responder { /* ... */ }

#[pre_authorize("hasRole('USER') AND hasAuthority('posts:write')")]
#[post("/posts")]
async fn create_post() -&gt; impl Responder { /* ... */ }

#[permit_all]
#[get("/public")]
async fn public_endpoint() -&gt; impl Responder { /* ... */ }

#[deny_all]
#[get("/deprecated")]
async fn deprecated() -&gt; impl Responder { /* ... */ }

#[roles_allowed("ADMIN", "MANAGER")]
#[get("/management")]
async fn management() -&gt; impl Responder { /* ... */ }</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="roles-vs-authorities-1"><a class="header" href="#roles-vs-authorities-1">Roles vs Authorities</a></h1>
<p>Understanding when to use roles versus authorities is key to designing a good security model.</p>
<h2 id="quick-comparison"><a class="header" href="#quick-comparison">Quick Comparison</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Aspect</th><th>Roles</th><th>Authorities</th></tr></thead><tbody>
<tr><td>Granularity</td><td>Coarse</td><td>Fine</td></tr>
<tr><td>Purpose</td><td>User categories</td><td>Specific permissions</td></tr>
<tr><td>Examples</td><td>ADMIN, USER, GUEST</td><td>users:read, posts:write</td></tr>
<tr><td>Use when</td><td>Grouping users</td><td>Controlling actions</td></tr>
</tbody></table>
</div>
<h2 id="roles"><a class="header" href="#roles">Roles</a></h2>
<p>Roles represent <strong>what type of user</strong> someone is.</p>
<h3 id="characteristics"><a class="header" href="#characteristics">Characteristics</a></h3>
<ul>
<li>Coarse-grained categories</li>
<li>Usually few per application (3-10)</li>
<li>Often hierarchical (ADMIN &gt; MANAGER &gt; USER)</li>
<li>Represent job functions or user types</li>
</ul>
<h3 id="examples"><a class="header" href="#examples">Examples</a></h3>
<pre><code class="language-rust">User::with_encoded_password("john", encoded_password)
    .roles(&amp;["USER".into()])

User::with_encoded_password("jane", encoded_password)
    .roles(&amp;["ADMIN".into(), "USER".into()])

User::with_encoded_password("service", encoded_password)
    .roles(&amp;["SERVICE".into()])</code></pre>
<h3 id="usage"><a class="header" href="#usage">Usage</a></h3>
<pre><code class="language-rust">// URL-based
.add_matcher("/admin/.*", Access::new().roles(vec!["ADMIN"]))

// Method-based
#[secured("ADMIN")]
#[get("/admin/dashboard")]
async fn admin_dashboard(user: AuthenticatedUser) -&gt; impl Responder { /* ... */ }</code></pre>
<h2 id="authorities"><a class="header" href="#authorities">Authorities</a></h2>
<p>Authorities represent <strong>what actions</strong> a user can perform.</p>
<h3 id="characteristics-1"><a class="header" href="#characteristics-1">Characteristics</a></h3>
<ul>
<li>Fine-grained permissions</li>
<li>Many per application (10-100+)</li>
<li>Usually flat (no hierarchy)</li>
<li>Represent specific operations</li>
</ul>
<h3 id="naming-convention"><a class="header" href="#naming-convention">Naming Convention</a></h3>
<p>Use <code>resource:action</code> format:</p>
<pre><code>users:read     - Read user data
users:write    - Create/update users
users:delete   - Delete users
posts:read     - Read posts
posts:write    - Create/update posts
posts:publish  - Publish posts
admin:access   - Access admin area
reports:view   - View reports
reports:export - Export reports
</code></pre>
<h3 id="examples-1"><a class="header" href="#examples-1">Examples</a></h3>
<pre><code class="language-rust">User::with_encoded_password("content_manager", encoded_password)
    .roles(&amp;["USER".into()])
    .authorities(&amp;[
        "posts:read".into(),
        "posts:write".into(),
        "posts:publish".into(),
    ])

User::with_encoded_password("analyst", encoded_password)
    .roles(&amp;["USER".into()])
    .authorities(&amp;[
        "reports:view".into(),
        "reports:export".into(),
    ])</code></pre>
<h3 id="usage-1"><a class="header" href="#usage-1">Usage</a></h3>
<pre><code class="language-rust">// URL-based
.add_matcher("/api/reports/.*", Access::new().authorities(vec!["reports:view"]))

// Method-based
#[pre_authorize(authority = "posts:publish")]
#[post("/posts/{id}/publish")]
async fn publish_post(user: AuthenticatedUser) -&gt; impl Responder { /* ... */ }</code></pre>
<h2 id="when-to-use-each"><a class="header" href="#when-to-use-each">When to Use Each</a></h2>
<h3 id="use-roles-when"><a class="header" href="#use-roles-when">Use Roles When:</a></h3>
<ol>
<li>
<p><strong>Controlling broad sections of your app</strong></p>
<pre><code class="language-rust">.add_matcher("/admin/.*", Access::new().roles(vec!["ADMIN"]))</code></pre>
</li>
<li>
<p><strong>User type matters more than specific permission</strong></p>
<pre><code class="language-rust">#[secured("PREMIUM")]
#[get("/premium-content")]
async fn premium_content() -&gt; impl Responder { /* ... */ }</code></pre>
</li>
<li>
<p><strong>Simple applications with clear user categories</strong></p>
</li>
</ol>
<h3 id="use-authorities-when"><a class="header" href="#use-authorities-when">Use Authorities When:</a></h3>
<ol>
<li>
<p><strong>Controlling specific operations</strong></p>
<pre><code class="language-rust">#[pre_authorize(authority = "users:delete")]
#[delete("/users/{id}")]
async fn delete_user() -&gt; impl Responder { /* ... */ }</code></pre>
</li>
<li>
<p><strong>Same role needs different capabilities</strong></p>
<pre><code class="language-rust">// Both are USERs, but with different permissions
User::with_encoded_password("editor", pwd)
    .roles(&amp;["USER".into()])
    .authorities(&amp;["posts:write".into(), "posts:publish".into()])

User::with_encoded_password("writer", pwd)
    .roles(&amp;["USER".into()])
    .authorities(&amp;["posts:write".into()])  // Can write but not publish</code></pre>
</li>
<li>
<p><strong>Building permission-based features</strong></p>
<pre><code class="language-rust">// In handler, check specific permissions
if user.has_authority("reports:export") {
    // Show export button
}</code></pre>
</li>
</ol>
<h2 id="combining-roles-and-authorities"><a class="header" href="#combining-roles-and-authorities">Combining Roles and Authorities</a></h2>
<p>The most flexible approach uses both:</p>
<pre><code class="language-rust">// Define users with roles AND authorities
User::with_encoded_password("admin", encoded_password)
    .roles(&amp;["ADMIN".into()])
    .authorities(&amp;[
        "users:read".into(),
        "users:write".into(),
        "users:delete".into(),
        "posts:read".into(),
        "posts:write".into(),
        "posts:delete".into(),
        "reports:view".into(),
        "reports:export".into(),
    ])

User::with_encoded_password("content_editor", encoded_password)
    .roles(&amp;["USER".into()])
    .authorities(&amp;[
        "posts:read".into(),
        "posts:write".into(),
    ])

// Use roles for broad access control
.add_matcher("/admin/.*", Access::new().roles(vec!["ADMIN"]))

// Use authorities for specific operations
#[pre_authorize(authority = "posts:publish")]
#[post("/posts/{id}/publish")]
async fn publish_post() -&gt; impl Responder { /* ... */ }

// Combine in expressions
#[pre_authorize("hasRole('ADMIN') OR hasAuthority('posts:delete')")]
#[delete("/posts/{id}")]
async fn delete_post() -&gt; impl Responder { /* ... */ }</code></pre>
<h2 id="or-logic"><a class="header" href="#or-logic">OR Logic</a></h2>
<p>Both roles and authorities use <strong>OR logic</strong> - user needs <strong>at least one</strong> matching role OR authority:</p>
<pre><code class="language-rust">// User needs ADMIN OR MANAGER (not both)
Access::new().roles(vec!["ADMIN", "MANAGER"])

// User needs users:read OR users:write (not both)
Access::new().authorities(vec!["users:read", "users:write"])</code></pre>
<p>For <strong>AND logic</strong>, use expressions:</p>
<pre><code class="language-rust">#[pre_authorize("hasRole('USER') AND hasAuthority('premium')")]
async fn premium_feature() -&gt; impl Responder { /* ... */ }</code></pre>
<h2 id="spring-security-comparison-11"><a class="header" href="#spring-security-comparison-11">Spring Security Comparison</a></h2>
<p><strong>Spring Security:</strong></p>
<pre><code class="language-java">// Roles (Spring adds ROLE_ prefix internally)
@Secured("ROLE_ADMIN")
@PreAuthorize("hasRole('ADMIN')")

// Authorities (no prefix)
@PreAuthorize("hasAuthority('users:read')")
</code></pre>
<p><strong>Actix Security:</strong></p>
<pre><code class="language-rust">// Roles (no prefix magic)
#[secured("ADMIN")]
#[pre_authorize("hasRole('ADMIN')")]

// Authorities
#[pre_authorize("hasAuthority('users:read')")]</code></pre>
<blockquote>
<p><strong>Note</strong>: Unlike Spring Security, Actix Security doesn't add any <code>ROLE_</code> prefix. Roles are stored exactly as you define them.</p>
</blockquote>
<h2 id="best-practices-3"><a class="header" href="#best-practices-3">Best Practices</a></h2>
<ol>
<li>
<p><strong>Use consistent naming</strong></p>
<ul>
<li>Roles: UPPERCASE (ADMIN, USER, MANAGER)</li>
<li>Authorities: lowercase:action (users:read, posts:write)</li>
</ul>
</li>
<li>
<p><strong>Don't over-engineer</strong></p>
<ul>
<li>Start with roles only</li>
<li>Add authorities when you need finer control</li>
</ul>
</li>
<li>
<p><strong>Document your permission model</strong></p>
<pre><code class="language-rust">// Document what each authority means
/// users:read - View user list and profiles
/// users:write - Create and update users
/// users:delete - Delete users (admin only)</code></pre>
</li>
<li>
<p><strong>Consider a permission matrix</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Role</th><th>users:read</th><th>users:write</th><th>users:delete</th></tr></thead><tbody>
<tr><td>ADMIN</td><td>‚úì</td><td>‚úì</td><td>‚úì</td></tr>
<tr><td>MANAGER</td><td>‚úì</td><td>‚úì</td><td>-</td></tr>
<tr><td>USER</td><td>‚úì</td><td>-</td><td>-</td></tr>
</tbody></table>
</div></li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="custom-authorizers"><a class="header" href="#custom-authorizers">Custom Authorizers</a></h1>
<p>Create custom authorizers for complex authorization logic, external policy engines, or domain-specific rules.</p>
<h2 id="implementing-the-authorizer-trait"><a class="header" href="#implementing-the-authorizer-trait">Implementing the Authorizer Trait</a></h2>
<pre><code class="language-rust">use actix_security::http::security::config::{Authorizer, AuthorizationResult};
use actix_security::http::security::User;
use actix_web::dev::ServiceRequest;

#[derive(Clone)]
pub struct CustomAuthorizer {
    // Your configuration
}

impl Authorizer for CustomAuthorizer {
    fn authorize(&amp;self, user: Option&lt;&amp;User&gt;, req: &amp;ServiceRequest) -&gt; AuthorizationResult {
        // Your authorization logic
        match user {
            Some(u) if self.check_access(u, req) =&gt; AuthorizationResult::Granted,
            Some(_) =&gt; AuthorizationResult::Denied,
            None =&gt; AuthorizationResult::LoginRequired,
        }
    }
}</code></pre>
<h2 id="authorization-results"><a class="header" href="#authorization-results">Authorization Results</a></h2>
<p>Return one of three results:</p>
<pre><code class="language-rust">pub enum AuthorizationResult {
    Granted,       // Allow access
    Denied,        // 403 Forbidden
    LoginRequired, // 401 Unauthorized or redirect to login
}</code></pre>
<h2 id="example-time-based-access"><a class="header" href="#example-time-based-access">Example: Time-Based Access</a></h2>
<pre><code class="language-rust">use chrono::{Local, Timelike};

#[derive(Clone)]
pub struct BusinessHoursAuthorizer {
    inner: RequestMatcherAuthorizer,
}

impl Authorizer for BusinessHoursAuthorizer {
    fn authorize(&amp;self, user: Option&lt;&amp;User&gt;, req: &amp;ServiceRequest) -&gt; AuthorizationResult {
        // First, check standard authorization
        let result = self.inner.authorize(user, req);
        if result != AuthorizationResult::Granted {
            return result;
        }

        // Then, check business hours for certain paths
        if req.path().starts_with("/business/") {
            let hour = Local::now().hour();
            if hour &lt; 9 || hour &gt;= 17 {
                log::warn!("Access denied outside business hours");
                return AuthorizationResult::Denied;
            }
        }

        AuthorizationResult::Granted
    }
}</code></pre>
<h2 id="example-ip-based-access"><a class="header" href="#example-ip-based-access">Example: IP-Based Access</a></h2>
<pre><code class="language-rust">use std::net::IpAddr;

#[derive(Clone)]
pub struct IpWhitelistAuthorizer {
    inner: RequestMatcherAuthorizer,
    admin_ips: Vec&lt;IpAddr&gt;,
}

impl Authorizer for IpWhitelistAuthorizer {
    fn authorize(&amp;self, user: Option&lt;&amp;User&gt;, req: &amp;ServiceRequest) -&gt; AuthorizationResult {
        // Check if admin path
        if req.path().starts_with("/admin/") {
            // Get client IP
            let client_ip = req.peer_addr()
                .map(|addr| addr.ip());

            // Check whitelist
            if let Some(ip) = client_ip {
                if !self.admin_ips.contains(&amp;ip) {
                    log::warn!("Admin access denied from IP: {}", ip);
                    return AuthorizationResult::Denied;
                }
            } else {
                return AuthorizationResult::Denied;
            }
        }

        self.inner.authorize(user, req)
    }
}</code></pre>
<h2 id="example-resource-owner-check"><a class="header" href="#example-resource-owner-check">Example: Resource Owner Check</a></h2>
<pre><code class="language-rust">#[derive(Clone)]
pub struct ResourceOwnerAuthorizer {
    inner: RequestMatcherAuthorizer,
}

impl Authorizer for ResourceOwnerAuthorizer {
    fn authorize(&amp;self, user: Option&lt;&amp;User&gt;, req: &amp;ServiceRequest) -&gt; AuthorizationResult {
        // Check standard authorization first
        let result = self.inner.authorize(user, req);
        if result != AuthorizationResult::Granted {
            return result;
        }

        // For user-specific paths, check ownership
        // Path: /users/{user_id}/...
        if let Some(user) = user {
            if let Some(captures) = regex::Regex::new(r"/users/(\w+)/")
                .unwrap()
                .captures(req.path())
            {
                let path_user_id = &amp;captures[1];

                // Allow if admin OR owner
                if !user.has_role("ADMIN") &amp;&amp; user.username != path_user_id {
                    return AuthorizationResult::Denied;
                }
            }
        }

        AuthorizationResult::Granted
    }
}</code></pre>
<h2 id="example-external-policy-engine-opa"><a class="header" href="#example-external-policy-engine-opa">Example: External Policy Engine (OPA)</a></h2>
<pre><code class="language-rust">use reqwest::blocking::Client;

#[derive(Clone)]
pub struct OpaAuthorizer {
    opa_url: String,
    client: Client,
}

impl OpaAuthorizer {
    pub fn new(opa_url: &amp;str) -&gt; Self {
        Self {
            opa_url: opa_url.to_string(),
            client: Client::new(),
        }
    }
}

impl Authorizer for OpaAuthorizer {
    fn authorize(&amp;self, user: Option&lt;&amp;User&gt;, req: &amp;ServiceRequest) -&gt; AuthorizationResult {
        let input = serde_json::json!({
            "input": {
                "user": user.map(|u| &amp;u.username),
                "roles": user.map(|u| &amp;u.roles).unwrap_or(&amp;HashSet::new()),
                "path": req.path(),
                "method": req.method().as_str(),
            }
        });

        match self.client
            .post(&amp;format!("{}/v1/data/authz/allow", self.opa_url))
            .json(&amp;input)
            .send()
        {
            Ok(resp) =&gt; {
                let result: serde_json::Value = resp.json().unwrap_or_default();
                if result["result"].as_bool().unwrap_or(false) {
                    AuthorizationResult::Granted
                } else if user.is_some() {
                    AuthorizationResult::Denied
                } else {
                    AuthorizationResult::LoginRequired
                }
            }
            Err(e) =&gt; {
                log::error!("OPA request failed: {}", e);
                AuthorizationResult::Denied // Fail closed
            }
        }
    }
}</code></pre>
<h2 id="composing-authorizers"><a class="header" href="#composing-authorizers">Composing Authorizers</a></h2>
<pre><code class="language-rust">#[derive(Clone)]
pub struct CompositeAuthorizer {
    authorizers: Vec&lt;Box&lt;dyn Authorizer&gt;&gt;,
}

impl Authorizer for CompositeAuthorizer {
    fn authorize(&amp;self, user: Option&lt;&amp;User&gt;, req: &amp;ServiceRequest) -&gt; AuthorizationResult {
        // All authorizers must grant access
        for authorizer in &amp;self.authorizers {
            match authorizer.authorize(user, req) {
                AuthorizationResult::Granted =&gt; continue,
                result =&gt; return result,
            }
        }
        AuthorizationResult::Granted
    }
}

// Usage
let authorizer = CompositeAuthorizer {
    authorizers: vec![
        Box::new(RequestMatcherAuthorizer::new()),
        Box::new(IpWhitelistAuthorizer::new()),
        Box::new(BusinessHoursAuthorizer::new()),
    ],
};</code></pre>
<h2 id="using-with-securitytransform-1"><a class="header" href="#using-with-securitytransform-1">Using with SecurityTransform</a></h2>
<pre><code class="language-rust">let custom_authorizer = CustomAuthorizer::new();

App::new()
    .wrap(
        SecurityTransform::new()
            .config_authenticator(|| /* ... */)
            .config_authorizer(move || custom_authorizer.clone())
    )</code></pre>
<h2 id="best-practices-4"><a class="header" href="#best-practices-4">Best Practices</a></h2>
<h3 id="1-fail-closed"><a class="header" href="#1-fail-closed">1. Fail Closed</a></h3>
<p>When in doubt, deny access:</p>
<pre><code class="language-rust">fn authorize(&amp;self, user: Option&lt;&amp;User&gt;, req: &amp;ServiceRequest) -&gt; AuthorizationResult {
    // If anything goes wrong, deny
    match self.do_authorize(user, req) {
        Ok(result) =&gt; result,
        Err(e) =&gt; {
            log::error!("Authorization error: {}", e);
            AuthorizationResult::Denied
        }
    }
}</code></pre>
<h3 id="2-log-security-decisions"><a class="header" href="#2-log-security-decisions">2. Log Security Decisions</a></h3>
<pre><code class="language-rust">fn authorize(&amp;self, user: Option&lt;&amp;User&gt;, req: &amp;ServiceRequest) -&gt; AuthorizationResult {
    let result = self.check_access(user, req);

    match &amp;result {
        AuthorizationResult::Denied =&gt; {
            log::warn!(
                "Access denied: user={:?}, path={}, method={}",
                user.map(|u| &amp;u.username),
                req.path(),
                req.method()
            );
        }
        _ =&gt; {}
    }

    result
}</code></pre>
<h3 id="3-keep-it-simple"><a class="header" href="#3-keep-it-simple">3. Keep It Simple</a></h3>
<p>Complex authorization logic should live in your business layer, not the authorizer:</p>
<pre><code class="language-rust">// Good - simple authorizer, complex logic elsewhere
fn authorize(&amp;self, user: Option&lt;&amp;User&gt;, req: &amp;ServiceRequest) -&gt; AuthorizationResult {
    if self.policy_service.is_allowed(user, req.path(), req.method()) {
        AuthorizationResult::Granted
    } else {
        AuthorizationResult::Denied
    }
}</code></pre>
<h3 id="4-test-thoroughly"><a class="header" href="#4-test-thoroughly">4. Test Thoroughly</a></h3>
<pre><code class="language-rust">#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_admin_ip_whitelist() {
        let authorizer = IpWhitelistAuthorizer::new(vec!["10.0.0.1".parse().unwrap()]);

        // Test allowed IP
        // Test denied IP
        // Test missing IP
    }
}</code></pre>
<h2 id="spring-security-comparison-12"><a class="header" href="#spring-security-comparison-12">Spring Security Comparison</a></h2>
<p><strong>Spring Security:</strong></p>
<pre><code class="language-java">@Component
public class CustomAuthorizationManager implements AuthorizationManager&lt;RequestAuthorizationContext&gt; {
    @Override
    public AuthorizationDecision check(
        Supplier&lt;Authentication&gt; authentication,
        RequestAuthorizationContext context
    ) {
        // Your logic
        return new AuthorizationDecision(allowed);
    }
}
</code></pre>
<p><strong>Actix Security:</strong></p>
<pre><code class="language-rust">impl Authorizer for CustomAuthorizer {
    fn authorize(&amp;self, user: Option&lt;&amp;User&gt;, req: &amp;ServiceRequest) -&gt; AuthorizationResult {
        // Your logic
        if allowed {
            AuthorizationResult::Granted
        } else {
            AuthorizationResult::Denied
        }
    }
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="security-macros-overview"><a class="header" href="#security-macros-overview">Security Macros Overview</a></h1>
<p>Actix Security provides attribute macros for declarative method-level security, inspired by Spring Security and Java EE annotations.</p>
<h2 id="available-macros-1"><a class="header" href="#available-macros-1">Available Macros</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Macro</th><th>Spring Equivalent</th><th>Java EE Equivalent</th><th>Description</th></tr></thead><tbody>
<tr><td><code>#[secured]</code></td><td><code>@Secured</code></td><td>-</td><td>Role-based access</td></tr>
<tr><td><code>#[pre_authorize]</code></td><td><code>@PreAuthorize</code></td><td>-</td><td>Expression-based access</td></tr>
<tr><td><code>#[permit_all]</code></td><td><code>@PermitAll</code></td><td><code>@PermitAll</code></td><td>Public access</td></tr>
<tr><td><code>#[deny_all]</code></td><td><code>@DenyAll</code></td><td><code>@DenyAll</code></td><td>Block all access</td></tr>
<tr><td><code>#[roles_allowed]</code></td><td><code>@Secured</code></td><td><code>@RolesAllowed</code></td><td>Java EE style roles</td></tr>
</tbody></table>
</div>
<h2 id="quick-reference"><a class="header" href="#quick-reference">Quick Reference</a></h2>
<pre><code class="language-rust">use actix_security::{secured, pre_authorize, permit_all, deny_all, roles_allowed};
use actix_security::http::security::AuthenticatedUser;

// Simple role check
#[secured("ADMIN")]
#[get("/admin")]
async fn admin(user: AuthenticatedUser) -&gt; impl Responder { /* ... */ }

// Multiple roles (OR)
#[secured("ADMIN", "MANAGER")]
#[get("/management")]
async fn management(user: AuthenticatedUser) -&gt; impl Responder { /* ... */ }

// Expression-based
#[pre_authorize("hasRole('USER') AND hasAuthority('posts:write')")]
#[post("/posts")]
async fn create_post(user: AuthenticatedUser) -&gt; impl Responder { /* ... */ }

// Authority check
#[pre_authorize(authority = "users:delete")]
#[delete("/users/{id}")]
async fn delete_user(user: AuthenticatedUser) -&gt; impl Responder { /* ... */ }

// Authenticated only
#[pre_authorize(authenticated)]
#[get("/profile")]
async fn profile(user: AuthenticatedUser) -&gt; impl Responder { /* ... */ }

// Public endpoint
#[permit_all]
#[get("/health")]
async fn health() -&gt; impl Responder { /* ... */ }

// Disabled endpoint
#[deny_all]
#[get("/deprecated")]
async fn deprecated(_user: AuthenticatedUser) -&gt; impl Responder { /* ... */ }

// Java EE style
#[roles_allowed("ADMIN", "USER")]
#[get("/app")]
async fn app(user: AuthenticatedUser) -&gt; impl Responder { /* ... */ }</code></pre>
<h2 id="how-they-work"><a class="header" href="#how-they-work">How They Work</a></h2>
<p>Security macros wrap your handler with authorization checks at compile time. When a check fails, a <code>403 Forbidden</code> response is returned before your handler code executes.</p>
<h3 id="before-your-code"><a class="header" href="#before-your-code">Before (your code)</a></h3>
<pre><code class="language-rust">#[secured("ADMIN")]
#[get("/admin")]
async fn admin(user: AuthenticatedUser) -&gt; impl Responder {
    HttpResponse::Ok().body("Admin")
}</code></pre>
<h3 id="after-macro-expansion-simplified"><a class="header" href="#after-macro-expansion-simplified">After (macro expansion, simplified)</a></h3>
<pre><code class="language-rust">#[get("/admin")]
async fn admin(user: AuthenticatedUser) -&gt; Result&lt;impl Responder, AuthError&gt; {
    // Injected security check
    if !user.has_any_role(&amp;["ADMIN"]) {
        return Err(AuthError::Forbidden);
    }

    // Your original code
    Ok(HttpResponse::Ok().body("Admin"))
}</code></pre>
<h2 id="macro-placement-1"><a class="header" href="#macro-placement-1">Macro Placement</a></h2>
<p><strong>Important</strong>: Security macros must be placed <strong>before</strong> the route macro:</p>
<pre><code class="language-rust">// ‚úì Correct
#[secured("ADMIN")]
#[get("/admin")]
async fn admin() -&gt; impl Responder { /* ... */ }

// ‚úó Wrong - security check won't be applied
#[get("/admin")]
#[secured("ADMIN")]
async fn admin() -&gt; impl Responder { /* ... */ }</code></pre>
<h2 id="compile-time-expression-parsing"><a class="header" href="#compile-time-expression-parsing">Compile-Time Expression Parsing</a></h2>
<p>For <code>#[pre_authorize]</code> with expressions, parsing and validation happens at compile time:</p>
<pre><code class="language-rust">// This is validated at compile time
#[pre_authorize("hasRole('ADMIN') OR hasAuthority('users:write')")]
#[get("/users")]
async fn users(user: AuthenticatedUser) -&gt; impl Responder { /* ... */ }

// This would cause a compile error
#[pre_authorize("invalid expression !!!")]  // Compile error
#[get("/users")]
async fn users(user: AuthenticatedUser) -&gt; impl Responder { /* ... */ }</code></pre>
<p>Benefits:</p>
<ul>
<li><strong>Zero runtime overhead</strong> - No expression parsing at request time</li>
<li><strong>Early error detection</strong> - Invalid expressions fail at compile time</li>
<li><strong>Type safety</strong> - Rust's type system ensures correctness</li>
</ul>
<h2 id="sections-2"><a class="header" href="#sections-2">Sections</a></h2>
<ul>
<li><a href="macros/./secured.html">@secured</a> - Simple role-based security</li>
<li><a href="macros/./pre-authorize.html">@pre_authorize</a> - Expression-based security</li>
<li><a href="macros/./permit-all.html">@permit_all</a> - Public endpoints</li>
<li><a href="macros/./deny-all.html">@deny_all</a> - Blocked endpoints</li>
<li><a href="macros/./roles-allowed.html">@roles_allowed</a> - Java EE style</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="secured-1"><a class="header" href="#secured-1">@secured</a></h1>
<p>Simple role-based method security. Use when you need to check one or more roles.</p>
<h2 id="syntax"><a class="header" href="#syntax">Syntax</a></h2>
<pre><code class="language-rust">#[secured("ROLE")]           // Single role
#[secured("ROLE1", "ROLE2")] // Multiple roles (OR logic)</code></pre>
<h2 id="basic-usage-2"><a class="header" href="#basic-usage-2">Basic Usage</a></h2>
<pre><code class="language-rust">use actix_web::{get, HttpResponse, Responder};
use actix_security::secured;
use actix_security::http::security::AuthenticatedUser;

// Single role
#[secured("ADMIN")]
#[get("/admin/dashboard")]
async fn admin_dashboard(user: AuthenticatedUser) -&gt; impl Responder {
    HttpResponse::Ok().body(format!("Welcome Admin: {}", user.get_username()))
}

// Multiple roles - user needs ANY of the specified roles
#[secured("ADMIN", "MANAGER", "SUPERVISOR")]
#[get("/reports")]
async fn view_reports(user: AuthenticatedUser) -&gt; impl Responder {
    HttpResponse::Ok().body("Reports")
}</code></pre>
<h2 id="or-logic-1"><a class="header" href="#or-logic-1">OR Logic</a></h2>
<p>When multiple roles are specified, the user needs <strong>at least one</strong> matching role:</p>
<pre><code class="language-rust">#[secured("ADMIN", "MANAGER")]</code></pre>
<p>This grants access if the user has <code>ADMIN</code> OR <code>MANAGER</code> role.</p>
<p>For AND logic, use <code>#[pre_authorize]</code>:</p>
<pre><code class="language-rust">#[pre_authorize("hasRole('ADMIN') AND hasRole('MANAGER')")]</code></pre>
<h2 id="handler-requirements"><a class="header" href="#handler-requirements">Handler Requirements</a></h2>
<p>The handler <strong>must</strong> have an <code>AuthenticatedUser</code> parameter:</p>
<pre><code class="language-rust">// ‚úì Correct
#[secured("USER")]
#[get("/profile")]
async fn profile(user: AuthenticatedUser) -&gt; impl Responder { /* ... */ }

// ‚úó Wrong - missing AuthenticatedUser
#[secured("USER")]
#[get("/profile")]
async fn profile() -&gt; impl Responder { /* ... */ }</code></pre>
<p>The <code>AuthenticatedUser</code> provides access to user information:</p>
<pre><code class="language-rust">#[secured("USER")]
#[get("/profile")]
async fn profile(user: AuthenticatedUser) -&gt; impl Responder {
    let username = user.get_username();
    let roles = user.get_roles();
    let authorities = user.get_authorities();

    HttpResponse::Ok().body(format!(
        "User: {}\nRoles: {:?}\nAuthorities: {:?}",
        username, roles, authorities
    ))
}</code></pre>
<h2 id="examples-2"><a class="header" href="#examples-2">Examples</a></h2>
<h3 id="admin-only-endpoint"><a class="header" href="#admin-only-endpoint">Admin-Only Endpoint</a></h3>
<pre><code class="language-rust">#[secured("ADMIN")]
#[get("/admin/users")]
async fn list_all_users(user: AuthenticatedUser) -&gt; impl Responder {
    // Only ADMIN can access
    HttpResponse::Ok().json(get_all_users())
}</code></pre>
<h3 id="premium-content"><a class="header" href="#premium-content">Premium Content</a></h3>
<pre><code class="language-rust">#[secured("PREMIUM", "ADMIN")]
#[get("/premium/content")]
async fn premium_content(user: AuthenticatedUser) -&gt; impl Responder {
    // PREMIUM users and ADMINs can access
    HttpResponse::Ok().body("Exclusive content")
}</code></pre>
<h3 id="service-account"><a class="header" href="#service-account">Service Account</a></h3>
<pre><code class="language-rust">#[secured("SERVICE")]
#[post("/internal/sync")]
async fn internal_sync(user: AuthenticatedUser) -&gt; impl Responder {
    // Only SERVICE accounts can call this
    HttpResponse::Ok().body("Synced")
}</code></pre>
<h2 id="error-response"><a class="header" href="#error-response">Error Response</a></h2>
<p>When access is denied, a <code>403 Forbidden</code> response is returned:</p>
<pre><code>HTTP/1.1 403 Forbidden
Content-Length: 0
</code></pre>
<h2 id="how-it-works-1"><a class="header" href="#how-it-works-1">How It Works</a></h2>
<p>The macro expands to:</p>
<pre><code class="language-rust">// Input
#[secured("ADMIN")]
#[get("/admin")]
async fn admin(user: AuthenticatedUser) -&gt; impl Responder {
    HttpResponse::Ok().body("Admin")
}

// Expansion (simplified)
#[get("/admin")]
async fn admin(user: AuthenticatedUser) -&gt; Result&lt;impl Responder, AuthError&gt; {
    if !user.has_any_role(&amp;["ADMIN".to_string()]) {
        return Err(AuthError::Forbidden);
    }
    Ok(HttpResponse::Ok().body("Admin"))
}</code></pre>
<h2 id="spring-security-comparison-13"><a class="header" href="#spring-security-comparison-13">Spring Security Comparison</a></h2>
<p><strong>Spring Security:</strong></p>
<pre><code class="language-java">@Secured("ROLE_ADMIN")
@GetMapping("/admin")
public String admin() {
    return "admin";
}

@Secured({"ROLE_ADMIN", "ROLE_MANAGER"})
@GetMapping("/management")
public String management() {
    return "management";
}
</code></pre>
<p><strong>Actix Security:</strong></p>
<pre><code class="language-rust">#[secured("ADMIN")]
#[get("/admin")]
async fn admin(user: AuthenticatedUser) -&gt; impl Responder {
    HttpResponse::Ok().body("admin")
}

#[secured("ADMIN", "MANAGER")]
#[get("/management")]
async fn management(user: AuthenticatedUser) -&gt; impl Responder {
    HttpResponse::Ok().body("management")
}</code></pre>
<blockquote>
<p><strong>Note</strong>: Unlike Spring Security, Actix Security doesn't add a <code>ROLE_</code> prefix. Roles are used exactly as specified.</p>
</blockquote>
<h2 id="when-to-use"><a class="header" href="#when-to-use">When to Use</a></h2>
<p>Use <code>#[secured]</code> when:</p>
<ul>
<li>You need simple role checks</li>
<li>OR logic is sufficient</li>
<li>You don't need expressions</li>
</ul>
<p>Use <code>#[pre_authorize]</code> instead when:</p>
<ul>
<li>You need authority checks</li>
<li>You need AND logic</li>
<li>You need complex expressions</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pre_authorize-1"><a class="header" href="#pre_authorize-1">@pre_authorize</a></h1>
<p>Expression-based method security. The most powerful and flexible security macro.</p>
<h2 id="syntax-options"><a class="header" href="#syntax-options">Syntax Options</a></h2>
<pre><code class="language-rust">// Simple checks
#[pre_authorize(authenticated)]               // Any authenticated user
#[pre_authorize(role = "ADMIN")]              // Single role
#[pre_authorize(authority = "users:write")]   // Single authority
#[pre_authorize(authorities = ["a", "b"])]    // Multiple authorities (OR)

// Expression syntax
#[pre_authorize("hasRole('ADMIN')")]
#[pre_authorize("hasRole('USER') AND hasAuthority('posts:write')")]
#[pre_authorize("hasAnyRole('ADMIN', 'MANAGER') OR hasAuthority('reports:view')")]</code></pre>
<h2 id="simple-checks"><a class="header" href="#simple-checks">Simple Checks</a></h2>
<h3 id="authenticated-only"><a class="header" href="#authenticated-only">Authenticated Only</a></h3>
<pre><code class="language-rust">#[pre_authorize(authenticated)]
#[get("/profile")]
async fn profile(user: AuthenticatedUser) -&gt; impl Responder {
    HttpResponse::Ok().body(format!("Hello, {}!", user.get_username()))
}</code></pre>
<h3 id="single-role"><a class="header" href="#single-role">Single Role</a></h3>
<pre><code class="language-rust">#[pre_authorize(role = "ADMIN")]
#[get("/admin")]
async fn admin(user: AuthenticatedUser) -&gt; impl Responder {
    HttpResponse::Ok().body("Admin panel")
}</code></pre>
<h3 id="single-authority"><a class="header" href="#single-authority">Single Authority</a></h3>
<pre><code class="language-rust">#[pre_authorize(authority = "users:delete")]
#[delete("/users/{id}")]
async fn delete_user(user: AuthenticatedUser, path: web::Path&lt;i64&gt;) -&gt; impl Responder {
    HttpResponse::Ok().body(format!("Deleted user {}", path.into_inner()))
}</code></pre>
<h3 id="multiple-authorities-or"><a class="header" href="#multiple-authorities-or">Multiple Authorities (OR)</a></h3>
<pre><code class="language-rust">#[pre_authorize(authorities = ["users:read", "users:write"])]
#[get("/users")]
async fn list_users(user: AuthenticatedUser) -&gt; impl Responder {
    HttpResponse::Ok().json(vec!["user1", "user2"])
}</code></pre>
<h2 id="expression-syntax"><a class="header" href="#expression-syntax">Expression Syntax</a></h2>
<p>For complex authorization rules, use the expression syntax:</p>
<pre><code class="language-rust">#[pre_authorize("expression")]</code></pre>
<h3 id="available-functions"><a class="header" href="#available-functions">Available Functions</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Function</th><th>Description</th></tr></thead><tbody>
<tr><td><code>hasRole('ROLE')</code></td><td>User has the specified role</td></tr>
<tr><td><code>hasAnyRole('R1', 'R2')</code></td><td>User has any of the roles</td></tr>
<tr><td><code>hasAuthority('auth')</code></td><td>User has the authority</td></tr>
<tr><td><code>hasAnyAuthority('a1', 'a2')</code></td><td>User has any of the authorities</td></tr>
<tr><td><code>isAuthenticated()</code></td><td>User is authenticated</td></tr>
<tr><td><code>permitAll()</code></td><td>Always allow</td></tr>
<tr><td><code>denyAll()</code></td><td>Always deny</td></tr>
</tbody></table>
</div>
<h3 id="operators"><a class="header" href="#operators">Operators</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Operator</th><th>Description</th></tr></thead><tbody>
<tr><td><code>AND</code></td><td>Both conditions must be true</td></tr>
<tr><td><code>OR</code></td><td>Either condition can be true</td></tr>
<tr><td><code>NOT</code></td><td>Negates the condition</td></tr>
<tr><td><code>( )</code></td><td>Groups expressions</td></tr>
</tbody></table>
</div>
<h2 id="expression-examples"><a class="header" href="#expression-examples">Expression Examples</a></h2>
<h3 id="basic-expressions"><a class="header" href="#basic-expressions">Basic Expressions</a></h3>
<pre><code class="language-rust">// Role check
#[pre_authorize("hasRole('ADMIN')")]

// Authority check
#[pre_authorize("hasAuthority('posts:write')")]

// Any of multiple roles
#[pre_authorize("hasAnyRole('ADMIN', 'MANAGER', 'SUPERVISOR')")]

// Any of multiple authorities
#[pre_authorize("hasAnyAuthority('posts:read', 'posts:write')")]</code></pre>
<h3 id="combining-with-and"><a class="header" href="#combining-with-and">Combining with AND</a></h3>
<pre><code class="language-rust">// Must have role AND authority
#[pre_authorize("hasRole('USER') AND hasAuthority('posts:write')")]
#[post("/posts")]
async fn create_post(user: AuthenticatedUser) -&gt; impl Responder {
    HttpResponse::Created().body("Post created")
}</code></pre>
<h3 id="combining-with-or"><a class="header" href="#combining-with-or">Combining with OR</a></h3>
<pre><code class="language-rust">// Either admin role OR specific authority
#[pre_authorize("hasRole('ADMIN') OR hasAuthority('users:write')")]
#[put("/users/{id}")]
async fn update_user(user: AuthenticatedUser) -&gt; impl Responder {
    HttpResponse::Ok().body("User updated")
}</code></pre>
<h3 id="using-not"><a class="header" href="#using-not">Using NOT</a></h3>
<pre><code class="language-rust">// Anyone except guests
#[pre_authorize("NOT hasRole('GUEST')")]
#[get("/premium")]
async fn premium(user: AuthenticatedUser) -&gt; impl Responder {
    HttpResponse::Ok().body("Premium content")
}</code></pre>
<h3 id="complex-expressions"><a class="header" href="#complex-expressions">Complex Expressions</a></h3>
<pre><code class="language-rust">// Admin OR (User with write permission)
#[pre_authorize("hasRole('ADMIN') OR (hasRole('USER') AND hasAuthority('posts:write'))")]
#[post("/posts")]
async fn create_post(user: AuthenticatedUser) -&gt; impl Responder {
    HttpResponse::Created().body("Post created")
}

// Multiple conditions
#[pre_authorize("(hasAnyRole('ADMIN', 'MANAGER')) AND hasAuthority('reports:export')")]
#[get("/reports/export")]
async fn export_reports(user: AuthenticatedUser) -&gt; impl Responder {
    HttpResponse::Ok().body("Exported")
}</code></pre>
<h3 id="permit-all--deny-all"><a class="header" href="#permit-all--deny-all">Permit All / Deny All</a></h3>
<pre><code class="language-rust">#[pre_authorize("permitAll()")]
#[get("/public")]
async fn public_info(user: AuthenticatedUser) -&gt; impl Responder {
    HttpResponse::Ok().body("Public")
}

#[pre_authorize("denyAll()")]
#[get("/disabled")]
async fn disabled(_user: AuthenticatedUser) -&gt; impl Responder {
    HttpResponse::Ok().body("Never reached")
}</code></pre>
<h2 id="compile-time-validation"><a class="header" href="#compile-time-validation">Compile-Time Validation</a></h2>
<p>Expressions are parsed and validated at compile time:</p>
<pre><code class="language-rust">// ‚úì Valid - compiles successfully
#[pre_authorize("hasRole('ADMIN') AND hasAuthority('users:write')")]

// ‚úó Invalid - compile error: unexpected token
#[pre_authorize("hasRole('ADMIN') &amp;&amp; hasAuthority('users:write')")]

// ‚úó Invalid - compile error: unmatched parenthesis
#[pre_authorize("hasRole('ADMIN'")]

// ‚úó Invalid - compile error: unknown function
#[pre_authorize("hasPermission('admin')")]</code></pre>
<h2 id="error-response-1"><a class="header" href="#error-response-1">Error Response</a></h2>
<p>When access is denied:</p>
<pre><code>HTTP/1.1 403 Forbidden
Content-Length: 0
</code></pre>
<h2 id="spring-security-comparison-14"><a class="header" href="#spring-security-comparison-14">Spring Security Comparison</a></h2>
<p><strong>Spring Security:</strong></p>
<pre><code class="language-java">@PreAuthorize("hasRole('ADMIN')")
public void adminOnly() {}

@PreAuthorize("hasRole('USER') and hasAuthority('posts:write')")
public void createPost() {}

@PreAuthorize("hasAnyRole('ADMIN', 'MANAGER') or hasAuthority('reports:view')")
public void viewReports() {}

@PreAuthorize("isAuthenticated()")
public void authenticated() {}
</code></pre>
<p><strong>Actix Security:</strong></p>
<pre><code class="language-rust">#[pre_authorize("hasRole('ADMIN')")]
async fn admin_only() {}

#[pre_authorize("hasRole('USER') AND hasAuthority('posts:write')")]
async fn create_post() {}

#[pre_authorize("hasAnyRole('ADMIN', 'MANAGER') OR hasAuthority('reports:view')")]
async fn view_reports() {}

#[pre_authorize("isAuthenticated()")]
async fn authenticated() {}</code></pre>
<p>Key differences:</p>
<ul>
<li>Use <code>AND</code>/<code>OR</code> instead of <code>and</code>/<code>or</code> (case-insensitive but uppercase is conventional)</li>
<li>Use single quotes for strings: <code>'ADMIN'</code> not <code>"ADMIN"</code></li>
</ul>
<h2 id="when-to-use-1"><a class="header" href="#when-to-use-1">When to Use</a></h2>
<p>Use <code>#[pre_authorize]</code> when:</p>
<ul>
<li>You need authority checks</li>
<li>You need AND/OR/NOT logic</li>
<li>You need complex expressions</li>
<li>You want Spring Security-like syntax</li>
</ul>
<p>Use <code>#[secured]</code> instead when:</p>
<ul>
<li>You only need simple role checks</li>
<li>OR logic is sufficient</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="permit_all-1"><a class="header" href="#permit_all-1">@permit_all</a></h1>
<p>Marks an endpoint as publicly accessible. No authentication required.</p>
<h2 id="syntax-1"><a class="header" href="#syntax-1">Syntax</a></h2>
<pre><code class="language-rust">#[permit_all]</code></pre>
<h2 id="usage-2"><a class="header" href="#usage-2">Usage</a></h2>
<pre><code class="language-rust">use actix_web::{get, HttpResponse, Responder};
use actix_security::permit_all;

#[permit_all]
#[get("/health")]
async fn health_check() -&gt; impl Responder {
    HttpResponse::Ok().body("OK")
}

#[permit_all]
#[get("/")]
async fn index() -&gt; impl Responder {
    HttpResponse::Ok().body("Welcome!")
}</code></pre>
<h2 id="no-authenticateduser-required"><a class="header" href="#no-authenticateduser-required">No AuthenticatedUser Required</a></h2>
<p>Unlike other security macros, <code>#[permit_all]</code> handlers don't need an <code>AuthenticatedUser</code> parameter since no authentication is required:</p>
<pre><code class="language-rust">// ‚úì Correct - no AuthenticatedUser needed
#[permit_all]
#[get("/public")]
async fn public_endpoint() -&gt; impl Responder {
    HttpResponse::Ok().body("Public content")
}

// ‚úì Also valid - AuthenticatedUser is optional
#[permit_all]
#[get("/info")]
async fn info(user: Option&lt;AuthenticatedUser&gt;) -&gt; impl Responder {
    match user {
        Some(u) =&gt; HttpResponse::Ok().body(format!("Hello, {}!", u.get_username())),
        None =&gt; HttpResponse::Ok().body("Hello, guest!"),
    }
}</code></pre>
<h2 id="common-use-cases"><a class="header" href="#common-use-cases">Common Use Cases</a></h2>
<h3 id="health-checks"><a class="header" href="#health-checks">Health Checks</a></h3>
<pre><code class="language-rust">#[permit_all]
#[get("/health")]
async fn health() -&gt; impl Responder {
    HttpResponse::Ok().body("OK")
}

#[permit_all]
#[get("/ready")]
async fn readiness() -&gt; impl Responder {
    // Check database, etc.
    HttpResponse::Ok().body("Ready")
}</code></pre>
<h3 id="public-api-endpoints"><a class="header" href="#public-api-endpoints">Public API Endpoints</a></h3>
<pre><code class="language-rust">#[permit_all]
#[get("/api/public/version")]
async fn api_version() -&gt; impl Responder {
    HttpResponse::Ok().json(serde_json::json!({
        "version": "1.0.0"
    }))
}</code></pre>
<h3 id="landing-pages"><a class="header" href="#landing-pages">Landing Pages</a></h3>
<pre><code class="language-rust">#[permit_all]
#[get("/")]
async fn home() -&gt; impl Responder {
    HttpResponse::Ok().body("Welcome to our app!")
}

#[permit_all]
#[get("/about")]
async fn about() -&gt; impl Responder {
    HttpResponse::Ok().body("About us")
}</code></pre>
<h3 id="loginregistration"><a class="header" href="#loginregistration">Login/Registration</a></h3>
<pre><code class="language-rust">#[permit_all]
#[get("/login")]
async fn login_page() -&gt; impl Responder {
    HttpResponse::Ok().body("Login form")
}

#[permit_all]
#[post("/login")]
async fn do_login(form: web::Form&lt;LoginForm&gt;) -&gt; impl Responder {
    // Process login
    HttpResponse::Ok().body("Logged in")
}

#[permit_all]
#[post("/register")]
async fn register(form: web::Form&lt;RegisterForm&gt;) -&gt; impl Responder {
    // Process registration
    HttpResponse::Created().body("Registered")
}</code></pre>
<h2 id="important-note"><a class="header" href="#important-note">Important Note</a></h2>
<p><code>#[permit_all]</code> marks the <strong>handler</strong> as public, but URL-based authorization still applies. If your URL matcher requires authentication for the path, users will still need to authenticate.</p>
<p>To make an endpoint truly public, ensure your URL matcher doesn't require authentication for that path:</p>
<pre><code class="language-rust">// URL authorization
let authorizer = AuthorizationManager::request_matcher()
    .add_matcher("/api/private/.*", Access::new().authenticated())
    // /api/public/.* has no matcher, so it's public by default
    ;

// Handler authorization
#[permit_all]  // Explicitly marks handler as public
#[get("/api/public/info")]
async fn public_info() -&gt; impl Responder {
    HttpResponse::Ok().body("Public info")
}</code></pre>
<h2 id="how-it-works-2"><a class="header" href="#how-it-works-2">How It Works</a></h2>
<p>The macro simply passes through your function unchanged:</p>
<pre><code class="language-rust">// Input
#[permit_all]
#[get("/health")]
async fn health() -&gt; impl Responder {
    HttpResponse::Ok().body("OK")
}

// Output (unchanged)
#[get("/health")]
async fn health() -&gt; impl Responder {
    HttpResponse::Ok().body("OK")
}</code></pre>
<p>The macro serves as documentation and ensures consistency with other security annotations.</p>
<h2 id="spring-security--java-ee-comparison"><a class="header" href="#spring-security--java-ee-comparison">Spring Security / Java EE Comparison</a></h2>
<p><strong>Spring Security / Java EE:</strong></p>
<pre><code class="language-java">@PermitAll
@GetMapping("/public")
public String publicEndpoint() {
    return "public";
}
</code></pre>
<p><strong>Actix Security:</strong></p>
<pre><code class="language-rust">#[permit_all]
#[get("/public")]
async fn public_endpoint() -&gt; impl Responder {
    HttpResponse::Ok().body("public")
}</code></pre>
<h2 id="when-to-use-2"><a class="header" href="#when-to-use-2">When to Use</a></h2>
<p>Use <code>#[permit_all]</code> for:</p>
<ul>
<li>Health check endpoints</li>
<li>Public API endpoints</li>
<li>Login/registration pages</li>
<li>Landing pages</li>
<li>Any endpoint that should be accessible without authentication</li>
</ul>
<p>Consider using URL-based authorization instead when you have many public endpoints under a common path prefix.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="deny_all-1"><a class="header" href="#deny_all-1">@deny_all</a></h1>
<p>Blocks all access to an endpoint. Always returns <code>403 Forbidden</code>.</p>
<h2 id="syntax-2"><a class="header" href="#syntax-2">Syntax</a></h2>
<pre><code class="language-rust">#[deny_all]</code></pre>
<h2 id="usage-3"><a class="header" href="#usage-3">Usage</a></h2>
<pre><code class="language-rust">use actix_web::{get, HttpResponse, Responder};
use actix_security::deny_all;
use actix_security::http::security::AuthenticatedUser;

#[deny_all]
#[get("/disabled")]
async fn disabled_endpoint(_user: AuthenticatedUser) -&gt; impl Responder {
    // This code is never executed
    HttpResponse::Ok().body("Never reached")
}</code></pre>
<h2 id="common-use-cases-1"><a class="header" href="#common-use-cases-1">Common Use Cases</a></h2>
<h3 id="temporarily-disable-endpoints"><a class="header" href="#temporarily-disable-endpoints">Temporarily Disable Endpoints</a></h3>
<pre><code class="language-rust">// Disable an endpoint for maintenance
#[deny_all]
#[post("/payments/process")]
async fn process_payment(_user: AuthenticatedUser) -&gt; impl Responder {
    HttpResponse::Ok().body("Processing")
}</code></pre>
<h3 id="deprecate-endpoints"><a class="header" href="#deprecate-endpoints">Deprecate Endpoints</a></h3>
<pre><code class="language-rust">// Mark old API version as deprecated
#[deny_all]
#[get("/api/v1/users")]
async fn v1_users(_user: AuthenticatedUser) -&gt; impl Responder {
    HttpResponse::Ok().body("Old API")
}</code></pre>
<h3 id="placeholder-for-future-features"><a class="header" href="#placeholder-for-future-features">Placeholder for Future Features</a></h3>
<pre><code class="language-rust">// Reserve endpoint for future implementation
#[deny_all]
#[get("/premium/advanced-analytics")]
async fn advanced_analytics(_user: AuthenticatedUser) -&gt; impl Responder {
    HttpResponse::Ok().body("Coming soon")
}</code></pre>
<h3 id="security-lockdown"><a class="header" href="#security-lockdown">Security Lockdown</a></h3>
<pre><code class="language-rust">// Emergency lockdown of sensitive endpoints
#[deny_all]
#[delete("/admin/database")]
async fn delete_database(_user: AuthenticatedUser) -&gt; impl Responder {
    HttpResponse::Ok().body("Deleted")
}</code></pre>
<h2 id="authenticateduser-parameter"><a class="header" href="#authenticateduser-parameter">AuthenticatedUser Parameter</a></h2>
<p>The handler should have an <code>AuthenticatedUser</code> parameter (typically prefixed with <code>_</code> since it's unused):</p>
<pre><code class="language-rust">#[deny_all]
#[get("/disabled")]
async fn disabled(_user: AuthenticatedUser) -&gt; impl Responder {
    HttpResponse::Ok().body("Never reached")
}</code></pre>
<p>The <code>_user</code> parameter is needed for type inference, even though the handler code is never executed.</p>
<h2 id="response"><a class="header" href="#response">Response</a></h2>
<p>Always returns:</p>
<pre><code>HTTP/1.1 403 Forbidden
Content-Length: 0
</code></pre>
<p>Regardless of:</p>
<ul>
<li>User authentication status</li>
<li>User roles or authorities</li>
<li>Request method or body</li>
</ul>
<h2 id="how-it-works-3"><a class="header" href="#how-it-works-3">How It Works</a></h2>
<p>The macro replaces your handler with one that immediately returns <code>Forbidden</code>:</p>
<pre><code class="language-rust">// Input
#[deny_all]
#[get("/disabled")]
async fn disabled(_user: AuthenticatedUser) -&gt; impl Responder {
    HttpResponse::Ok().body("Never reached")
}

// Expansion (simplified)
#[get("/disabled")]
async fn disabled(_user: AuthenticatedUser) -&gt; Result&lt;impl Responder, AuthError&gt; {
    return Err(AuthError::Forbidden);

    // Unreachable - kept for type inference
    #[allow(unreachable_code)]
    Ok(HttpResponse::Ok().body("Never reached"))
}</code></pre>
<h2 id="spring-security--java-ee-comparison-1"><a class="header" href="#spring-security--java-ee-comparison-1">Spring Security / Java EE Comparison</a></h2>
<p><strong>Spring Security / Java EE:</strong></p>
<pre><code class="language-java">@DenyAll
@GetMapping("/disabled")
public String disabled() {
    return "never reached";
}
</code></pre>
<p><strong>Actix Security:</strong></p>
<pre><code class="language-rust">#[deny_all]
#[get("/disabled")]
async fn disabled(_user: AuthenticatedUser) -&gt; impl Responder {
    HttpResponse::Ok().body("never reached")
}</code></pre>
<h2 id="when-to-use-3"><a class="header" href="#when-to-use-3">When to Use</a></h2>
<p>Use <code>#[deny_all]</code> when:</p>
<ul>
<li>Temporarily disabling an endpoint</li>
<li>Deprecating old API versions</li>
<li>Reserving endpoints for future use</li>
<li>Emergency security lockdown</li>
</ul>
<p>Consider removing the endpoint entirely if it's permanently disabled.</p>
<h2 id="alternatives"><a class="header" href="#alternatives">Alternatives</a></h2>
<h3 id="return-custom-error"><a class="header" href="#return-custom-error">Return Custom Error</a></h3>
<p>If you want to return a custom message:</p>
<pre><code class="language-rust">#[get("/deprecated")]
async fn deprecated() -&gt; impl Responder {
    HttpResponse::Gone().body("This endpoint has been deprecated. Use /api/v2 instead.")
}</code></pre>
<h3 id="conditional-disable"><a class="header" href="#conditional-disable">Conditional Disable</a></h3>
<p>If you want to conditionally disable:</p>
<pre><code class="language-rust">#[get("/feature")]
async fn feature(user: AuthenticatedUser) -&gt; impl Responder {
    if !feature_flag_enabled("new_feature") {
        return HttpResponse::ServiceUnavailable()
            .body("Feature temporarily disabled");
    }
    HttpResponse::Ok().body("Feature content")
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="roles_allowed-1"><a class="header" href="#roles_allowed-1">@roles_allowed</a></h1>
<p>Java EE-style role-based security. Functionally equivalent to <code>#[secured]</code>.</p>
<h2 id="syntax-3"><a class="header" href="#syntax-3">Syntax</a></h2>
<pre><code class="language-rust">#[roles_allowed("ROLE")]           // Single role
#[roles_allowed("ROLE1", "ROLE2")] // Multiple roles (OR logic)</code></pre>
<h2 id="usage-4"><a class="header" href="#usage-4">Usage</a></h2>
<pre><code class="language-rust">use actix_web::{get, HttpResponse, Responder};
use actix_security::roles_allowed;
use actix_security::http::security::AuthenticatedUser;

// Single role
#[roles_allowed("ADMIN")]
#[get("/admin")]
async fn admin_panel(user: AuthenticatedUser) -&gt; impl Responder {
    HttpResponse::Ok().body("Admin Panel")
}

// Multiple roles
#[roles_allowed("ADMIN", "MANAGER")]
#[get("/management")]
async fn management(user: AuthenticatedUser) -&gt; impl Responder {
    HttpResponse::Ok().body("Management")
}</code></pre>
<h2 id="java-ee-equivalent"><a class="header" href="#java-ee-equivalent">Java EE Equivalent</a></h2>
<p>This macro follows the Java EE <code>@RolesAllowed</code> annotation:</p>
<p><strong>Java EE:</strong></p>
<pre><code class="language-java">@RolesAllowed("ADMIN")
@GET
@Path("/admin")
public String admin() {
    return "admin";
}

@RolesAllowed({"ADMIN", "MANAGER"})
@GET
@Path("/management")
public String management() {
    return "management";
}
</code></pre>
<p><strong>Actix Security:</strong></p>
<pre><code class="language-rust">#[roles_allowed("ADMIN")]
#[get("/admin")]
async fn admin(user: AuthenticatedUser) -&gt; impl Responder {
    HttpResponse::Ok().body("admin")
}

#[roles_allowed("ADMIN", "MANAGER")]
#[get("/management")]
async fn management(user: AuthenticatedUser) -&gt; impl Responder {
    HttpResponse::Ok().body("management")
}</code></pre>
<h2 id="comparison-with-secured"><a class="header" href="#comparison-with-secured">Comparison with @secured</a></h2>
<p><code>#[roles_allowed]</code> and <code>#[secured]</code> are functionally identical. Choose based on your preferred naming convention:</p>
<div class="table-wrapper"><table><thead><tr><th>If you're coming from...</th><th>Use</th></tr></thead><tbody>
<tr><td>Spring Security</td><td><code>#[secured]</code></td></tr>
<tr><td>Java EE / Jakarta EE</td><td><code>#[roles_allowed]</code></td></tr>
</tbody></table>
</div>
<pre><code class="language-rust">// These are equivalent:

#[roles_allowed("ADMIN")]
#[get("/admin")]
async fn admin_v1(user: AuthenticatedUser) -&gt; impl Responder { /* ... */ }

#[secured("ADMIN")]
#[get("/admin")]
async fn admin_v2(user: AuthenticatedUser) -&gt; impl Responder { /* ... */ }</code></pre>
<h2 id="or-logic-2"><a class="header" href="#or-logic-2">OR Logic</a></h2>
<p>Like <code>#[secured]</code>, multiple roles use OR logic:</p>
<pre><code class="language-rust">#[roles_allowed("ADMIN", "MANAGER", "SUPERVISOR")]
#[get("/reports")]
async fn reports(user: AuthenticatedUser) -&gt; impl Responder {
    // Access granted if user has ADMIN OR MANAGER OR SUPERVISOR
    HttpResponse::Ok().body("Reports")
}</code></pre>
<p>For AND logic, use <code>#[pre_authorize]</code>:</p>
<pre><code class="language-rust">#[pre_authorize("hasRole('ADMIN') AND hasRole('AUDITOR')")]
#[get("/audit")]
async fn audit(user: AuthenticatedUser) -&gt; impl Responder {
    HttpResponse::Ok().body("Audit")
}</code></pre>
<h2 id="examples-3"><a class="header" href="#examples-3">Examples</a></h2>
<h3 id="admin-dashboard"><a class="header" href="#admin-dashboard">Admin Dashboard</a></h3>
<pre><code class="language-rust">#[roles_allowed("ADMIN")]
#[get("/admin/dashboard")]
async fn admin_dashboard(user: AuthenticatedUser) -&gt; impl Responder {
    HttpResponse::Ok().body(format!("Welcome, Admin {}!", user.get_username()))
}</code></pre>
<h3 id="multi-tier-access"><a class="header" href="#multi-tier-access">Multi-Tier Access</a></h3>
<pre><code class="language-rust">// Executive + Management access
#[roles_allowed("EXECUTIVE", "MANAGER")]
#[get("/reports/financial")]
async fn financial_reports(user: AuthenticatedUser) -&gt; impl Responder {
    HttpResponse::Ok().body("Financial Reports")
}

// All staff access
#[roles_allowed("EXECUTIVE", "MANAGER", "EMPLOYEE")]
#[get("/reports/general")]
async fn general_reports(user: AuthenticatedUser) -&gt; impl Responder {
    HttpResponse::Ok().body("General Reports")
}</code></pre>
<h3 id="service-account-1"><a class="header" href="#service-account-1">Service Account</a></h3>
<pre><code class="language-rust">#[roles_allowed("SERVICE", "ADMIN")]
#[post("/internal/sync")]
async fn internal_sync(user: AuthenticatedUser) -&gt; impl Responder {
    HttpResponse::Ok().body("Synchronized")
}</code></pre>
<h2 id="how-it-works-4"><a class="header" href="#how-it-works-4">How It Works</a></h2>
<p><code>#[roles_allowed]</code> delegates to <code>#[secured]</code> internally:</p>
<pre><code class="language-rust">// Input
#[roles_allowed("ADMIN", "MANAGER")]
#[get("/management")]
async fn management(user: AuthenticatedUser) -&gt; impl Responder {
    HttpResponse::Ok().body("Management")
}

// Effectively same as
#[secured("ADMIN", "MANAGER")]
#[get("/management")]
async fn management(user: AuthenticatedUser) -&gt; impl Responder {
    HttpResponse::Ok().body("Management")
}

// Which expands to (simplified)
#[get("/management")]
async fn management(user: AuthenticatedUser) -&gt; Result&lt;impl Responder, AuthError&gt; {
    if !user.has_any_role(&amp;["ADMIN".to_string(), "MANAGER".to_string()]) {
        return Err(AuthError::Forbidden);
    }
    Ok(HttpResponse::Ok().body("Management"))
}</code></pre>
<h2 id="when-to-use-4"><a class="header" href="#when-to-use-4">When to Use</a></h2>
<p>Use <code>#[roles_allowed]</code> when:</p>
<ul>
<li>You prefer Java EE naming conventions</li>
<li>You're porting code from Java EE</li>
<li>Your team is familiar with <code>@RolesAllowed</code></li>
</ul>
<p>Use <code>#[secured]</code> instead when:</p>
<ul>
<li>You prefer Spring Security naming conventions</li>
<li>Your team is familiar with <code>@Secured</code></li>
</ul>
<p>Use <code>#[pre_authorize]</code> instead when:</p>
<ul>
<li>You need authority checks (not just roles)</li>
<li>You need complex AND/OR/NOT logic</li>
<li>You need expression-based security</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="security-expression-language"><a class="header" href="#security-expression-language">Security Expression Language</a></h1>
<p>Actix Security includes a powerful expression language inspired by Spring Security's SpEL (Spring Expression Language) for security.</p>
<h2 id="overview-4"><a class="header" href="#overview-4">Overview</a></h2>
<p>Security expressions allow you to write complex authorization rules in a readable, declarative syntax:</p>
<pre><code class="language-rust">#[pre_authorize("hasRole('ADMIN') OR (hasRole('USER') AND hasAuthority('posts:write'))")]</code></pre>
<h2 id="key-features"><a class="header" href="#key-features">Key Features</a></h2>
<ul>
<li><strong>Compile-time parsing</strong> - Expressions are validated at compile time</li>
<li><strong>Zero runtime overhead</strong> - Expressions are compiled to Rust code</li>
<li><strong>Parameter references</strong> - Reference handler parameters with <code>#param_name</code> syntax</li>
<li><strong>Custom functions</strong> - Define async authorization functions with any logic</li>
<li><strong>Dual syntax support</strong> - Both Spring Security style (camelCase) and Rust style (snake_case)</li>
</ul>
<h2 id="expression-syntax-1"><a class="header" href="#expression-syntax-1">Expression Syntax</a></h2>
<h3 id="functions"><a class="header" href="#functions">Functions</a></h3>
<p>Both camelCase (Spring Security style) and snake_case (Rust style) are supported:</p>
<div class="table-wrapper"><table><thead><tr><th>Spring Style</th><th>Rust Style</th><th>Description</th></tr></thead><tbody>
<tr><td><code>hasRole('R')</code></td><td><code>has_role('R')</code></td><td>User has role R</td></tr>
<tr><td><code>hasAnyRole('R1', 'R2')</code></td><td><code>has_any_role('R1', 'R2')</code></td><td>User has any of the roles</td></tr>
<tr><td><code>hasAuthority('A')</code></td><td><code>has_authority('A')</code></td><td>User has authority A</td></tr>
<tr><td><code>hasAnyAuthority('A1', 'A2')</code></td><td><code>has_any_authority('A1', 'A2')</code></td><td>User has any of the authorities</td></tr>
<tr><td><code>isAuthenticated()</code></td><td><code>is_authenticated()</code></td><td>User is authenticated</td></tr>
<tr><td><code>permitAll()</code></td><td><code>permit_all()</code></td><td>Always true</td></tr>
<tr><td><code>denyAll()</code></td><td><code>deny_all()</code></td><td>Always false</td></tr>
</tbody></table>
</div>
<h3 id="operators-1"><a class="header" href="#operators-1">Operators</a></h3>
<p>Both Spring Security style and Rust style operators are supported:</p>
<div class="table-wrapper"><table><thead><tr><th>Spring Style</th><th>Rust Style</th><th>Description</th></tr></thead><tbody>
<tr><td><code>AND</code></td><td><code>&amp;&amp;</code></td><td>Both must be true</td></tr>
<tr><td><code>OR</code></td><td><code>||</code></td><td>Either can be true</td></tr>
<tr><td><code>NOT</code></td><td><code>!</code></td><td>Negation</td></tr>
<tr><td><code>( )</code></td><td><code>( )</code></td><td>Grouping</td></tr>
</tbody></table>
</div>
<p><strong>Note:</strong> Operators are case-insensitive (<code>AND</code>, <code>and</code>, <code>And</code> all work).</p>
<h2 id="examples-4"><a class="header" href="#examples-4">Examples</a></h2>
<h3 id="basic-expressions-1"><a class="header" href="#basic-expressions-1">Basic Expressions</a></h3>
<pre><code class="language-rust">// Single role check (both styles work)
#[pre_authorize("hasRole('ADMIN')")]
#[pre_authorize("has_role('ADMIN')")]

// Single authority check
#[pre_authorize("hasAuthority('posts:write')")]
#[pre_authorize("has_authority('posts:write')")]

// Any of multiple roles
#[pre_authorize("hasAnyRole('ADMIN', 'MANAGER', 'SUPERVISOR')")]
#[pre_authorize("has_any_role('ADMIN', 'MANAGER', 'SUPERVISOR')")]

// Any of multiple authorities
#[pre_authorize("hasAnyAuthority('read', 'write', 'delete')")]
#[pre_authorize("has_any_authority('read', 'write', 'delete')")]

// Authenticated user
#[pre_authorize("isAuthenticated()")]</code></pre>
<h3 id="combining-conditions"><a class="header" href="#combining-conditions">Combining Conditions</a></h3>
<pre><code class="language-rust">// AND - both must be true (Spring style)
#[pre_authorize("hasRole('USER') AND hasAuthority('premium')")]
// Rust style
#[pre_authorize("has_role('USER') &amp;&amp; has_authority('premium')")]

// OR - either can be true (Spring style)
#[pre_authorize("hasRole('ADMIN') OR hasAuthority('users:manage')")]
// Rust style
#[pre_authorize("has_role('ADMIN') || has_authority('users:manage')")]

// NOT - negation (Spring style)
#[pre_authorize("NOT hasRole('GUEST')")]
// Rust style
#[pre_authorize("!has_role('GUEST')")]</code></pre>
<h3 id="complex-expressions-1"><a class="header" href="#complex-expressions-1">Complex Expressions</a></h3>
<pre><code class="language-rust">// Admin OR (User with write permission) - Spring style
#[pre_authorize("hasRole('ADMIN') OR (hasRole('USER') AND hasAuthority('posts:write'))")]
// Rust style
#[pre_authorize("has_role('ADMIN') || (has_role('USER') &amp;&amp; has_authority('posts:write'))")]

// Mixed styles also work!
#[pre_authorize("hasRole('ADMIN') || has_role('USER') &amp;&amp; has_authority('write')")]

// Complex nested conditions
#[pre_authorize("has_role('ADMIN') || (has_role('USER') &amp;&amp; (has_authority('a') || has_authority('b')))")]</code></pre>
<h2 id="compile-time-validation-1"><a class="header" href="#compile-time-validation-1">Compile-Time Validation</a></h2>
<p>Expressions are parsed and validated at compile time:</p>
<pre><code class="language-rust">// ‚úì Valid - built-in function
#[pre_authorize("hasRole('ADMIN') AND hasAuthority('write')")]

// ‚úì Valid - custom function with parameter reference (v0.2.2+)
#[pre_authorize("is_tenant_admin(#tenant_id)")]

// ‚úì Valid - combining built-in and custom functions
#[pre_authorize("hasRole('ADMIN') OR my_custom_check(#resource_id)")]

// ‚úó Compile error: Unknown parameter reference
#[pre_authorize("my_check(#nonexistent_param)")]

// ‚úó Compile error: Syntax error
#[pre_authorize("hasRole('ADMIN'")]</code></pre>
<h2 id="how-it-works-5"><a class="header" href="#how-it-works-5">How It Works</a></h2>
<h3 id="1-parse-at-compile-time"><a class="header" href="#1-parse-at-compile-time">1. Parse at Compile Time</a></h3>
<p>The expression is parsed into an AST:</p>
<pre><code>hasRole('ADMIN') OR hasAuthority('write')
                 ‚Üì
         Binary(OR)
        /         \
   hasRole      hasAuthority
   ('ADMIN')    ('write')
</code></pre>
<h3 id="2-generate-rust-code"><a class="header" href="#2-generate-rust-code">2. Generate Rust Code</a></h3>
<p>The AST is compiled to Rust code:</p>
<pre><code class="language-rust">// Expression: hasRole('ADMIN') OR hasAuthority('write')
// Generates:
user.has_role("ADMIN") || user.has_authority("write")</code></pre>
<h3 id="3-execute-at-runtime"><a class="header" href="#3-execute-at-runtime">3. Execute at Runtime</a></h3>
<p>The generated Rust code executes with zero parsing overhead.</p>
<h2 id="spring-security-comparison-15"><a class="header" href="#spring-security-comparison-15">Spring Security Comparison</a></h2>
<p><strong>Spring Security (Java):</strong></p>
<pre><code class="language-java">@PreAuthorize("hasRole('ADMIN') or hasAuthority('users:write')")
public void updateUser() {}

@PreAuthorize("hasAnyRole('ADMIN', 'MANAGER') and hasAuthority('reports:view')")
public void viewReports() {}

@PreAuthorize("isAuthenticated() and !hasRole('GUEST')")
public void premiumContent() {}
</code></pre>
<p><strong>Actix Security (Rust) - Spring style:</strong></p>
<pre><code class="language-rust">#[pre_authorize("hasRole('ADMIN') OR hasAuthority('users:write')")]
async fn update_user() {}

#[pre_authorize("hasAnyRole('ADMIN', 'MANAGER') AND hasAuthority('reports:view')")]
async fn view_reports() {}

#[pre_authorize("isAuthenticated() AND NOT hasRole('GUEST')")]
async fn premium_content() {}</code></pre>
<p><strong>Actix Security (Rust) - Rust style:</strong></p>
<pre><code class="language-rust">#[pre_authorize("has_role('ADMIN') || has_authority('users:write')")]
async fn update_user() {}

#[pre_authorize("has_any_role('ADMIN', 'MANAGER') &amp;&amp; has_authority('reports:view')")]
async fn view_reports() {}

#[pre_authorize("is_authenticated() &amp;&amp; !has_role('GUEST')")]
async fn premium_content() {}</code></pre>
<p><strong>Syntax flexibility:</strong></p>
<ul>
<li>Both camelCase and snake_case function names work</li>
<li>Both <code>AND</code>/<code>OR</code>/<code>NOT</code> and <code>&amp;&amp;</code>/<code>||</code>/<code>!</code> operators work</li>
<li>Operators are case-insensitive (<code>AND</code>, <code>and</code>, <code>And</code> all work)</li>
<li>Use single quotes for strings: <code>'ADMIN'</code> not <code>"ADMIN"</code></li>
</ul>
<h2 id="sections-3"><a class="header" href="#sections-3">Sections</a></h2>
<ul>
<li><a href="expressions/./builtin.html">Built-in Functions</a> - Detailed function reference</li>
<li><a href="expressions/./custom.html">Custom Expressions</a> - Extend with your own functions</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="built-in-expression-functions"><a class="header" href="#built-in-expression-functions">Built-in Expression Functions</a></h1>
<p>Reference for all built-in security expression functions.</p>
<h2 id="role-functions"><a class="header" href="#role-functions">Role Functions</a></h2>
<h3 id="hasrole"><a class="header" href="#hasrole">hasRole</a></h3>
<p>Checks if the user has a specific role.</p>
<pre><code class="language-rust">#[pre_authorize("hasRole('ADMIN')")]</code></pre>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>role</code> - The role name (string)</li>
</ul>
<p><strong>Returns:</strong> <code>true</code> if user has the role</p>
<p><strong>Example:</strong></p>
<pre><code class="language-rust">#[pre_authorize("hasRole('ADMIN')")]
#[get("/admin")]
async fn admin(user: AuthenticatedUser) -&gt; impl Responder {
    HttpResponse::Ok().body("Admin")
}</code></pre>
<h3 id="hasanyrole"><a class="header" href="#hasanyrole">hasAnyRole</a></h3>
<p>Checks if the user has any of the specified roles.</p>
<pre><code class="language-rust">#[pre_authorize("hasAnyRole('ADMIN', 'MANAGER', 'SUPERVISOR')")]</code></pre>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>roles</code> - Variable number of role names</li>
</ul>
<p><strong>Returns:</strong> <code>true</code> if user has at least one of the roles</p>
<p><strong>Example:</strong></p>
<pre><code class="language-rust">#[pre_authorize("hasAnyRole('ADMIN', 'MANAGER')")]
#[get("/management")]
async fn management(user: AuthenticatedUser) -&gt; impl Responder {
    HttpResponse::Ok().body("Management")
}</code></pre>
<h2 id="authority-functions"><a class="header" href="#authority-functions">Authority Functions</a></h2>
<h3 id="hasauthority"><a class="header" href="#hasauthority">hasAuthority</a></h3>
<p>Checks if the user has a specific authority.</p>
<pre><code class="language-rust">#[pre_authorize("hasAuthority('users:write')")]</code></pre>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>authority</code> - The authority name (string)</li>
</ul>
<p><strong>Returns:</strong> <code>true</code> if user has the authority</p>
<p><strong>Example:</strong></p>
<pre><code class="language-rust">#[pre_authorize("hasAuthority('posts:write')")]
#[post("/posts")]
async fn create_post(user: AuthenticatedUser) -&gt; impl Responder {
    HttpResponse::Created().body("Post created")
}</code></pre>
<h3 id="hasanyauthority"><a class="header" href="#hasanyauthority">hasAnyAuthority</a></h3>
<p>Checks if the user has any of the specified authorities.</p>
<pre><code class="language-rust">#[pre_authorize("hasAnyAuthority('read', 'write', 'admin')")]</code></pre>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>authorities</code> - Variable number of authority names</li>
</ul>
<p><strong>Returns:</strong> <code>true</code> if user has at least one of the authorities</p>
<p><strong>Example:</strong></p>
<pre><code class="language-rust">#[pre_authorize("hasAnyAuthority('posts:read', 'posts:write')")]
#[get("/posts")]
async fn list_posts(user: AuthenticatedUser) -&gt; impl Responder {
    HttpResponse::Ok().body("Posts")
}</code></pre>
<h2 id="authentication-functions"><a class="header" href="#authentication-functions">Authentication Functions</a></h2>
<h3 id="isauthenticated"><a class="header" href="#isauthenticated">isAuthenticated</a></h3>
<p>Checks if the user is authenticated.</p>
<pre><code class="language-rust">#[pre_authorize("isAuthenticated()")]</code></pre>
<p><strong>Parameters:</strong> None</p>
<p><strong>Returns:</strong> <code>true</code> if user is authenticated</p>
<p><strong>Example:</strong></p>
<pre><code class="language-rust">#[pre_authorize("isAuthenticated()")]
#[get("/profile")]
async fn profile(user: AuthenticatedUser) -&gt; impl Responder {
    HttpResponse::Ok().body(format!("Hello, {}!", user.get_username()))
}</code></pre>
<h2 id="access-control-functions"><a class="header" href="#access-control-functions">Access Control Functions</a></h2>
<h3 id="permitall"><a class="header" href="#permitall">permitAll</a></h3>
<p>Always returns true. Allows all access.</p>
<pre><code class="language-rust">#[pre_authorize("permitAll()")]</code></pre>
<p><strong>Parameters:</strong> None</p>
<p><strong>Returns:</strong> Always <code>true</code></p>
<p><strong>Example:</strong></p>
<pre><code class="language-rust">#[pre_authorize("permitAll()")]
#[get("/public")]
async fn public_info(user: AuthenticatedUser) -&gt; impl Responder {
    HttpResponse::Ok().body("Public")
}</code></pre>
<blockquote>
<p><strong>Note:</strong> For public endpoints, consider using <code>#[permit_all]</code> macro instead, which doesn't require <code>AuthenticatedUser</code>.</p>
</blockquote>
<h3 id="denyall"><a class="header" href="#denyall">denyAll</a></h3>
<p>Always returns false. Denies all access.</p>
<pre><code class="language-rust">#[pre_authorize("denyAll()")]</code></pre>
<p><strong>Parameters:</strong> None</p>
<p><strong>Returns:</strong> Always <code>false</code></p>
<p><strong>Example:</strong></p>
<pre><code class="language-rust">#[pre_authorize("denyAll()")]
#[get("/disabled")]
async fn disabled(_user: AuthenticatedUser) -&gt; impl Responder {
    HttpResponse::Ok().body("Never reached")
}</code></pre>
<blockquote>
<p><strong>Note:</strong> Consider using <code>#[deny_all]</code> macro instead for cleaner syntax.</p>
</blockquote>
<h2 id="function-reference-table"><a class="header" href="#function-reference-table">Function Reference Table</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Function</th><th>Parameters</th><th>Returns</th><th>Description</th></tr></thead><tbody>
<tr><td><code>hasRole(role)</code></td><td>1 string</td><td>bool</td><td>User has role</td></tr>
<tr><td><code>hasAnyRole(r1, r2, ...)</code></td><td>1+ strings</td><td>bool</td><td>User has any role</td></tr>
<tr><td><code>hasAuthority(auth)</code></td><td>1 string</td><td>bool</td><td>User has authority</td></tr>
<tr><td><code>hasAnyAuthority(a1, a2, ...)</code></td><td>1+ strings</td><td>bool</td><td>User has any authority</td></tr>
<tr><td><code>isAuthenticated()</code></td><td>none</td><td>bool</td><td>User is authenticated</td></tr>
<tr><td><code>permitAll()</code></td><td>none</td><td>bool</td><td>Always true</td></tr>
<tr><td><code>denyAll()</code></td><td>none</td><td>bool</td><td>Always false</td></tr>
</tbody></table>
</div>
<h2 id="combining-functions"><a class="header" href="#combining-functions">Combining Functions</a></h2>
<h3 id="with-and"><a class="header" href="#with-and">With AND</a></h3>
<p>Both conditions must be true:</p>
<pre><code class="language-rust">#[pre_authorize("hasRole('USER') AND hasAuthority('premium')")]</code></pre>
<h3 id="with-or"><a class="header" href="#with-or">With OR</a></h3>
<p>Either condition can be true:</p>
<pre><code class="language-rust">#[pre_authorize("hasRole('ADMIN') OR hasAuthority('users:manage')")]</code></pre>
<h3 id="with-not"><a class="header" href="#with-not">With NOT</a></h3>
<p>Negates a condition:</p>
<pre><code class="language-rust">#[pre_authorize("NOT hasRole('GUEST')")]
#[pre_authorize("isAuthenticated() AND NOT hasRole('SUSPENDED')")]</code></pre>
<h3 id="with-grouping"><a class="header" href="#with-grouping">With Grouping</a></h3>
<p>Use parentheses for complex logic:</p>
<pre><code class="language-rust">#[pre_authorize("(hasRole('ADMIN') OR hasRole('MANAGER')) AND hasAuthority('reports:view')")]</code></pre>
<h2 id="case-sensitivity"><a class="header" href="#case-sensitivity">Case Sensitivity</a></h2>
<ul>
<li><strong>Operators</strong> are case-insensitive: <code>AND</code>, <code>and</code>, <code>And</code> all work</li>
<li><strong>Function names</strong> are case-sensitive: <code>hasRole</code> works, <code>HasRole</code> doesn't</li>
<li><strong>Role/Authority names</strong> are case-sensitive as stored in your user</li>
</ul>
<h2 id="string-quoting"><a class="header" href="#string-quoting">String Quoting</a></h2>
<p>Use single quotes for string arguments:</p>
<pre><code class="language-rust">// ‚úì Correct
#[pre_authorize("hasRole('ADMIN')")]

// ‚úó Wrong - double quotes cause parsing issues
#[pre_authorize("hasRole(\"ADMIN\")")]</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="custom-expressions"><a class="header" href="#custom-expressions">Custom Expressions</a></h1>
<p>Extend the security expression language with your own functions.</p>
<h2 id="custom-functions-with-parameter-references-v022"><a class="header" href="#custom-functions-with-parameter-references-v022">Custom Functions with Parameter References (v0.2.2+)</a></h2>
<p>The most powerful way to implement custom authorization is using async functions with parameter references. This approach allows you to reference handler parameters directly in your expressions, similar to Spring Security's SpEL:</p>
<h3 id="defining-custom-authorization-functions"><a class="header" href="#defining-custom-authorization-functions">Defining Custom Authorization Functions</a></h3>
<p>Create an async function that takes a user reference and any parameters you need:</p>
<pre><code class="language-rust">use actix_security::http::security::User;

/// Check if user is admin of a specific tenant
pub async fn is_tenant_admin(user: &amp;User, tenant_id: i64) -&gt; bool {
    // Admin users can access all tenants
    if user.has_role("ADMIN") {
        return true;
    }
    // Check tenant-specific authority
    user.has_authority(&amp;format!("tenant:{}:admin", tenant_id))
}

/// Check if user can access a specific resource
pub async fn can_access_resource(user: &amp;User, resource_id: String) -&gt; bool {
    // Your authorization logic here
    if user.has_role("ADMIN") {
        return true;
    }
    // Regular users can only access public resources
    resource_id.starts_with("public-")
}</code></pre>
<h3 id="using-parameter-references"><a class="header" href="#using-parameter-references">Using Parameter References</a></h3>
<p>Use <code>#param_name</code> to reference handler parameters in your expressions:</p>
<pre><code class="language-rust">use actix_web::{get, web::Path, HttpResponse, Responder};
use actix_security::pre_authorize;
use actix_security::http::security::AuthenticatedUser;

// Reference the tenant_id path parameter
#[pre_authorize("is_tenant_admin(#tenant_id)")]
#[get("/tenants/{tenant_id}")]
async fn get_tenant(
    tenant_id: Path&lt;i64&gt;,
    user: AuthenticatedUser,
) -&gt; impl Responder {
    HttpResponse::Ok().body(format!("Tenant {}", tenant_id.into_inner()))
}

// Reference a string path parameter
#[pre_authorize("can_access_resource(#resource_id)")]
#[get("/resources/{resource_id}")]
async fn get_resource(
    resource_id: Path&lt;String&gt;,
    user: AuthenticatedUser,
) -&gt; impl Responder {
    HttpResponse::Ok().body("Resource data")
}

// Combine with built-in functions
#[pre_authorize("hasRole('ADMIN') OR is_tenant_admin(#tenant_id)")]
#[get("/tenants/{tenant_id}/settings")]
async fn get_tenant_settings(
    tenant_id: Path&lt;i64&gt;,
    user: AuthenticatedUser,
) -&gt; impl Responder {
    HttpResponse::Ok().body("Settings")
}</code></pre>
<h3 id="supported-extractor-types"><a class="header" href="#supported-extractor-types">Supported Extractor Types</a></h3>
<p>Parameter references work with these Actix Web extractors:</p>
<div class="table-wrapper"><table><thead><tr><th>Extractor</th><th>Example</th><th>Description</th></tr></thead><tbody>
<tr><td><code>Path&lt;T&gt;</code></td><td><code>tenant_id: Path&lt;i64&gt;</code></td><td>URL path parameters</td></tr>
<tr><td><code>Query&lt;T&gt;</code></td><td><code>params: Query&lt;SearchParams&gt;</code></td><td>Query string parameters</td></tr>
<tr><td><code>Json&lt;T&gt;</code></td><td><code>body: Json&lt;CreateRequest&gt;</code></td><td>JSON request body</td></tr>
<tr><td><code>Form&lt;T&gt;</code></td><td><code>form: Form&lt;LoginForm&gt;</code></td><td>Form data</td></tr>
</tbody></table>
</div>
<p><strong>Important:</strong> For <code>Query&lt;T&gt;</code>, <code>Json&lt;T&gt;</code>, and <code>Form&lt;T&gt;</code>, the parameter reference must be the extractor parameter name, not individual fields within the struct. Your custom function should accept the full struct type:</p>
<pre><code class="language-rust">use serde::Deserialize;
use actix_web::{get, post, web};
use actix_security::pre_authorize;
use actix_security::http::security::{AuthenticatedUser, User};

// DTOs must implement Clone for parameter references
#[derive(Debug, Clone, Deserialize)]
pub struct SearchQuery {
    pub min_price: i32,
}

#[derive(Debug, Clone, Deserialize)]
pub struct CreateOrderRequest {
    pub amount: i64,
}

// Custom function accepts the full struct
pub async fn can_search_premium(user: &amp;User, query: SearchQuery) -&gt; bool {
    if user.has_role("ADMIN") {
        return true;
    }
    query.min_price &lt;= 100
}

pub async fn can_create_order(user: &amp;User, order: CreateOrderRequest) -&gt; bool {
    if user.has_role("ADMIN") {
        return true;
    }
    order.amount &lt;= 1000
}

// Reference the extractor parameter name (#query, not #min_price)
#[pre_authorize("can_search_premium(#query)")]
#[get("/products/search")]
async fn search_products(
    query: web::Query&lt;SearchQuery&gt;,
    user: AuthenticatedUser,
) -&gt; impl actix_web::Responder {
    actix_web::HttpResponse::Ok().body("Search results")
}

// Reference the extractor parameter name (#body, not #amount)
#[pre_authorize("can_create_order(#body)")]
#[post("/orders")]
async fn create_order(
    body: web::Json&lt;CreateOrderRequest&gt;,
    user: AuthenticatedUser,
) -&gt; impl actix_web::Responder {
    actix_web::HttpResponse::Created().body("Order created")
}</code></pre>
<h3 id="function-signature-requirements"><a class="header" href="#function-signature-requirements">Function Signature Requirements</a></h3>
<p>Custom authorization functions must:</p>
<ol>
<li>Be <code>async</code></li>
<li>Return <code>bool</code></li>
<li>Take <code>&amp;User</code> as the first parameter</li>
<li>Be in scope where the handler is defined</li>
</ol>
<pre><code class="language-rust">// ‚úì Valid function signature
pub async fn my_check(user: &amp;User, param1: i64, param2: String) -&gt; bool {
    // ...
    true
}

// ‚úó Invalid - not async
pub fn my_check(user: &amp;User, param: i64) -&gt; bool { true }

// ‚úó Invalid - wrong return type
pub async fn my_check(user: &amp;User) -&gt; Result&lt;bool, Error&gt; { Ok(true) }

// ‚úó Invalid - no user parameter
pub async fn my_check(param: i64) -&gt; bool { true }</code></pre>
<h3 id="spring-security-comparison-16"><a class="header" href="#spring-security-comparison-16">Spring Security Comparison</a></h3>
<p><strong>Spring Security (Java):</strong></p>
<pre><code class="language-java">@Service
public class TenantService {
    public boolean isTenantAdmin(Long tenantId) {
        // Uses SecurityContextHolder internally
        Authentication auth = SecurityContextHolder.getContext().getAuthentication();
        return checkTenantAdmin(auth, tenantId);
    }
}

@PreAuthorize("@tenantService.isTenantAdmin(#tenantId)")
@GetMapping("/tenants/{tenantId}")
public Tenant getTenant(@PathVariable Long tenantId) { }
</code></pre>
<p><strong>Actix Security (Rust):</strong></p>
<pre><code class="language-rust">pub async fn is_tenant_admin(user: &amp;User, tenant_id: i64) -&gt; bool {
    user.has_authority(&amp;format!("tenant:{}:admin", tenant_id))
}

#[pre_authorize("is_tenant_admin(#tenant_id)")]
#[get("/tenants/{tenant_id}")]
async fn get_tenant(tenant_id: Path&lt;i64&gt;, user: AuthenticatedUser) -&gt; impl Responder { }</code></pre>
<p>Key differences:</p>
<ul>
<li>In Rust, the user is passed explicitly (no thread-local storage)</li>
<li>Function name is used directly (no <code>@</code> prefix or bean reference)</li>
<li>Compile-time verification of parameter references</li>
</ul>
<hr />
<h2 id="the-expressionroot-trait"><a class="header" href="#the-expressionroot-trait">The ExpressionRoot Trait</a></h2>
<p>Custom expression functions are added by implementing <code>ExpressionRoot</code>:</p>
<pre><code class="language-rust">use actix_security::http::security::expression::ExpressionRoot;
use actix_security::http::security::User;

pub trait ExpressionRoot: Send + Sync {
    /// Evaluate a custom function.
    ///
    /// Returns:
    /// - `Some(true)` - Function matched and returned true
    /// - `Some(false)` - Function matched and returned false
    /// - `None` - Function not recognized, try default implementation
    fn evaluate_function(
        &amp;self,
        name: &amp;str,
        args: &amp;[String],
        user: Option&lt;&amp;User&gt;,
    ) -&gt; Option&lt;bool&gt;;
}</code></pre>
<h2 id="creating-a-custom-expressionroot"><a class="header" href="#creating-a-custom-expressionroot">Creating a Custom ExpressionRoot</a></h2>
<pre><code class="language-rust">use actix_security::http::security::expression::ExpressionRoot;
use actix_security::http::security::User;
use std::collections::HashSet;

#[derive(Clone)]
pub struct CustomExpressionRoot {
    premium_users: HashSet&lt;String&gt;,
    beta_features: HashSet&lt;String&gt;,
}

impl ExpressionRoot for CustomExpressionRoot {
    fn evaluate_function(
        &amp;self,
        name: &amp;str,
        args: &amp;[String],
        user: Option&lt;&amp;User&gt;,
    ) -&gt; Option&lt;bool&gt; {
        match name {
            // isPremium() - check if user has premium subscription
            "isPremium" =&gt; {
                let username = user?.username.clone();
                Some(self.premium_users.contains(&amp;username))
            }

            // hasBetaAccess('feature') - check beta feature access
            "hasBetaAccess" =&gt; {
                let feature = args.get(0)?;
                let user = user?;

                // Admins always have beta access
                if user.has_role("ADMIN") {
                    return Some(true);
                }

                // Check if feature is in beta and user has beta role
                Some(
                    self.beta_features.contains(feature)
                        &amp;&amp; user.has_role("BETA_TESTER"),
                )
            }

            // isOwner('resource_id') - check resource ownership
            "isOwner" =&gt; {
                let resource_id = args.get(0)?;
                let user = user?;
                // Your ownership logic
                Some(self.check_ownership(&amp;user.username, resource_id))
            }

            // Unknown function - return None to use default
            _ =&gt; None,
        }
    }
}

impl CustomExpressionRoot {
    fn check_ownership(&amp;self, username: &amp;str, resource_id: &amp;str) -&gt; bool {
        // Your database lookup logic
        true
    }
}</code></pre>
<h2 id="registering-custom-expressions"><a class="header" href="#registering-custom-expressions">Registering Custom Expressions</a></h2>
<p>Register your custom <code>ExpressionRoot</code> with the security configuration:</p>
<pre><code class="language-rust">use actix_security::http::security::expression::ExpressionEvaluator;

let custom_root = CustomExpressionRoot {
    premium_users: vec!["vip_user".to_string()].into_iter().collect(),
    beta_features: vec!["new_dashboard".to_string()].into_iter().collect(),
};

// Create evaluator with custom root
let evaluator = ExpressionEvaluator::with_root(Box::new(custom_root));</code></pre>
<h2 id="using-custom-functions"><a class="header" href="#using-custom-functions">Using Custom Functions</a></h2>
<p>Once registered, use your custom functions in expressions:</p>
<pre><code class="language-rust">// Check premium status
#[pre_authorize("isPremium()")]
#[get("/premium/content")]
async fn premium_content(user: AuthenticatedUser) -&gt; impl Responder {
    HttpResponse::Ok().body("Premium content")
}

// Check beta access
#[pre_authorize("hasBetaAccess('new_dashboard')")]
#[get("/beta/dashboard")]
async fn beta_dashboard(user: AuthenticatedUser) -&gt; impl Responder {
    HttpResponse::Ok().body("Beta dashboard")
}

// Combine with built-in functions
#[pre_authorize("hasRole('USER') AND isPremium()")]
#[get("/premium/profile")]
async fn premium_profile(user: AuthenticatedUser) -&gt; impl Responder {
    HttpResponse::Ok().body("Premium profile")
}

// Complex custom expression
#[pre_authorize("hasRole('ADMIN') OR (hasRole('USER') AND hasBetaAccess('feature'))")]
#[get("/feature")]
async fn feature(user: AuthenticatedUser) -&gt; impl Responder {
    HttpResponse::Ok().body("Feature")
}</code></pre>
<h2 id="spring-security-comparison-17"><a class="header" href="#spring-security-comparison-17">Spring Security Comparison</a></h2>
<p><strong>Spring Security:</strong></p>
<pre><code class="language-java">// Custom SecurityExpressionRoot
public class CustomSecurityExpressionRoot
    extends SecurityExpressionRoot
    implements MethodSecurityExpressionOperations {

    public boolean isPremium() {
        return premiumService.isPremium(getAuthentication().getName());
    }

    public boolean hasBetaAccess(String feature) {
        return betaService.hasAccess(getAuthentication(), feature);
    }
}

// Usage
@PreAuthorize("isPremium()")
public void premiumContent() {}

@PreAuthorize("hasBetaAccess('new_feature')")
public void betaFeature() {}
</code></pre>
<p><strong>Actix Security:</strong></p>
<pre><code class="language-rust">// Custom ExpressionRoot
impl ExpressionRoot for CustomExpressionRoot {
    fn evaluate_function(&amp;self, name: &amp;str, args: &amp;[String], user: Option&lt;&amp;User&gt;) -&gt; Option&lt;bool&gt; {
        match name {
            "isPremium" =&gt; Some(self.premium_service.is_premium(user?)),
            "hasBetaAccess" =&gt; Some(self.beta_service.has_access(user?, args.get(0)?)),
            _ =&gt; None,
        }
    }
}

// Usage
#[pre_authorize("isPremium()")]
async fn premium_content() {}

#[pre_authorize("hasBetaAccess('new_feature')")]
async fn beta_feature() {}</code></pre>
<h2 id="example-organization-based-access"><a class="header" href="#example-organization-based-access">Example: Organization-Based Access</a></h2>
<pre><code class="language-rust">#[derive(Clone)]
pub struct OrgExpressionRoot {
    org_service: OrgService,
}

impl ExpressionRoot for OrgExpressionRoot {
    fn evaluate_function(
        &amp;self,
        name: &amp;str,
        args: &amp;[String],
        user: Option&lt;&amp;User&gt;,
    ) -&gt; Option&lt;bool&gt; {
        match name {
            // belongsToOrg('org_id') - user belongs to organization
            "belongsToOrg" =&gt; {
                let org_id = args.get(0)?;
                let user = user?;
                Some(self.org_service.user_belongs_to(&amp;user.username, org_id))
            }

            // isOrgAdmin('org_id') - user is admin of organization
            "isOrgAdmin" =&gt; {
                let org_id = args.get(0)?;
                let user = user?;
                Some(self.org_service.is_org_admin(&amp;user.username, org_id))
            }

            // hasOrgPermission('org_id', 'permission')
            "hasOrgPermission" =&gt; {
                let org_id = args.get(0)?;
                let permission = args.get(1)?;
                let user = user?;
                Some(self.org_service.has_permission(&amp;user.username, org_id, permission))
            }

            _ =&gt; None,
        }
    }
}

// Usage
#[pre_authorize("belongsToOrg('acme-corp')")]
async fn org_dashboard() {}

#[pre_authorize("isOrgAdmin('acme-corp') OR hasRole('SUPER_ADMIN')")]
async fn org_settings() {}

#[pre_authorize("hasOrgPermission('acme-corp', 'billing:manage')")]
async fn billing() {}</code></pre>
<h2 id="best-practices-5"><a class="header" href="#best-practices-5">Best Practices</a></h2>
<h3 id="1-return-none-for-unknown-functions"><a class="header" href="#1-return-none-for-unknown-functions">1. Return None for Unknown Functions</a></h3>
<p>Allow fallback to default implementation:</p>
<pre><code class="language-rust">fn evaluate_function(&amp;self, name: &amp;str, args: &amp;[String], user: Option&lt;&amp;User&gt;) -&gt; Option&lt;bool&gt; {
    match name {
        "myFunction" =&gt; Some(/* ... */),
        _ =&gt; None,  // Important: let default handle unknown functions
    }
}</code></pre>
<h3 id="2-handle-missing-user"><a class="header" href="#2-handle-missing-user">2. Handle Missing User</a></h3>
<p>Return <code>false</code> or <code>None</code> when user is required but missing:</p>
<pre><code class="language-rust">"isPremium" =&gt; {
    let user = user?;  // Returns None if no user
    Some(self.check_premium(&amp;user.username))
}</code></pre>
<h3 id="3-validate-arguments"><a class="header" href="#3-validate-arguments">3. Validate Arguments</a></h3>
<p>Check for required arguments:</p>
<pre><code class="language-rust">"hasFeature" =&gt; {
    let feature = args.get(0)?;  // Returns None if missing
    Some(self.check_feature(feature))
}</code></pre>
<h3 id="4-keep-functions-simple"><a class="header" href="#4-keep-functions-simple">4. Keep Functions Simple</a></h3>
<p>Complex logic should live in services:</p>
<pre><code class="language-rust">// Good
"isPremium" =&gt; Some(self.premium_service.is_premium(user?))

// Bad - too much logic in expression root
"isPremium" =&gt; {
    let user = user?;
    let subscription = db.query_subscription(&amp;user.id)?;
    Some(subscription.tier == "premium" &amp;&amp; subscription.expires &gt; now())
}</code></pre>
<h3 id="5-document-your-functions"><a class="header" href="#5-document-your-functions">5. Document Your Functions</a></h3>
<pre><code class="language-rust">/// Custom expression functions for MyApp.
///
/// Available functions:
/// - `isPremium()` - Returns true if user has premium subscription
/// - `hasBetaAccess('feature')` - Returns true if user can access beta feature
/// - `isOrgMember('org_id')` - Returns true if user belongs to organization
impl ExpressionRoot for MyExpressionRoot { /* ... */ }</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="security-headers"><a class="header" href="#security-headers">Security Headers</a></h1>
<p>Protect your application with HTTP security headers middleware.</p>
<h2 id="overview-5"><a class="header" href="#overview-5">Overview</a></h2>
<p><code>SecurityHeaders</code> middleware adds important security headers to all responses:</p>
<ul>
<li><strong>X-Content-Type-Options</strong> - Prevents MIME sniffing</li>
<li><strong>X-Frame-Options</strong> - Protects against clickjacking</li>
<li><strong>X-XSS-Protection</strong> - Legacy XSS protection</li>
<li><strong>Content-Security-Policy</strong> - Controls resource loading</li>
<li><strong>Strict-Transport-Security</strong> - Enforces HTTPS</li>
<li><strong>Referrer-Policy</strong> - Controls referrer information</li>
<li><strong>Permissions-Policy</strong> - Controls browser features</li>
<li><strong>Cache-Control</strong> - Controls caching behavior</li>
</ul>
<h2 id="quick-start-4"><a class="header" href="#quick-start-4">Quick Start</a></h2>
<pre><code class="language-rust">use actix_security::http::security::SecurityHeaders;

App::new()
    .wrap(SecurityHeaders::default())
    .service(/* ... */)</code></pre>
<h2 id="default-configuration"><a class="header" href="#default-configuration">Default Configuration</a></h2>
<pre><code class="language-rust">SecurityHeaders::default()</code></pre>
<p>Adds these headers:</p>
<pre><code>X-Content-Type-Options: nosniff
X-Frame-Options: DENY
X-XSS-Protection: 0
Referrer-Policy: strict-origin-when-cross-origin
</code></pre>
<h2 id="strict-configuration"><a class="header" href="#strict-configuration">Strict Configuration</a></h2>
<pre><code class="language-rust">SecurityHeaders::strict()</code></pre>
<p>Maximum security with all headers:</p>
<pre><code>X-Content-Type-Options: nosniff
X-Frame-Options: DENY
X-XSS-Protection: 0
Content-Security-Policy: default-src 'self'
Strict-Transport-Security: max-age=31536000; includeSubDomains; preload
Referrer-Policy: no-referrer
Permissions-Policy: geolocation=(), microphone=(), camera=()
Cache-Control: no-cache, no-store, must-revalidate
</code></pre>
<h2 id="custom-configuration"><a class="header" href="#custom-configuration">Custom Configuration</a></h2>
<h3 id="x-frame-options"><a class="header" href="#x-frame-options">X-Frame-Options</a></h3>
<p>Protect against clickjacking:</p>
<pre><code class="language-rust">use actix_security::http::security::headers::FrameOptions;

// Block all framing (default)
SecurityHeaders::new().frame_options(FrameOptions::Deny)

// Allow same origin
SecurityHeaders::new().frame_options(FrameOptions::SameOrigin)

// Disable header
SecurityHeaders::new().frame_options(FrameOptions::Disabled)</code></pre>
<h3 id="content-security-policy"><a class="header" href="#content-security-policy">Content-Security-Policy</a></h3>
<p>Control resource loading:</p>
<pre><code class="language-rust">// Basic policy
SecurityHeaders::new()
    .content_security_policy("default-src 'self'")

// More permissive
SecurityHeaders::new()
    .content_security_policy("default-src 'self'; img-src *; script-src 'self' cdn.example.com")

// Complex policy
SecurityHeaders::new()
    .content_security_policy(
        "default-src 'self'; \
         script-src 'self' 'unsafe-inline' cdn.example.com; \
         style-src 'self' 'unsafe-inline'; \
         img-src 'self' data: https:; \
         font-src 'self' fonts.gstatic.com; \
         connect-src 'self' api.example.com"
    )</code></pre>
<h3 id="strict-transport-security-hsts"><a class="header" href="#strict-transport-security-hsts">Strict-Transport-Security (HSTS)</a></h3>
<p>Enforce HTTPS:</p>
<pre><code class="language-rust">// Enable with 1 year max-age
SecurityHeaders::new().hsts(true, 31536000)

// With subdomains
SecurityHeaders::new()
    .hsts(true, 31536000)
    .hsts_include_subdomains(true)

// With preload (for HSTS preload list)
SecurityHeaders::new()
    .hsts(true, 31536000)
    .hsts_include_subdomains(true)
    .hsts_preload(true)</code></pre>
<blockquote>
<p><strong>Warning</strong>: Only enable HSTS preload if you're committed to HTTPS forever. It's difficult to reverse.</p>
</blockquote>
<h3 id="referrer-policy"><a class="header" href="#referrer-policy">Referrer-Policy</a></h3>
<p>Control referrer information:</p>
<pre><code class="language-rust">use actix_security::http::security::headers::ReferrerPolicy;

// No referrer (maximum privacy)
SecurityHeaders::new().referrer_policy(ReferrerPolicy::NoReferrer)

// Same origin only
SecurityHeaders::new().referrer_policy(ReferrerPolicy::SameOrigin)

// Strict origin when cross-origin (default)
SecurityHeaders::new().referrer_policy(ReferrerPolicy::StrictOriginWhenCrossOrigin)

// No referrer when downgrade
SecurityHeaders::new().referrer_policy(ReferrerPolicy::NoReferrerWhenDowngrade)</code></pre>
<h3 id="permissions-policy"><a class="header" href="#permissions-policy">Permissions-Policy</a></h3>
<p>Control browser features:</p>
<pre><code class="language-rust">// Disable geolocation, microphone, camera
SecurityHeaders::new()
    .permissions_policy("geolocation=(), microphone=(), camera=()")

// Allow geolocation for self only
SecurityHeaders::new()
    .permissions_policy("geolocation=(self), microphone=(), camera=()")</code></pre>
<h3 id="cache-control"><a class="header" href="#cache-control">Cache-Control</a></h3>
<p>Control caching:</p>
<pre><code class="language-rust">// No caching (for sensitive data)
SecurityHeaders::new()
    .cache_control("no-cache, no-store, must-revalidate")

// Private caching
SecurityHeaders::new()
    .cache_control("private, max-age=3600")</code></pre>
<h2 id="complete-example-5"><a class="header" href="#complete-example-5">Complete Example</a></h2>
<pre><code class="language-rust">use actix_web::{get, App, HttpServer, HttpResponse, Responder};
use actix_security::http::security::SecurityHeaders;
use actix_security::http::security::headers::{FrameOptions, ReferrerPolicy};

#[get("/")]
async fn index() -&gt; impl Responder {
    HttpResponse::Ok().body("Hello!")
}

#[actix_web::main]
async fn main() -&gt; std::io::Result&lt;()&gt; {
    HttpServer::new(|| {
        App::new()
            .wrap(
                SecurityHeaders::new()
                    .frame_options(FrameOptions::SameOrigin)
                    .content_security_policy("default-src 'self'; img-src *")
                    .hsts(true, 31536000)
                    .hsts_include_subdomains(true)
                    .referrer_policy(ReferrerPolicy::StrictOriginWhenCrossOrigin)
                    .permissions_policy("geolocation=(), microphone=(), camera=()")
                    .cache_control("no-cache")
            )
            .service(index)
    })
    .bind("127.0.0.1:8080")?
    .run()
    .await
}</code></pre>
<h2 id="middleware-order"><a class="header" href="#middleware-order">Middleware Order</a></h2>
<p>Place <code>SecurityHeaders</code> after authentication middleware but before your routes:</p>
<pre><code class="language-rust">App::new()
    .wrap(SecurityHeaders::default())  // Adds security headers
    .wrap(SecurityTransform::new()     // Handles auth
        .config_authenticator(/* ... */)
        .config_authorizer(/* ... */))
    .service(/* ... */)</code></pre>
<h2 id="testing"><a class="header" href="#testing">Testing</a></h2>
<pre><code class="language-rust">use actix_web::{test, App, http::StatusCode};

#[actix_web::test]
async fn test_security_headers() {
    let app = test::init_service(
        App::new()
            .wrap(SecurityHeaders::default())
            .service(test_endpoint)
    ).await;

    let req = test::TestRequest::get().uri("/test").to_request();
    let resp = test::call_service(&amp;app, req).await;

    assert_eq!(resp.status(), StatusCode::OK);

    let headers = resp.headers();
    assert_eq!(headers.get("x-content-type-options").unwrap(), "nosniff");
    assert_eq!(headers.get("x-frame-options").unwrap(), "DENY");
}</code></pre>
<h2 id="spring-security-comparison-18"><a class="header" href="#spring-security-comparison-18">Spring Security Comparison</a></h2>
<p><strong>Spring Security:</strong></p>
<pre><code class="language-java">http.headers(headers -&gt; headers
    .frameOptions(frame -&gt; frame.deny())
    .contentSecurityPolicy(csp -&gt; csp.policyDirectives("default-src 'self'"))
    .httpStrictTransportSecurity(hsts -&gt; hsts
        .maxAgeInSeconds(31536000)
        .includeSubDomains(true))
    .referrerPolicy(referrer -&gt; referrer
        .policy(ReferrerPolicy.STRICT_ORIGIN_WHEN_CROSS_ORIGIN))
);
</code></pre>
<p><strong>Actix Security:</strong></p>
<pre><code class="language-rust">SecurityHeaders::new()
    .frame_options(FrameOptions::Deny)
    .content_security_policy("default-src 'self'")
    .hsts(true, 31536000)
    .hsts_include_subdomains(true)
    .referrer_policy(ReferrerPolicy::StrictOriginWhenCrossOrigin)</code></pre>
<h2 id="security-recommendations"><a class="header" href="#security-recommendations">Security Recommendations</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Header</th><th>Recommended Value</th><th>Notes</th></tr></thead><tbody>
<tr><td>X-Content-Type-Options</td><td><code>nosniff</code></td><td>Always enable</td></tr>
<tr><td>X-Frame-Options</td><td><code>DENY</code> or <code>SAMEORIGIN</code></td><td>Prevent clickjacking</td></tr>
<tr><td>Content-Security-Policy</td><td>App-specific</td><td>Start strict, relax as needed</td></tr>
<tr><td>Strict-Transport-Security</td><td><code>max-age=31536000</code></td><td>Only for HTTPS sites</td></tr>
<tr><td>Referrer-Policy</td><td><code>strict-origin-when-cross-origin</code></td><td>Balance privacy/functionality</td></tr>
<tr><td>Permissions-Policy</td><td>Disable unused features</td><td>Camera, mic, geolocation</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="security-context"><a class="header" href="#security-context">Security Context</a></h1>
<p>Access the current authenticated user from anywhere in your application.</p>
<h2 id="overview-6"><a class="header" href="#overview-6">Overview</a></h2>
<p><code>SecurityContext</code> provides thread-safe access to the current user using Tokio's task-local storage. This is useful when you need to access user information outside of handlers.</p>
<h2 id="basic-usage-3"><a class="header" href="#basic-usage-3">Basic Usage</a></h2>
<pre><code class="language-rust">use actix_security::http::security::SecurityContext;

// Get the current user
if let Some(user) = SecurityContext::get_user() {
    println!("Current user: {}", user.username);
}

// Check role
if SecurityContext::has_role("ADMIN") {
    // Admin-specific logic
}

// Check authority
if SecurityContext::has_authority("posts:write") {
    // Permission-specific logic
}</code></pre>
<h2 id="api-reference"><a class="header" href="#api-reference">API Reference</a></h2>
<h3 id="get_user"><a class="header" href="#get_user">get_user</a></h3>
<p>Returns the current authenticated user, if any.</p>
<pre><code class="language-rust">pub fn get_user() -&gt; Option&lt;User&gt;</code></pre>
<p><strong>Example:</strong></p>
<pre><code class="language-rust">match SecurityContext::get_user() {
    Some(user) =&gt; println!("Logged in as: {}", user.username),
    None =&gt; println!("Not authenticated"),
}</code></pre>
<h3 id="has_role"><a class="header" href="#has_role">has_role</a></h3>
<p>Checks if the current user has a specific role.</p>
<pre><code class="language-rust">pub fn has_role(role: &amp;str) -&gt; bool</code></pre>
<p><strong>Example:</strong></p>
<pre><code class="language-rust">if SecurityContext::has_role("ADMIN") {
    // Show admin controls
}</code></pre>
<h3 id="has_authority"><a class="header" href="#has_authority">has_authority</a></h3>
<p>Checks if the current user has a specific authority.</p>
<pre><code class="language-rust">pub fn has_authority(authority: &amp;str) -&gt; bool</code></pre>
<p><strong>Example:</strong></p>
<pre><code class="language-rust">if SecurityContext::has_authority("posts:delete") {
    // Show delete button
}</code></pre>
<h3 id="is_authenticated"><a class="header" href="#is_authenticated">is_authenticated</a></h3>
<p>Checks if there is an authenticated user.</p>
<pre><code class="language-rust">pub fn is_authenticated() -&gt; bool</code></pre>
<p><strong>Example:</strong></p>
<pre><code class="language-rust">if SecurityContext::is_authenticated() {
    // User is logged in
}</code></pre>
<h3 id="run_with"><a class="header" href="#run_with">run_with</a></h3>
<p>Executes code with a specific user context.</p>
<pre><code class="language-rust">pub async fn run_with&lt;F, R&gt;(user: Option&lt;User&gt;, f: F) -&gt; R
where
    F: Future&lt;Output = R&gt;,</code></pre>
<p><strong>Example:</strong></p>
<pre><code class="language-rust">let user = User::new("test".to_string(), "".to_string())
    .roles(&amp;["USER".into()]);

let result = SecurityContext::run_with(Some(user), async {
    // Code here has access to the user via SecurityContext
    SecurityContext::get_user()
}).await;</code></pre>
<h2 id="use-cases"><a class="header" href="#use-cases">Use Cases</a></h2>
<h3 id="service-layer-authorization"><a class="header" href="#service-layer-authorization">Service Layer Authorization</a></h3>
<pre><code class="language-rust">pub struct PostService;

impl PostService {
    pub async fn delete_post(&amp;self, post_id: i64) -&gt; Result&lt;(), ServiceError&gt; {
        // Check authorization in service layer
        let user = SecurityContext::get_user()
            .ok_or(ServiceError::Unauthorized)?;

        if !user.has_role("ADMIN") &amp;&amp; !user.has_authority("posts:delete") {
            return Err(ServiceError::Forbidden);
        }

        // Proceed with deletion
        self.repository.delete(post_id).await
    }
}</code></pre>
<h3 id="audit-logging"><a class="header" href="#audit-logging">Audit Logging</a></h3>
<pre><code class="language-rust">pub fn log_action(action: &amp;str, resource: &amp;str) {
    let username = SecurityContext::get_user()
        .map(|u| u.username.clone())
        .unwrap_or_else(|| "anonymous".to_string());

    log::info!("AUDIT: {} performed {} on {}", username, action, resource);
}

// In handler
#[post("/posts")]
async fn create_post() -&gt; impl Responder {
    log_action("CREATE", "post");
    // ...
}</code></pre>
<h3 id="dynamic-query-filtering"><a class="header" href="#dynamic-query-filtering">Dynamic Query Filtering</a></h3>
<pre><code class="language-rust">pub async fn get_visible_posts(&amp;self) -&gt; Vec&lt;Post&gt; {
    let user = SecurityContext::get_user();

    match user {
        Some(u) if u.has_role("ADMIN") =&gt; {
            // Admins see all posts
            self.repository.find_all().await
        }
        Some(u) =&gt; {
            // Users see their own posts + published posts
            self.repository.find_visible_for(&amp;u.username).await
        }
        None =&gt; {
            // Anonymous users see only published posts
            self.repository.find_published().await
        }
    }
}</code></pre>
<h3 id="conditional-ui-elements-in-templates"><a class="header" href="#conditional-ui-elements-in-templates">Conditional UI Elements (in templates)</a></h3>
<pre><code class="language-rust">pub struct TemplateContext {
    pub can_edit: bool,
    pub can_delete: bool,
    pub is_admin: bool,
}

impl TemplateContext {
    pub fn from_security_context() -&gt; Self {
        Self {
            can_edit: SecurityContext::has_authority("posts:write"),
            can_delete: SecurityContext::has_authority("posts:delete"),
            is_admin: SecurityContext::has_role("ADMIN"),
        }
    }
}</code></pre>
<h2 id="how-it-works-6"><a class="header" href="#how-it-works-6">How It Works</a></h2>
<p>The security middleware sets up the context before handling each request:</p>
<pre><code class="language-rust">// Simplified middleware flow
async fn call(&amp;self, req: ServiceRequest) -&gt; Result&lt;ServiceResponse, Error&gt; {
    // 1. Authenticate user
    let user = self.authenticator.authenticate(&amp;req);

    // 2. Run handler with security context
    SecurityContext::run_with(user, async {
        // 3. Your handler runs here with access to SecurityContext
        self.service.call(req).await
    }).await
}</code></pre>
<h2 id="thread-safety-1"><a class="header" href="#thread-safety-1">Thread Safety</a></h2>
<p><code>SecurityContext</code> uses Tokio's <code>task_local!</code> macro, which provides:</p>
<ul>
<li><strong>Task isolation</strong> - Each async task has its own context</li>
<li><strong>Thread safety</strong> - Safe to use across <code>.await</code> points</li>
<li><strong>No data races</strong> - Proper synchronization</li>
</ul>
<pre><code class="language-rust">// Safe to use across await points
async fn my_handler() {
    let user = SecurityContext::get_user();  // Before await

    some_async_operation().await;

    let same_user = SecurityContext::get_user();  // After await
    // Both return the same user
}</code></pre>
<h2 id="testing-with-security-context"><a class="header" href="#testing-with-security-context">Testing with Security Context</a></h2>
<pre><code class="language-rust">#[tokio::test]
async fn test_with_security_context() {
    let admin = User::new("admin".to_string(), "".to_string())
        .roles(&amp;["ADMIN".into()]);

    SecurityContext::run_with(Some(admin), async {
        assert!(SecurityContext::is_authenticated());
        assert!(SecurityContext::has_role("ADMIN"));
        assert_eq!(SecurityContext::get_user().unwrap().username, "admin");
    }).await;
}

#[tokio::test]
async fn test_without_user() {
    SecurityContext::run_with(None, async {
        assert!(!SecurityContext::is_authenticated());
        assert!(!SecurityContext::has_role("ADMIN"));
        assert!(SecurityContext::get_user().is_none());
    }).await;
}</code></pre>
<h2 id="spring-security-comparison-19"><a class="header" href="#spring-security-comparison-19">Spring Security Comparison</a></h2>
<p><strong>Spring Security:</strong></p>
<pre><code class="language-java">// Get current user
Authentication auth = SecurityContextHolder.getContext().getAuthentication();
String username = auth.getName();

// Check role
if (auth.getAuthorities().stream()
        .anyMatch(a -&gt; a.getAuthority().equals("ROLE_ADMIN"))) {
    // Admin logic
}

// Run with different context
SecurityContext context = SecurityContextHolder.createEmptyContext();
context.setAuthentication(newAuth);
SecurityContextHolder.setContext(context);
try {
    // Code runs with new context
} finally {
    SecurityContextHolder.clearContext();
}
</code></pre>
<p><strong>Actix Security:</strong></p>
<pre><code class="language-rust">// Get current user
let user = SecurityContext::get_user();
let username = user.map(|u| u.username.clone());

// Check role
if SecurityContext::has_role("ADMIN") {
    // Admin logic
}

// Run with different context
SecurityContext::run_with(Some(new_user), async {
    // Code runs with new context
}).await;</code></pre>
<h2 id="limitations-1"><a class="header" href="#limitations-1">Limitations</a></h2>
<ol>
<li><strong>Request scope only</strong> - Context is only available during request handling</li>
<li><strong>No cross-task sharing</strong> - Each spawned task needs its own context</li>
<li><strong>Async only</strong> - Uses Tokio's task-local storage</li>
</ol>
<p>For spawned tasks, pass the user explicitly:</p>
<pre><code class="language-rust">#[post("/process")]
async fn process(user: AuthenticatedUser) -&gt; impl Responder {
    let user_clone = user.clone();

    tokio::spawn(async move {
        // SecurityContext not available here
        // Use user_clone directly
        process_in_background(user_clone).await;
    });

    HttpResponse::Accepted().body("Processing")
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="csrf-protection"><a class="header" href="#csrf-protection">CSRF Protection</a></h1>
<p>Cross-Site Request Forgery (CSRF) protection prevents attackers from tricking users into performing unwanted actions.</p>
<h2 id="enabling-csrf-protection"><a class="header" href="#enabling-csrf-protection">Enabling CSRF Protection</a></h2>
<p>Add the <code>csrf</code> feature to your <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[dependencies]
actix-security = { version = "0.2", features = ["csrf"] }
</code></pre>
<h2 id="basic-usage-4"><a class="header" href="#basic-usage-4">Basic Usage</a></h2>
<pre><code class="language-rust">use actix_security::http::security::{CsrfProtection, CsrfConfig};
use actix_session::{SessionMiddleware, storage::CookieSessionStore};
use actix_web::{App, HttpServer, cookie::Key};

#[actix_web::main]
async fn main() -&gt; std::io::Result&lt;()&gt; {
    let secret_key = Key::generate();

    let csrf = CsrfProtection::new(CsrfConfig::default());

    HttpServer::new(move || {
        App::new()
            // Session middleware is required for CSRF
            .wrap(SessionMiddleware::new(
                CookieSessionStore::default(),
                secret_key.clone(),
            ))
            .wrap(csrf.clone())
            // ... routes
    })
    .bind("127.0.0.1:8080")?
    .run()
    .await
}</code></pre>
<h2 id="configuration-options-2"><a class="header" href="#configuration-options-2">Configuration Options</a></h2>
<pre><code class="language-rust">CsrfConfig::new()
    // Name of the form field containing the token
    .token_parameter("_csrf")

    // Name of the HTTP header containing the token
    .header_name("X-CSRF-TOKEN")

    // Session key for storing the token
    .session_key("csrf_token")

    // Paths to exclude from CSRF checks
    .ignore_path("/api/webhook")
    .ignore_paths(vec!["/api/public/*"])

    // Methods that don't require CSRF (safe methods)
    // Default: GET, HEAD, OPTIONS, TRACE
    .ignore_method(Method::GET)</code></pre>
<h2 id="token-in-forms"><a class="header" href="#token-in-forms">Token in Forms</a></h2>
<p>Include the CSRF token in your HTML forms:</p>
<pre><code class="language-html">&lt;form method="POST" action="/submit"&gt;
    &lt;input type="hidden" name="_csrf" value="{{ csrf_token }}"&gt;
    &lt;!-- other form fields --&gt;
    &lt;button type="submit"&gt;Submit&lt;/button&gt;
&lt;/form&gt;
</code></pre>
<p>To get the CSRF token in your handler:</p>
<pre><code class="language-rust">use actix_security::http::security::CsrfToken;
use actix_session::Session;

async fn show_form(session: Session) -&gt; impl Responder {
    // Generate or retrieve CSRF token
    let token = CsrfToken::generate();
    session.insert("csrf_token", &amp;token.token).ok();

    let html = format!(r#"
        &lt;form method="POST" action="/submit"&gt;
            &lt;input type="hidden" name="_csrf" value="{}"&gt;
            &lt;button type="submit"&gt;Submit&lt;/button&gt;
        &lt;/form&gt;
    "#, token.token);

    HttpResponse::Ok().content_type("text/html").body(html)
}</code></pre>
<h2 id="token-in-ajax-requests"><a class="header" href="#token-in-ajax-requests">Token in AJAX Requests</a></h2>
<p>For JavaScript/AJAX requests, include the token in a header:</p>
<pre><code class="language-javascript">// Get token from meta tag or cookie
const csrfToken = document.querySelector('meta[name="csrf-token"]').content;

fetch('/api/action', {
    method: 'POST',
    headers: {
        'Content-Type': 'application/json',
        'X-CSRF-TOKEN': csrfToken
    },
    body: JSON.stringify(data)
});
</code></pre>
<h2 id="token-repository"><a class="header" href="#token-repository">Token Repository</a></h2>
<p>By default, tokens are stored in the session. You can customize this:</p>
<pre><code class="language-rust">use actix_security::http::security::{CsrfTokenRepository, SessionCsrfTokenRepository};

// Session-based (default)
CsrfConfig::new()
    .token_repository(SessionCsrfTokenRepository::new())</code></pre>
<h2 id="error-handling-1"><a class="header" href="#error-handling-1">Error Handling</a></h2>
<p>When CSRF validation fails, a 403 Forbidden response is returned by default.</p>
<pre><code class="language-rust">use actix_security::http::security::CsrfError;

// CsrfError variants:
CsrfError::MissingToken    // No token in request
CsrfError::InvalidToken    // Token doesn't match
CsrfError::SessionError    // Session storage issue</code></pre>
<h2 id="when-to-use-csrf-protection"><a class="header" href="#when-to-use-csrf-protection">When to Use CSRF Protection</a></h2>
<ul>
<li><strong>Enable for</strong>: Form submissions, state-changing operations</li>
<li><strong>Disable for</strong>: APIs using token-based auth (JWT), webhooks, public endpoints</li>
</ul>
<h2 id="spring-security-comparison-20"><a class="header" href="#spring-security-comparison-20">Spring Security Comparison</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Spring Security</th><th>Actix Security</th></tr></thead><tbody>
<tr><td><code>CsrfFilter</code></td><td><code>CsrfProtection</code> middleware</td></tr>
<tr><td><code>CsrfToken</code></td><td><code>CsrfToken</code></td></tr>
<tr><td><code>CsrfTokenRepository</code></td><td><code>CsrfTokenRepository</code> trait</td></tr>
<tr><td><code>HttpSessionCsrfTokenRepository</code></td><td><code>SessionCsrfTokenRepository</code></td></tr>
<tr><td><code>.csrf().disable()</code></td><td><code>.ignore_path()</code></td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="rate-limiting"><a class="header" href="#rate-limiting">Rate Limiting</a></h1>
<p>Rate limiting protects your application from brute-force attacks, denial-of-service (DoS) attempts, and excessive API usage.</p>
<h2 id="enabling-rate-limiting"><a class="header" href="#enabling-rate-limiting">Enabling Rate Limiting</a></h2>
<p>Add the <code>rate-limit</code> feature to your <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[dependencies]
actix-security = { version = "0.2", features = ["rate-limit"] }
</code></pre>
<h2 id="basic-usage-5"><a class="header" href="#basic-usage-5">Basic Usage</a></h2>
<pre><code class="language-rust">use actix_security::http::security::{RateLimiter, RateLimitConfig};
use actix_web::{App, HttpServer};

#[actix_web::main]
async fn main() -&gt; std::io::Result&lt;()&gt; {
    let rate_limiter = RateLimiter::new(
        RateLimitConfig::new()
            .requests_per_minute(60)
    );

    HttpServer::new(move || {
        App::new()
            .wrap(rate_limiter.clone())
            // ... routes
    })
    .bind("127.0.0.1:8080")?
    .run()
    .await
}</code></pre>
<h2 id="configuration-options-3"><a class="header" href="#configuration-options-3">Configuration Options</a></h2>
<pre><code class="language-rust">RateLimitConfig::new()
    // Maximum requests per window
    .max_requests(100)

    // Time window
    .window(Duration::from_secs(60))

    // Shorthand for requests_per_minute
    .requests_per_minute(60)

    // Burst capacity (for token bucket)
    .burst_size(10)

    // Algorithm selection
    .algorithm(RateLimitAlgorithm::SlidingWindow)

    // Add rate limit headers to response
    .add_headers(true)

    // Exclude certain paths
    .exclude_paths(vec!["/health", "/metrics"])</code></pre>
<h2 id="algorithms-1"><a class="header" href="#algorithms-1">Algorithms</a></h2>
<h3 id="fixed-window"><a class="header" href="#fixed-window">Fixed Window</a></h3>
<p>Counts requests in fixed time intervals. Simple but can allow bursts at window boundaries.</p>
<pre><code class="language-rust">.algorithm(RateLimitAlgorithm::FixedWindow)</code></pre>
<h3 id="sliding-window"><a class="header" href="#sliding-window">Sliding Window</a></h3>
<p>Smooths out the window boundary issue by considering a weighted average.</p>
<pre><code class="language-rust">.algorithm(RateLimitAlgorithm::SlidingWindow)</code></pre>
<h3 id="token-bucket"><a class="header" href="#token-bucket">Token Bucket</a></h3>
<p>Allows controlled bursting while maintaining overall rate limits.</p>
<pre><code class="language-rust">.algorithm(RateLimitAlgorithm::TokenBucket)
.burst_size(10)  // Allow burst of 10 requests</code></pre>
<h2 id="key-extraction"><a class="header" href="#key-extraction">Key Extraction</a></h2>
<p>Rate limiting can be applied per IP address, per user, or with custom logic:</p>
<pre><code class="language-rust">use actix_security::http::security::KeyExtractor;

RateLimitConfig::new()
    .key_extractor(KeyExtractor::IpAddress)      // Per IP (default)
    .key_extractor(KeyExtractor::User)           // Per authenticated user
    .key_extractor(KeyExtractor::IpAndEndpoint)  // Per IP + endpoint
    .key_extractor(KeyExtractor::Header("X-API-Key".to_string()))  // Per API key</code></pre>
<h2 id="response-headers"><a class="header" href="#response-headers">Response Headers</a></h2>
<p>When <code>add_headers</code> is enabled, the following headers are added:</p>
<ul>
<li><code>X-RateLimit-Limit</code>: Maximum requests allowed</li>
<li><code>X-RateLimit-Remaining</code>: Requests remaining in current window</li>
<li><code>X-RateLimit-Reset</code>: Unix timestamp when the window resets</li>
</ul>
<h2 id="preset-configurations"><a class="header" href="#preset-configurations">Preset Configurations</a></h2>
<pre><code class="language-rust">// Strict for login endpoints (5/minute)
RateLimitConfig::strict_login()

// Lenient for API (1000/minute)
RateLimitConfig::lenient_api()</code></pre>
<h2 id="spring-security-comparison-21"><a class="header" href="#spring-security-comparison-21">Spring Security Comparison</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Spring Security</th><th>Actix Security</th></tr></thead><tbody>
<tr><td>Custom filter or Bucket4j</td><td><code>RateLimiter</code> middleware</td></tr>
<tr><td><code>@RateLimiter</code> annotation</td><td>Configuration-based</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="account-locking"><a class="header" href="#account-locking">Account Locking</a></h1>
<p>Account locking automatically locks user accounts after multiple failed login attempts, protecting against brute-force attacks.</p>
<h2 id="enabling-account-locking"><a class="header" href="#enabling-account-locking">Enabling Account Locking</a></h2>
<p>Add the <code>account-lock</code> feature to your <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[dependencies]
actix-security = { version = "0.2", features = ["account-lock"] }
</code></pre>
<h2 id="basic-usage-6"><a class="header" href="#basic-usage-6">Basic Usage</a></h2>
<pre><code class="language-rust">use actix_security::http::security::{
    AccountLockManager, LockConfig, check_login
};
use std::time::Duration;

// Create lock manager
let lock_manager = AccountLockManager::new(
    LockConfig::new()
        .max_attempts(5)
        .lockout_duration(Duration::from_secs(15 * 60))
);

// In your login handler:
async fn login(
    form: web::Form&lt;LoginForm&gt;,
    lock_manager: web::Data&lt;AccountLockManager&gt;,
) -&gt; impl Responder {
    let username = &amp;form.username;

    // Check if account is locked
    let result = check_login(&amp;lock_manager, username).await;
    if !result.is_allowed() {
        return HttpResponse::Forbidden().body("Account locked");
    }

    // Attempt authentication
    if authenticate(username, &amp;form.password) {
        lock_manager.record_success(username).await;
        HttpResponse::Ok().body("Logged in")
    } else {
        lock_manager.record_failure(username).await;
        let remaining = lock_manager.get_remaining_attempts(username).await;
        HttpResponse::Unauthorized()
            .body(format!("{} attempts remaining", remaining))
    }
}</code></pre>
<h2 id="configuration-options-4"><a class="header" href="#configuration-options-4">Configuration Options</a></h2>
<pre><code class="language-rust">LockConfig::new()
    // Maximum failed attempts before lock
    .max_attempts(5)

    // How long to lock the account
    .lockout_duration(Duration::from_secs(15 * 60))

    // Reset counter on successful login
    .reset_on_success(true)

    // Progressive lockout (doubles duration each time)
    .progressive_lockout(true)</code></pre>
<h2 id="preset-configurations-1"><a class="header" href="#preset-configurations-1">Preset Configurations</a></h2>
<pre><code class="language-rust">// Strict: 3 attempts, 30 minute lockout
LockConfig::strict()

// Lenient: 10 attempts, 5 minute lockout
LockConfig::lenient()</code></pre>
<h2 id="lock-status"><a class="header" href="#lock-status">Lock Status</a></h2>
<pre><code class="language-rust">use actix_security::http::security::LockStatus;

let status = lock_manager.get_lock_status(&amp;username).await;

match status {
    LockStatus::Unlocked =&gt; { /* Account is accessible */ }
    LockStatus::TemporarilyLocked { until, reason } =&gt; {
        // Locked until specified time
    }
    LockStatus::PermanentlyLocked { reason } =&gt; {
        // Requires admin intervention
    }
}</code></pre>
<h2 id="ip-address-tracking"><a class="header" href="#ip-address-tracking">IP Address Tracking</a></h2>
<p>Track which IP addresses have attempted to access an account:</p>
<pre><code class="language-rust">// Record failure with IP
lock_manager
    .record_failure_with_ip(&amp;username, Some(&amp;ip_address))
    .await;

// Get account statistics
let stats = lock_manager.get_account_stats(&amp;username).await;
println!("Failed attempts: {}", stats.failed_attempts);
println!("Associated IPs: {:?}", stats.associated_ips);</code></pre>
<h2 id="manual-lockunlock"><a class="header" href="#manual-lockunlock">Manual Lock/Unlock</a></h2>
<pre><code class="language-rust">// Manually unlock an account
lock_manager.unlock(&amp;username).await;

// Permanently lock an account
lock_manager
    .lock_permanently(&amp;username, "Suspicious activity detected")
    .await;</code></pre>
<h2 id="check-result"><a class="header" href="#check-result">Check Result</a></h2>
<p>The <code>check_login</code> function returns detailed information:</p>
<pre><code class="language-rust">let result = check_login(&amp;lock_manager, &amp;username).await;

match result {
    LoginCheckResult::Allowed { remaining_attempts } =&gt; {
        println!("{} attempts remaining", remaining_attempts);
    }
    LoginCheckResult::Blocked { message, unlock_time } =&gt; {
        println!("Blocked: {}", message);
        if let Some(time) = unlock_time {
            println!("Unlocks at: {:?}", time);
        }
    }
}</code></pre>
<h2 id="spring-security-comparison-22"><a class="header" href="#spring-security-comparison-22">Spring Security Comparison</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Spring Security</th><th>Actix Security</th></tr></thead><tbody>
<tr><td><code>LockedException</code></td><td><code>LockStatus::TemporarilyLocked</code></td></tr>
<tr><td><code>AccountStatusUserDetailsChecker</code></td><td><code>check_login()</code></td></tr>
<tr><td><code>JdbcUserDetailsManager.lockUser()</code></td><td><code>lock_permanently()</code></td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="audit-logging-1"><a class="header" href="#audit-logging-1">Audit Logging</a></h1>
<p>Audit logging captures security-relevant events for compliance, debugging, and threat detection.</p>
<h2 id="enabling-audit-logging"><a class="header" href="#enabling-audit-logging">Enabling Audit Logging</a></h2>
<p>Add the <code>audit</code> feature to your <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[dependencies]
actix-security = { version = "0.2", features = ["audit"] }
</code></pre>
<h2 id="basic-usage-7"><a class="header" href="#basic-usage-7">Basic Usage</a></h2>
<pre><code class="language-rust">use actix_security::http::security::{
    AuditLogger, SecurityEvent, SecurityEventType, StdoutHandler
};

// Create audit logger with stdout handler
let logger = AuditLogger::new()
    .add_handler(StdoutHandler::new());

// Log events
logger.log_login_success("admin", "192.168.1.1");
logger.log_login_failure("admin", "192.168.1.1", "Invalid password");</code></pre>
<h2 id="event-types"><a class="header" href="#event-types">Event Types</a></h2>
<pre><code class="language-rust">use actix_security::http::security::SecurityEventType;

// Authentication events
SecurityEventType::AuthenticationSuccess
SecurityEventType::AuthenticationFailure
SecurityEventType::Logout

// Session events
SecurityEventType::SessionCreated

// Authorization events
SecurityEventType::AccessGranted
SecurityEventType::AccessDenied

// Security events
SecurityEventType::AccountLocked
SecurityEventType::RateLimitExceeded
SecurityEventType::BruteForceDetected

// Custom events
SecurityEventType::Custom("password_changed".to_string())</code></pre>
<h2 id="event-severity"><a class="header" href="#event-severity">Event Severity</a></h2>
<pre><code class="language-rust">use actix_security::http::security::SecurityEventSeverity;

SecurityEventSeverity::Info      // Normal operations
SecurityEventSeverity::Warning   // Potential issues
SecurityEventSeverity::Error     // Failed operations
SecurityEventSeverity::Critical  // Security incidents</code></pre>
<h2 id="creating-events"><a class="header" href="#creating-events">Creating Events</a></h2>
<pre><code class="language-rust">use actix_security::http::security::SecurityEvent;

let event = SecurityEvent::new(SecurityEventType::AuthenticationFailure)
    .username("admin")
    .ip_address("192.168.1.1")
    .resource("/admin/dashboard")
    .error("Invalid credentials")
    .severity(SecurityEventSeverity::Warning)
    .add_detail("attempt_number", "3");

logger.log(event);</code></pre>
<h2 id="convenience-methods"><a class="header" href="#convenience-methods">Convenience Methods</a></h2>
<pre><code class="language-rust">// Login success
logger.log_login_success(&amp;username, &amp;ip);

// Login failure
logger.log_login_failure(&amp;username, &amp;ip, "Invalid password");

// Access denied
logger.log(
    SecurityEvent::new(SecurityEventType::AccessDenied)
        .username(&amp;username)
        .resource("/admin")
        .ip_address(&amp;ip)
);</code></pre>
<h2 id="event-handlers"><a class="header" href="#event-handlers">Event Handlers</a></h2>
<h3 id="tracinghandler-recommended"><a class="header" href="#tracinghandler-recommended">TracingHandler (Recommended)</a></h3>
<p>Emits events through the <code>tracing</code> crate, integrating with the Rust ecosystem's standard observability infrastructure:</p>
<pre><code class="language-rust">use actix_security::http::security::{AuditLogger, TracingHandler};
use tracing_subscriber;

// Initialize tracing subscriber (console output)
tracing_subscriber::fmt::init();

// Create audit logger with tracing handler
let logger = AuditLogger::new()
    .add_handler(TracingHandler::new());

// Events are emitted to target "actix_security::audit"
logger.log_login_success("admin", "192.168.1.1");
// Output: INFO actix_security::audit: Security event event_type="AUTHENTICATION_SUCCESS" user="admin" ip="192.168.1.1"</code></pre>
<p>This handler automatically maps event severity to tracing levels:</p>
<ul>
<li><code>Info</code> ‚Üí <code>tracing::info!</code></li>
<li><code>Warning</code> ‚Üí <code>tracing::warn!</code></li>
<li><code>Error</code>/<code>Critical</code> ‚Üí <code>tracing::error!</code></li>
</ul>
<h3 id="stdouthandler"><a class="header" href="#stdouthandler">StdoutHandler</a></h3>
<p>Prints events to standard output (simpler, no tracing dependency):</p>
<pre><code class="language-rust">let handler = StdoutHandler::new();</code></pre>
<h3 id="inmemoryeventstore"><a class="header" href="#inmemoryeventstore">InMemoryEventStore</a></h3>
<p>Stores events in memory (useful for testing):</p>
<pre><code class="language-rust">use actix_security::http::security::InMemoryEventStore;

let store = InMemoryEventStore::new();
let logger = AuditLogger::new().add_handler(store.clone());

// Later, retrieve events
let events = store.get_events();</code></pre>
<h3 id="custom-handler"><a class="header" href="#custom-handler">Custom Handler</a></h3>
<p>Implement the <code>SecurityEventHandler</code> trait:</p>
<pre><code class="language-rust">use actix_security::http::security::{SecurityEventHandler, SecurityEvent};

struct DatabaseHandler {
    // database connection
}

impl SecurityEventHandler for DatabaseHandler {
    fn handle(&amp;self, event: &amp;SecurityEvent) {
        // Store in database
    }
}

let logger = AuditLogger::new()
    .add_handler(DatabaseHandler::new());</code></pre>
<h2 id="global-logger"><a class="header" href="#global-logger">Global Logger</a></h2>
<p>Set up a global logger accessible from anywhere:</p>
<pre><code class="language-rust">use actix_security::http::security::{init_global_logger, audit_log, global_logger};

// Initialize once at startup
init_global_logger(AuditLogger::new().add_handler(StdoutHandler::new()));

// Use anywhere
audit_log(SecurityEvent::new(SecurityEventType::AccessGranted)
    .username("admin")
    .resource("/api/users"));

// Or get the logger instance
if let Some(logger) = global_logger() {
    logger.log_login_success("admin", "127.0.0.1");
}</code></pre>
<h2 id="json-output"><a class="header" href="#json-output">JSON Output</a></h2>
<p>Events can be serialized to JSON when serde is available (via <code>jwt</code>, <code>session</code>, or <code>oauth2</code> features):</p>
<pre><code class="language-json">{
  "event_type": "AuthenticationFailure",
  "severity": "Warning",
  "timestamp": "2024-01-15T10:30:00Z",
  "username": "admin",
  "ip_address": "192.168.1.1",
  "error": "Invalid credentials",
  "details": {
    "attempt_number": "3"
  }
}
</code></pre>
<h2 id="automatic-tracing-in-middleware"><a class="header" href="#automatic-tracing-in-middleware">Automatic Tracing in Middleware</a></h2>
<p>When the <code>audit</code> feature is enabled, the security middleware automatically emits tracing events for:</p>
<h3 id="authentication-events"><a class="header" href="#authentication-events">Authentication Events</a></h3>
<ul>
<li><code>AUTHENTICATION_SUCCESS</code> - User authenticated successfully</li>
<li><code>AUTHENTICATION_ANONYMOUS</code> - Anonymous request (debug level)</li>
</ul>
<h3 id="authorization-events"><a class="header" href="#authorization-events">Authorization Events</a></h3>
<ul>
<li><code>ACCESS_GRANTED</code> - User has required permissions (debug level)</li>
<li><code>ACCESS_DENIED</code> - User lacks required permissions (warning level)</li>
<li><code>AUTHENTICATION_REQUIRED</code> - Redirecting to login or returning 401</li>
</ul>
<p>Example output with <code>tracing-subscriber</code>:</p>
<pre><code>INFO actix_security::audit: User authenticated successfully event_type="AUTHENTICATION_SUCCESS" user="admin" ip="192.168.1.1" path="/api/users" method="GET"
WARN actix_security::audit: Access denied: insufficient permissions event_type="ACCESS_DENIED" user="user1" path="/admin" required_roles=["ADMIN"]
</code></pre>
<h3 id="filtering-by-target"><a class="header" href="#filtering-by-target">Filtering by Target</a></h3>
<p>Use tracing's target filtering to control output:</p>
<pre><code class="language-rust">use tracing_subscriber::EnvFilter;

tracing_subscriber::fmt()
    .with_env_filter(
        EnvFilter::from_default_env()
            // Show all security audit events
            .add_directive("actix_security::audit=info".parse().unwrap())
    )
    .init();</code></pre>
<h2 id="spring-security-comparison-23"><a class="header" href="#spring-security-comparison-23">Spring Security Comparison</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Spring Security</th><th>Actix Security</th></tr></thead><tbody>
<tr><td><code>AuthenticationEventPublisher</code></td><td><code>AuditLogger</code></td></tr>
<tr><td><code>AbstractAuthenticationEvent</code></td><td><code>SecurityEvent</code></td></tr>
<tr><td><code>@EventListener</code></td><td><code>SecurityEventHandler</code> trait</td></tr>
<tr><td>Spring AOP logging</td><td><code>tracing</code> integration</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="remember-me-authentication"><a class="header" href="#remember-me-authentication">Remember-Me Authentication</a></h1>
<p>Remember-me authentication allows users to stay logged in across browser sessions using a persistent token stored in a cookie.</p>
<h2 id="enabling-remember-me"><a class="header" href="#enabling-remember-me">Enabling Remember-Me</a></h2>
<p>Add the <code>remember-me</code> feature to your <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[dependencies]
actix-security = { version = "0.2", features = ["remember-me"] }
</code></pre>
<p>Note: The <code>remember-me</code> feature automatically enables the <code>session</code> feature.</p>
<h2 id="basic-usage-8"><a class="header" href="#basic-usage-8">Basic Usage</a></h2>
<pre><code class="language-rust">use actix_security::http::security::{RememberMeServices, RememberMeConfig};
use actix_session::{SessionMiddleware, storage::CookieSessionStore};
use actix_web::{App, HttpServer, cookie::Key};

#[actix_web::main]
async fn main() -&gt; std::io::Result&lt;()&gt; {
    let secret_key = Key::generate();

    let remember_me = RememberMeServices::new(
        RememberMeConfig::new()
            .key("my-secret-key")
            .validity_seconds(60 * 60 * 24 * 14)  // 14 days
            .cookie_name("remember-me")
    );

    HttpServer::new(move || {
        App::new()
            .wrap(SessionMiddleware::new(
                CookieSessionStore::default(),
                secret_key.clone(),
            ))
            // Configure with SecurityTransform
            // ...
    })
    .bind("127.0.0.1:8080")?
    .run()
    .await
}</code></pre>
<h2 id="configuration-options-5"><a class="header" href="#configuration-options-5">Configuration Options</a></h2>
<pre><code class="language-rust">RememberMeConfig::new()
    // Secret key for token generation
    .key("your-secret-key-here")

    // Token validity period (default: 14 days)
    .validity_seconds(60 * 60 * 24 * 14)

    // Cookie name (default: "remember-me")
    .cookie_name("remember-me")

    // Cookie path (default: "/")
    .cookie_path("/")

    // Secure cookie (HTTPS only)
    .secure(true)

    // HttpOnly cookie (not accessible via JavaScript)
    .http_only(true)

    // SameSite policy
    .same_site(SameSite::Lax)</code></pre>
<h2 id="login-with-remember-me"><a class="header" href="#login-with-remember-me">Login with Remember-Me</a></h2>
<p>When processing login, check if the user wants to be remembered:</p>
<pre><code class="language-rust">use actix_security::http::security::RememberMeServices;
use actix_web::{web, HttpResponse, HttpRequest};

async fn login(
    form: web::Form&lt;LoginForm&gt;,
    remember_me: web::Data&lt;RememberMeServices&gt;,
    req: HttpRequest,
) -&gt; HttpResponse {
    // Authenticate user
    if let Some(user) = authenticate(&amp;form.username, &amp;form.password) {
        // Create session
        create_session(&amp;user);

        // If remember-me checkbox was checked
        if form.remember_me {
            // Generate and set remember-me cookie
            let cookie = remember_me.create_token(&amp;user);

            HttpResponse::Found()
                .cookie(cookie)
                .insert_header(("Location", "/dashboard"))
                .finish()
        } else {
            HttpResponse::Found()
                .insert_header(("Location", "/dashboard"))
                .finish()
        }
    } else {
        HttpResponse::Unauthorized().body("Invalid credentials")
    }
}

#[derive(serde::Deserialize)]
struct LoginForm {
    username: String,
    password: String,
    #[serde(default)]
    remember_me: bool,
}</code></pre>
<h2 id="auto-login-from-remember-me-token"><a class="header" href="#auto-login-from-remember-me-token">Auto-Login from Remember-Me Token</a></h2>
<p>Check for remember-me token on requests:</p>
<pre><code class="language-rust">use actix_security::http::security::RememberMeServices;

async fn check_remember_me(
    remember_me: web::Data&lt;RememberMeServices&gt;,
    session: Session,
    req: HttpRequest,
) -&gt; Option&lt;User&gt; {
    // Check if already logged in
    if let Some(user) = session.get::&lt;User&gt;("user").ok().flatten() {
        return Some(user);
    }

    // Try to authenticate from remember-me cookie
    if let Some(user) = remember_me.auto_login(&amp;req) {
        // Create new session
        session.insert("user", &amp;user).ok();
        return Some(user);
    }

    None
}</code></pre>
<h2 id="logout-with-remember-me"><a class="header" href="#logout-with-remember-me">Logout with Remember-Me</a></h2>
<p>Clear the remember-me cookie on logout:</p>
<pre><code class="language-rust">async fn logout(
    remember_me: web::Data&lt;RememberMeServices&gt;,
    session: Session,
) -&gt; HttpResponse {
    // Clear session
    session.purge();

    // Clear remember-me cookie
    let removal_cookie = remember_me.logout_cookie();

    HttpResponse::Found()
        .cookie(removal_cookie)
        .insert_header(("Location", "/login"))
        .finish()
}</code></pre>
<h2 id="token-format"><a class="header" href="#token-format">Token Format</a></h2>
<p>The remember-me token contains:</p>
<pre><code>base64(username:expiration:signature)
</code></pre>
<p>Where:</p>
<ul>
<li><code>username</code>: The user's identifier</li>
<li><code>expiration</code>: Unix timestamp when token expires</li>
<li><code>signature</code>: HMAC-SHA256 of username + expiration + secret key</li>
</ul>
<h2 id="html-form-example"><a class="header" href="#html-form-example">HTML Form Example</a></h2>
<pre><code class="language-html">&lt;form method="POST" action="/login"&gt;
    &lt;input type="text" name="username" placeholder="Username"&gt;
    &lt;input type="password" name="password" placeholder="Password"&gt;

    &lt;label&gt;
        &lt;input type="checkbox" name="remember_me" value="true"&gt;
        Remember me for 14 days
    &lt;/label&gt;

    &lt;button type="submit"&gt;Login&lt;/button&gt;
&lt;/form&gt;
</code></pre>
<h2 id="token-repository-1"><a class="header" href="#token-repository-1">Token Repository</a></h2>
<p>For persistent token storage (more secure):</p>
<pre><code class="language-rust">use actix_security::http::security::{
    PersistentRememberMeServices,
    PersistentTokenRepository,
};

// Implement your own token repository
struct DatabaseTokenRepository { /* ... */ }

impl PersistentTokenRepository for DatabaseTokenRepository {
    fn create_token(&amp;self, username: &amp;str) -&gt; RememberMeToken;
    fn get_token(&amp;self, series: &amp;str) -&gt; Option&lt;RememberMeToken&gt;;
    fn update_token(&amp;self, series: &amp;str, token_value: &amp;str, last_used: DateTime);
    fn remove_user_tokens(&amp;self, username: &amp;str);
}

let remember_me = PersistentRememberMeServices::new(
    DatabaseTokenRepository::new(db_pool),
    "secret-key",
);</code></pre>
<h2 id="spring-security-comparison-24"><a class="header" href="#spring-security-comparison-24">Spring Security Comparison</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Spring Security</th><th>Actix Security</th></tr></thead><tbody>
<tr><td><code>RememberMeServices</code></td><td><code>RememberMeServices</code></td></tr>
<tr><td><code>RememberMeConfigurer</code></td><td><code>RememberMeConfig</code></td></tr>
<tr><td><code>TokenBasedRememberMeServices</code></td><td><code>RememberMeServices</code> (default)</td></tr>
<tr><td><code>PersistentTokenBasedRememberMeServices</code></td><td><code>PersistentRememberMeServices</code></td></tr>
<tr><td><code>PersistentTokenRepository</code></td><td><code>PersistentTokenRepository</code> trait</td></tr>
<tr><td><code>.rememberMe().key()</code></td><td><code>.key()</code></td></tr>
<tr><td><code>.tokenValiditySeconds()</code></td><td><code>.validity_seconds()</code></td></tr>
</tbody></table>
</div>
<h2 id="security-considerations-2"><a class="header" href="#security-considerations-2">Security Considerations</a></h2>
<ol>
<li><strong>Strong Secret Key</strong>: Use a cryptographically random key, at least 32 bytes</li>
<li><strong>Secure Cookies</strong>: Enable <code>secure(true)</code> in production (HTTPS only)</li>
<li><strong>HttpOnly</strong>: Always use <code>http_only(true)</code> to prevent XSS attacks</li>
<li><strong>Token Rotation</strong>: Consider using persistent tokens with rotation for better security</li>
<li><strong>Limited Scope</strong>: Remember-me should not grant access to sensitive operations</li>
<li><strong>Session Binding</strong>: Optionally bind remember-me tokens to additional factors (IP, user-agent)</li>
</ol>
<h2 id="best-practices-6"><a class="header" href="#best-practices-6">Best Practices</a></h2>
<ul>
<li>Don't use remember-me for sensitive operations (payments, password changes)</li>
<li>Provide users a way to invalidate all remember-me tokens (logout everywhere)</li>
<li>Monitor for suspicious remember-me usage patterns</li>
<li>Consider shorter validity periods for higher security requirements</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="channel-security"><a class="header" href="#channel-security">Channel Security</a></h1>
<p>Channel security ensures that certain URLs are only accessible over secure (HTTPS) connections, automatically redirecting HTTP requests to HTTPS when needed.</p>
<h2 id="basic-usage-9"><a class="header" href="#basic-usage-9">Basic Usage</a></h2>
<p>Channel security is always available (no feature flag needed):</p>
<pre><code class="language-rust">use actix_security::http::security::{ChannelSecurity, ChannelSecurityConfig};
use actix_web::{App, HttpServer};

#[actix_web::main]
async fn main() -&gt; std::io::Result&lt;()&gt; {
    let channel_security = ChannelSecurity::new(
        ChannelSecurityConfig::new()
            .require_secure("/login")
            .require_secure("/admin/**")
            .require_secure("/api/payments/**")
    );

    HttpServer::new(move || {
        App::new()
            .wrap(channel_security.clone())
            // ... routes
    })
    .bind("127.0.0.1:8080")?
    .run()
    .await
}</code></pre>
<h2 id="configuration-options-6"><a class="header" href="#configuration-options-6">Configuration Options</a></h2>
<pre><code class="language-rust">ChannelSecurityConfig::new()
    // Require HTTPS for specific paths (supports ant-style patterns)
    .require_secure("/login")
    .require_secure("/admin/**")
    .require_secure("/api/*/sensitive")

    // Require HTTP for specific paths (optional, for debugging)
    .require_insecure("/health")
    .require_insecure("/metrics")

    // Allow both HTTP and HTTPS
    .any_channel("/public/**")

    // Configure port mapping for redirects
    .port_mapper(PortMapper::new()
        .map(80, 443)
        .map(8080, 8443))

    // Redirect status code (default: 302)
    .redirect_status(StatusCode::MOVED_PERMANENTLY)  // 301</code></pre>
<h2 id="channel-requirements"><a class="header" href="#channel-requirements">Channel Requirements</a></h2>
<p>Three types of channel requirements:</p>
<pre><code class="language-rust">use actix_security::http::security::ChannelRequirement;

// Require HTTPS
ChannelRequirement::Secure

// Require HTTP (rarely used)
ChannelRequirement::Insecure

// Allow both
ChannelRequirement::Any</code></pre>
<h2 id="https-for-all-routes"><a class="header" href="#https-for-all-routes">HTTPS for All Routes</a></h2>
<p>To require HTTPS for the entire application:</p>
<pre><code class="language-rust">let channel_security = ChannelSecurity::new(
    ChannelSecurityConfig::new()
        .require_secure("/**")
        .except("/health")  // Except health checks
);</code></pre>
<h2 id="port-mapping"><a class="header" href="#port-mapping">Port Mapping</a></h2>
<p>Configure port mapping for proper redirects:</p>
<pre><code class="language-rust">use actix_security::http::security::PortMapper;

// Standard ports
let mapper = PortMapper::default();  // 80 -&gt; 443

// Custom ports (e.g., development)
let mapper = PortMapper::new()
    .map(8080, 8443)
    .map(3000, 3443);

ChannelSecurityConfig::new()
    .port_mapper(mapper)</code></pre>
<h2 id="behind-a-reverse-proxy"><a class="header" href="#behind-a-reverse-proxy">Behind a Reverse Proxy</a></h2>
<p>When behind a reverse proxy (nginx, load balancer), use the <code>X-Forwarded-Proto</code> header:</p>
<pre><code class="language-rust">ChannelSecurityConfig::new()
    .trust_proxy_headers(true)  // Trust X-Forwarded-Proto
    .require_secure("/api/**")</code></pre>
<p>This checks the <code>X-Forwarded-Proto</code> header instead of the actual connection protocol.</p>
<h2 id="redirect-behavior"><a class="header" href="#redirect-behavior">Redirect Behavior</a></h2>
<p>When an HTTP request is made to a secure-only path:</p>
<ol>
<li>The middleware intercepts the request</li>
<li>Constructs an HTTPS URL with the same path and query string</li>
<li>Returns a redirect response (302 by default)</li>
</ol>
<p>Example:</p>
<ul>
<li>Request: <code>http://example.com/login?next=/dashboard</code></li>
<li>Redirect: <code>https://example.com/login?next=/dashboard</code></li>
</ul>
<h2 id="conditional-channel-security"><a class="header" href="#conditional-channel-security">Conditional Channel Security</a></h2>
<p>Apply channel security based on environment:</p>
<pre><code class="language-rust">let config = if std::env::var("PRODUCTION").is_ok() {
    ChannelSecurityConfig::new()
        .require_secure("/**")
} else {
    // Development: no HTTPS requirement
    ChannelSecurityConfig::new()
        .any_channel("/**")
};</code></pre>
<h2 id="combining-with-security-headers"><a class="header" href="#combining-with-security-headers">Combining with Security Headers</a></h2>
<p>Often used together with HSTS:</p>
<pre><code class="language-rust">use actix_security::http::security::{ChannelSecurity, SecurityHeaders};

App::new()
    .wrap(channel_security)
    .wrap(SecurityHeaders::default())  // Includes HSTS</code></pre>
<h2 id="error-responses"><a class="header" href="#error-responses">Error Responses</a></h2>
<p>When redirect is not possible (e.g., POST request):</p>
<pre><code class="language-rust">ChannelSecurityConfig::new()
    .require_secure("/api/**")
    .on_insecure_request(|req| {
        // Return 403 instead of redirect for API calls
        HttpResponse::Forbidden()
            .body("HTTPS required for API access")
    })</code></pre>
<h2 id="spring-security-comparison-25"><a class="header" href="#spring-security-comparison-25">Spring Security Comparison</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Spring Security</th><th>Actix Security</th></tr></thead><tbody>
<tr><td><code>requiresChannel()</code></td><td><code>ChannelSecurityConfig</code></td></tr>
<tr><td><code>.requiresSecure()</code></td><td><code>.require_secure()</code></td></tr>
<tr><td><code>.requiresInsecure()</code></td><td><code>.require_insecure()</code></td></tr>
<tr><td><code>.anyRequest().requiresSecure()</code></td><td><code>.require_secure("/**")</code></td></tr>
<tr><td><code>PortMapper</code></td><td><code>PortMapper</code></td></tr>
<tr><td><code>ChannelDecisionManager</code></td><td><code>ChannelSecurity</code> middleware</td></tr>
</tbody></table>
</div>
<h2 id="example-e-commerce-security"><a class="header" href="#example-e-commerce-security">Example: E-Commerce Security</a></h2>
<pre><code class="language-rust">ChannelSecurityConfig::new()
    // All authentication must be secure
    .require_secure("/login")
    .require_secure("/register")
    .require_secure("/forgot-password")

    // All account pages must be secure
    .require_secure("/account/**")

    // All payment processing must be secure
    .require_secure("/checkout/**")
    .require_secure("/api/payments/**")

    // Admin area must be secure
    .require_secure("/admin/**")

    // Public pages can use either
    .any_channel("/products/**")
    .any_channel("/search")</code></pre>
<h2 id="best-practices-7"><a class="header" href="#best-practices-7">Best Practices</a></h2>
<ol>
<li><strong>Production</strong>: Require HTTPS for all routes (<code>/**</code>)</li>
<li><strong>Sensitive Data</strong>: Always require HTTPS for login, payments, personal data</li>
<li><strong>HSTS</strong>: Combine with HSTS header for additional security</li>
<li><strong>Monitoring</strong>: Exclude health check endpoints from HTTPS requirement</li>
<li><strong>API</strong>: Return 403 instead of redirect for API endpoints</li>
<li><strong>Development</strong>: Use self-signed certificates or disable in development only</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="websocket-security"><a class="header" href="#websocket-security">WebSocket Security</a></h1>
<p>Secure your WebSocket connections with authentication and origin validation.</p>
<h2 id="overview-7"><a class="header" href="#overview-7">Overview</a></h2>
<p>WebSocket security works by securing the HTTP upgrade request before the connection is established:</p>
<pre><code class="language-text">Client                    Server
  |                          |
  |--HTTP Upgrade Request---&gt;|
  |  (with auth token)       | 1. Validate origin (CSWSH prevention)
  |                          | 2. Authenticate user
  |                          | 3. Check roles/authorities
  |&lt;--101 Switching----------|
  |                          |
  |==WebSocket Connection====| User available in connection
  |                          |
</code></pre>
<h2 id="enable-feature"><a class="header" href="#enable-feature">Enable Feature</a></h2>
<pre><code class="language-toml">[dependencies]
actix-security = { version = "0.2", features = ["websocket", "jwt"] }
actix-ws = "0.3"
</code></pre>
<h2 id="cross-site-websocket-hijacking-cswsh-prevention"><a class="header" href="#cross-site-websocket-hijacking-cswsh-prevention">Cross-Site WebSocket Hijacking (CSWSH) Prevention</a></h2>
<p>CSWSH is an attack where a malicious website establishes a WebSocket connection using the victim's browser cookies:</p>
<pre><code class="language-javascript">// On evil.com - this includes victim's cookies automatically!
const ws = new WebSocket('wss://yourapp.com/ws');
</code></pre>
<p><strong>Solution</strong>: Validate the <code>Origin</code> header.</p>
<h3 id="originvalidator"><a class="header" href="#originvalidator">OriginValidator</a></h3>
<pre><code class="language-rust">use actix_security::http::security::websocket::OriginValidator;

// Simple configuration
let validator = OriginValidator::new(&amp;["https://myapp.com"]);

// Builder pattern with more options
let validator = OriginValidator::builder()
    .allow("https://myapp.com")
    .allow("https://admin.myapp.com")
    .allow_subdomain_pattern("*.myapp.com")  // Matches api.myapp.com, etc.
    .allow_localhost_in_dev(true)  // Only in debug builds
    .build();

// Use in handler
#[get("/ws")]
async fn ws_handler(req: HttpRequest) -&gt; Result&lt;HttpResponse, Error&gt; {
    validator.validate(&amp;req)?;  // Returns 403 if origin invalid
    // ... upgrade to WebSocket
}</code></pre>
<h2 id="websocket-security-configuration"><a class="header" href="#websocket-security-configuration">WebSocket Security Configuration</a></h2>
<p>For comprehensive security, use <code>WebSocketSecurityConfig</code>:</p>
<pre><code class="language-rust">use actix_security::http::security::websocket::WebSocketSecurityConfig;

let ws_config = WebSocketSecurityConfig::new()
    .allowed_origins(vec!["https://myapp.com".into()])
    .require_authentication(true)
    .required_roles(vec!["USER".into()])
    .required_authorities(vec!["ws:connect".into()]);

#[get("/ws")]
async fn ws_handler(
    req: HttpRequest,
    stream: web::Payload,
    config: web::Data&lt;WebSocketSecurityConfig&gt;,
) -&gt; Result&lt;HttpResponse, Error&gt; {
    // Validates origin, auth, roles, and authorities in one call
    let upgrade = config.validate_upgrade(&amp;req)?;

    // Get the authenticated user
    let user = upgrade.into_user().expect("User is present");

    // Upgrade to WebSocket
    let (response, session, msg_stream) = actix_ws::handle(&amp;req, stream)?;
    // ... spawn handler with user
    Ok(response)
}</code></pre>
<h2 id="jwt-authentication-for-websocket"><a class="header" href="#jwt-authentication-for-websocket">JWT Authentication for WebSocket</a></h2>
<p>Since browsers can't send custom headers with WebSocket, use JWT in the Authorization header:</p>
<pre><code class="language-rust">use actix_security::http::security::{
    JwtAuthenticator, JwtConfig,
    websocket::OriginValidator,
};

fn extract_user_from_jwt(
    req: &amp;HttpRequest,
    jwt_auth: &amp;JwtAuthenticator,
) -&gt; Result&lt;User, String&gt; {
    let auth_header = req
        .headers()
        .get("Authorization")
        .and_then(|h| h.to_str().ok());

    let token = match auth_header {
        Some(h) if h.starts_with("Bearer ") =&gt; &amp;h[7..],
        _ =&gt; return Err("Missing Authorization header".into()),
    };

    jwt_auth.validate_token(token)
        .map(|data| User::new(data.claims.sub, String::new())
            .roles(&amp;data.claims.roles)
            .authorities(&amp;data.claims.authorities))
        .map_err(|e| format!("Invalid token: {}", e))
}

#[get("/ws")]
async fn ws_handler(
    req: HttpRequest,
    stream: web::Payload,
    data: web::Data&lt;AppState&gt;,
) -&gt; Result&lt;HttpResponse, Error&gt; {
    // 1. Validate origin
    data.origin_validator.validate(&amp;req)?;

    // 2. Authenticate via JWT
    let user = extract_user_from_jwt(&amp;req, &amp;data.jwt_authenticator)
        .map_err(actix_web::error::ErrorUnauthorized)?;

    // 3. Check authority
    if !user.has_authority("ws:connect") {
        return Err(actix_web::error::ErrorForbidden("Missing ws:connect authority"));
    }

    // 4. Upgrade to WebSocket
    let (response, mut session, mut msg_stream) = actix_ws::handle(&amp;req, stream)?;

    actix_web::rt::spawn(async move {
        while let Some(Ok(msg)) = msg_stream.next().await {
            match msg {
                Message::Text(text) =&gt; {
                    // Access user in message handler
                    if user.has_role("ADMIN") &amp;&amp; text.trim() == "admin-cmd" {
                        let _ = session.text("Admin command executed").await;
                    } else {
                        let _ = session.text(format!("[{}] {}", user.get_username(), text)).await;
                    }
                }
                Message::Close(_) =&gt; break,
                _ =&gt; {}
            }
        }
    });

    Ok(response)
}</code></pre>
<h2 id="websocketuser-extractor"><a class="header" href="#websocketuser-extractor">WebSocketUser Extractor</a></h2>
<p>For simpler extraction with role/authority checks:</p>
<pre><code class="language-rust">use actix_security::http::security::websocket::WebSocketUser;

#[get("/ws")]
async fn ws_handler(req: HttpRequest, stream: web::Payload) -&gt; Result&lt;HttpResponse, Error&gt; {
    // Extract and validate in one line
    let user = WebSocketUser::extract(&amp;req)?
        .require_role("USER")?       // Check role
        .require_authority("ws:connect")?  // Check authority
        .into_inner();

    // ... upgrade to WebSocket with user
}</code></pre>
<h2 id="client-side-usage"><a class="header" href="#client-side-usage">Client-Side Usage</a></h2>
<h3 id="javascript-browser"><a class="header" href="#javascript-browser">JavaScript (Browser)</a></h3>
<pre><code class="language-javascript">// Browsers don't support custom headers for WebSocket
// Use public endpoints or pass token via query param (less secure)
const ws = new WebSocket('ws://localhost:8080/ws/public');
ws.onopen = () =&gt; console.log('Connected');
ws.onmessage = (e) =&gt; console.log('Received:', e.data);
ws.send('Hello');
</code></pre>
<h3 id="command-line-websocat"><a class="header" href="#command-line-websocat">Command Line (websocat)</a></h3>
<pre><code class="language-bash"># Get JWT token
TOKEN=$(curl -s -X POST http://localhost:8080/login \
  -H "Content-Type: application/json" \
  -d '{"username":"admin","password":"admin"}' | jq -r '.token')

# Connect with auth headers
websocat "ws://localhost:8080/ws" \
  -H "Authorization: Bearer $TOKEN" \
  -H "Origin: http://localhost:8080"
</code></pre>
<h2 id="spring-security-comparison-26"><a class="header" href="#spring-security-comparison-26">Spring Security Comparison</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Spring Security</th><th>Actix Security</th></tr></thead><tbody>
<tr><td><code>WebSocketSecurityConfigurer</code></td><td><code>WebSocketSecurityConfig</code></td></tr>
<tr><td><code>AbstractSecurityWebSocketMessageBrokerConfigurer</code></td><td>Security middleware + <code>OriginValidator</code></td></tr>
<tr><td><code>@PreAuthorize</code> on message handlers</td><td>Manual checks in actor/handler</td></tr>
<tr><td>CORS/Origin checking</td><td><code>OriginValidator</code></td></tr>
<tr><td><code>SimpMessagingTemplate</code></td><td>Native <code>actix-ws</code> session</td></tr>
</tbody></table>
</div>
<h2 id="security-best-practices-3"><a class="header" href="#security-best-practices-3">Security Best Practices</a></h2>
<ol>
<li><strong>Always use TLS</strong> - Use <code>wss://</code> in production</li>
<li><strong>Validate Origin</strong> - Prevent CSWSH attacks</li>
<li><strong>Authenticate during handshake</strong> - Before WebSocket upgrade</li>
<li><strong>Set message size limits</strong> - Prevent DoS attacks</li>
<li><strong>Implement timeouts</strong> - Close idle connections</li>
<li><strong>Log connections</strong> - Track who connects and when</li>
</ol>
<h2 id="example-application"><a class="header" href="#example-application">Example Application</a></h2>
<p>Run the complete example:</p>
<pre><code class="language-bash">cargo run -p actix-security-examples --bin websocket_auth
</code></pre>
<p>Then visit http://localhost:8080/test for a browser-based test page.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="api-key-authentication"><a class="header" href="#api-key-authentication">API Key Authentication</a></h1>
<p>API Key authentication is a simple authentication method where clients include a pre-shared key in their requests. It's commonly used for:</p>
<ul>
<li>Service-to-service communication</li>
<li>Public APIs with usage tracking</li>
<li>Simple authentication without user sessions</li>
</ul>
<h2 id="feature-flag-4"><a class="header" href="#feature-flag-4">Feature Flag</a></h2>
<p>Enable API Key authentication by adding the <code>api-key</code> feature:</p>
<pre><code class="language-toml">[dependencies]
actix-security = { version = "0.2", features = ["api-key"] }
</code></pre>
<h2 id="key-locations"><a class="header" href="#key-locations">Key Locations</a></h2>
<p>API keys can be extracted from multiple locations:</p>
<div class="table-wrapper"><table><thead><tr><th>Location</th><th>Example</th><th>Description</th></tr></thead><tbody>
<tr><td>Header</td><td><code>X-API-Key: sk_live_abc123</code></td><td>Recommended - most secure</td></tr>
<tr><td>Authorization Header</td><td><code>Authorization: ApiKey sk_live_abc123</code></td><td>Uses custom scheme</td></tr>
<tr><td>Query Parameter</td><td><code>?api_key=sk_live_abc123</code></td><td>Less secure, for testing</td></tr>
</tbody></table>
</div>
<h2 id="basic-setup"><a class="header" href="#basic-setup">Basic Setup</a></h2>
<pre><code class="language-rust">use actix_security::http::security::api_key::{
    ApiKeyAuthenticator, InMemoryApiKeyRepository, ApiKeyConfig, ApiKey,
};
use actix_security::http::security::middleware::SecurityTransform;

// Create API key repository
let repository = InMemoryApiKeyRepository::new()
    .with_key(ApiKey::new("sk_live_abc123")
        .name("Production Key")
        .roles(vec!["API_USER".into()])
        .authorities(vec!["api:read".into(), "api:write".into()]));

// Create authenticator
let authenticator = ApiKeyAuthenticator::new(repository);

// Use with middleware
App::new()
    .wrap(SecurityTransform::new()
        .config_authenticator(move || authenticator.clone()))</code></pre>
<h2 id="configuration-options-7"><a class="header" href="#configuration-options-7">Configuration Options</a></h2>
<h3 id="custom-header-name"><a class="header" href="#custom-header-name">Custom Header Name</a></h3>
<pre><code class="language-rust">let config = ApiKeyConfig::header("X-Custom-API-Key");
let authenticator = ApiKeyAuthenticator::new(repository).config(config);</code></pre>
<h3 id="authorization-header-with-custom-scheme"><a class="header" href="#authorization-header-with-custom-scheme">Authorization Header with Custom Scheme</a></h3>
<pre><code class="language-rust">// Expects: Authorization: Bearer sk_live_abc123
let config = ApiKeyConfig::authorization("Bearer");</code></pre>
<h3 id="query-parameter"><a class="header" href="#query-parameter">Query Parameter</a></h3>
<pre><code class="language-rust">// Reads from ?api_key=... or ?token=...
let config = ApiKeyConfig::query("api_key");</code></pre>
<h3 id="multiple-locations"><a class="header" href="#multiple-locations">Multiple Locations</a></h3>
<p>Check multiple locations in order of priority:</p>
<pre><code class="language-rust">use actix_security::http::security::api_key::ApiKeyLocation;

let config = ApiKeyConfig::new()
    .add_location(ApiKeyLocation::header("X-API-Key"))        // Check first
    .add_location(ApiKeyLocation::authorization("ApiKey"))    // Then this
    .add_location(ApiKeyLocation::query("api_key"));          // Finally this</code></pre>
<h2 id="api-key-model"><a class="header" href="#api-key-model">API Key Model</a></h2>
<p>The <code>ApiKey</code> struct holds all metadata for a key:</p>
<pre><code class="language-rust">let key = ApiKey::new("sk_live_abc123")
    .name("Production API Key")                     // Human-readable name
    .owner("service@example.com")                   // Owner identifier
    .roles(vec!["API_USER".into(), "ADMIN".into()]) // Roles for authorization
    .authorities(vec!["api:read".into()])           // Fine-grained permissions
    .enabled(true)                                  // Enable/disable the key
    .expires_in(Duration::from_secs(86400 * 365))   // Set expiration
    .with_metadata("environment", "production");    // Custom metadata</code></pre>
<h3 id="builder-pattern"><a class="header" href="#builder-pattern">Builder Pattern</a></h3>
<p>For more complex key creation:</p>
<pre><code class="language-rust">let key = ApiKey::builder("sk_live_abc123")
    .name("My Key")
    .role("USER")                // Add single role
    .role("ADMIN")               // Add another role
    .authority("api:read")       // Add single authority
    .authority("api:write")      // Add another authority
    .metadata("tier", "premium") // Add metadata
    .build();</code></pre>
<h2 id="custom-repository"><a class="header" href="#custom-repository">Custom Repository</a></h2>
<p>Implement <code>ApiKeyRepository</code> for custom storage backends:</p>
<pre><code class="language-rust">use actix_security::http::security::api_key::{ApiKey, ApiKeyRepository};

struct DatabaseApiKeyRepository {
    pool: DbPool,
}

impl ApiKeyRepository for DatabaseApiKeyRepository {
    fn find_by_key(&amp;self, key: &amp;str) -&gt; Option&lt;ApiKey&gt; {
        // Query your database
        let row = self.pool.query_one(
            "SELECT * FROM api_keys WHERE key_value = $1 AND enabled = true",
            &amp;[&amp;key]
        ).ok()?;

        Some(ApiKey::new(row.get("key_value"))
            .name(row.get("name"))
            .owner(row.get("owner"))
            .roles(row.get::&lt;_, Vec&lt;String&gt;&gt;("roles"))
            .authorities(row.get::&lt;_, Vec&lt;String&gt;&gt;("authorities"))
            .enabled(row.get("enabled")))
    }
}</code></pre>
<h2 id="validation-options"><a class="header" href="#validation-options">Validation Options</a></h2>
<p>Control what validations are performed:</p>
<pre><code class="language-rust">let config = ApiKeyConfig::default()
    .validate_expiration(true)   // Check if key has expired (default: true)
    .validate_enabled(true);     // Check if key is enabled (default: true)</code></pre>
<h2 id="complete-example-6"><a class="header" href="#complete-example-6">Complete Example</a></h2>
<p>See the full example in the repository:</p>
<pre><code class="language-bash">cargo run -p actix-security-examples --bin api_key_auth
</code></pre>
<pre><code class="language-rust">use actix_security::http::security::api_key::{
    ApiKey, ApiKeyAuthenticator, ApiKeyConfig, ApiKeyLocation, InMemoryApiKeyRepository,
};
use actix_security::http::security::middleware::SecurityTransform;
use actix_security::http::security::web::{Access, RequestMatcherAuthorizer};
use actix_security::http::security::{AuthenticatedUser, AuthorizationManager};

fn authenticator() -&gt; ApiKeyAuthenticator&lt;InMemoryApiKeyRepository&gt; {
    let repository = InMemoryApiKeyRepository::new()
        .with_key(ApiKey::new("sk_live_abc123")
            .name("Production Key")
            .roles(vec!["API_USER".into()])
            .authorities(vec!["api:read".into()]));

    ApiKeyAuthenticator::new(repository).config(
        ApiKeyConfig::new()
            .add_location(ApiKeyLocation::header("X-API-Key"))
            .add_location(ApiKeyLocation::authorization("ApiKey"))
            .add_location(ApiKeyLocation::query("api_key")),
    )
}

fn authorizer() -&gt; RequestMatcherAuthorizer {
    AuthorizationManager::request_matcher()
        .add_matcher("/api/admin.*", Access::new().roles(vec!["ADMIN"]))
        .add_matcher("/api/.*", Access::new().roles(vec!["API_USER"]))
}

#[actix_web::main]
async fn main() -&gt; std::io::Result&lt;()&gt; {
    HttpServer::new(move || {
        App::new()
            .wrap(SecurityTransform::new()
                .config_authenticator(authenticator)
                .config_authorizer(authorizer))
            .service(api_endpoint)
    })
    .bind("127.0.0.1:8080")?
    .run()
    .await
}</code></pre>
<h2 id="testing-1"><a class="header" href="#testing-1">Testing</a></h2>
<pre><code class="language-bash"># Without API key
curl http://127.0.0.1:8080/api/data
# -&gt; Redirects to /login

# With API key in header
curl -H "X-API-Key: sk_live_abc123" http://127.0.0.1:8080/api/data
# -&gt; 200 OK

# With API key in Authorization header
curl -H "Authorization: ApiKey sk_live_abc123" http://127.0.0.1:8080/api/data
# -&gt; 200 OK

# With API key in query parameter
curl "http://127.0.0.1:8080/api/data?api_key=sk_live_abc123"
# -&gt; 200 OK
</code></pre>
<h2 id="spring-security-comparison-27"><a class="header" href="#spring-security-comparison-27">Spring Security Comparison</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Spring Security</th><th>Actix Security</th></tr></thead><tbody>
<tr><td>Custom <code>AuthenticationFilter</code></td><td><code>ApiKeyAuthenticator</code></td></tr>
<tr><td><code>AuthenticationProvider</code></td><td><code>ApiKeyRepository</code></td></tr>
<tr><td><code>AbstractPreAuthenticatedProcessingFilter</code></td><td><code>ApiKeyConfig</code> locations</td></tr>
<tr><td><code>UserDetails</code></td><td><code>ApiKey</code> model</td></tr>
</tbody></table>
</div>
<h2 id="security-best-practices-4"><a class="header" href="#security-best-practices-4">Security Best Practices</a></h2>
<ol>
<li><strong>Use HTTPS</strong> - API keys are transmitted in plaintext</li>
<li><strong>Prefer Header Location</strong> - Query parameters may be logged</li>
<li><strong>Rotate Keys Regularly</strong> - Implement key rotation policies</li>
<li><strong>Limit Scope</strong> - Use roles/authorities to restrict key capabilities</li>
<li><strong>Set Expiration</strong> - Don't use keys that never expire</li>
<li><strong>Monitor Usage</strong> - Log API key usage for security auditing</li>
<li><strong>Rate Limit</strong> - Prevent abuse with rate limiting per key</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ldap-authentication"><a class="header" href="#ldap-authentication">LDAP Authentication</a></h1>
<p>LDAP authentication allows you to authenticate users against an LDAP or Active Directory server.</p>
<h2 id="enabling-ldap-authentication"><a class="header" href="#enabling-ldap-authentication">Enabling LDAP Authentication</a></h2>
<p>Add the <code>ldap</code> feature to your <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[dependencies]
actix-security = { version = "0.2", features = ["ldap"] }
</code></pre>
<h2 id="basic-usage-10"><a class="header" href="#basic-usage-10">Basic Usage</a></h2>
<pre><code class="language-rust">use actix_security::http::security::{LdapAuthenticator, LdapConfig, MockLdapClient};
use actix_web::{App, HttpServer};

#[actix_web::main]
async fn main() -&gt; std::io::Result&lt;()&gt; {
    let ldap_config = LdapConfig::new("ldap://ldap.example.com:389")
        .base_dn("dc=example,dc=com")
        .user_search_filter("(uid={0})")
        .bind_dn("cn=admin,dc=example,dc=com")
        .bind_password("admin_password");

    // Create authenticator with a client that implements LdapOperations
    // For testing, use MockLdapClient; for production, use a real LDAP client
    let client = MockLdapClient::new();
    let authenticator = LdapAuthenticator::new(ldap_config, client);

    HttpServer::new(move || {
        App::new()
            // Configure with SecurityTransform
            // ...
    })
    .bind("127.0.0.1:8080")?
    .run()
    .await
}</code></pre>
<h2 id="configuration-options-8"><a class="header" href="#configuration-options-8">Configuration Options</a></h2>
<pre><code class="language-rust">LdapConfig::new("ldap://ldap.example.com:389")
    // Base DN for user searches
    .base_dn("dc=example,dc=com")

    // User search configuration
    .user_search_base("ou=users")
    .user_search_filter("(uid={0})")

    // Service account for binding
    .bind_dn("cn=admin,dc=example,dc=com")
    .bind_password("admin_password")

    // Group configuration
    .group_search_base("ou=groups")
    .group_search_filter("(member={0})")

    // Role configuration
    .role_prefix("ROLE_")
    .convert_to_uppercase(true)

    // Timeouts
    .connect_timeout(Duration::from_secs(5))
    .operation_timeout(Duration::from_secs(10))</code></pre>
<h2 id="active-directory-configuration"><a class="header" href="#active-directory-configuration">Active Directory Configuration</a></h2>
<p>For Active Directory, use the preset configuration:</p>
<pre><code class="language-rust">let config = LdapConfig::active_directory(
    "ldap://ad.company.com:389",
    "dc=company,dc=com"
)
.bind_dn("cn=service,cn=users,dc=company,dc=com")
.bind_password("service_password");</code></pre>
<p>This configures:</p>
<ul>
<li>User search filter: <code>(sAMAccountName={0})</code></li>
<li>Group membership attribute: <code>memberOf</code></li>
</ul>
<h2 id="user-attributes-mapping"><a class="header" href="#user-attributes-mapping">User Attributes Mapping</a></h2>
<p>Configure which LDAP attributes map to user properties:</p>
<pre><code class="language-rust">LdapConfig::new()
    .username_attribute("uid")           // Default: "uid"
    .display_name_attribute("cn")        // Display name
    .email_attribute("mail")             // Email address
    .group_attribute("memberOf")         // Group membership</code></pre>
<h2 id="group-to-role-mapping"><a class="header" href="#group-to-role-mapping">Group to Role Mapping</a></h2>
<p>Map LDAP groups to application roles:</p>
<pre><code class="language-rust">let config = LdapConfig::new()
    // ... base configuration
    .group_role_mapping("cn=admins,ou=groups,dc=example,dc=com", "ADMIN")
    .group_role_mapping("cn=users,ou=groups,dc=example,dc=com", "USER")
    .group_role_mapping("cn=managers,ou=groups,dc=example,dc=com", "MANAGER");</code></pre>
<h2 id="testing-with-mockldapclient"><a class="header" href="#testing-with-mockldapclient">Testing with MockLdapClient</a></h2>
<p>For testing without a real LDAP server:</p>
<pre><code class="language-rust">use actix_security::http::security::MockLdapClient;

let mut mock = MockLdapClient::new();

// Add test users
mock.add_user(
    "john",
    "password123",
    vec![
        ("cn".into(), vec!["John Doe".into()]),
        ("mail".into(), vec!["john@example.com".into()]),
    ],
    vec!["cn=users,ou=groups,dc=example,dc=com".into()],
);

let authenticator = LdapAuthenticator::with_client(config, mock);</code></pre>
<h2 id="error-handling-2"><a class="header" href="#error-handling-2">Error Handling</a></h2>
<p>LDAP authentication can fail for various reasons:</p>
<pre><code class="language-rust">use actix_security::http::security::LdapError;

match result {
    Err(LdapError::ConnectionFailed) =&gt; // LDAP server unreachable
    Err(LdapError::BindFailed) =&gt; // Invalid service account credentials
    Err(LdapError::UserNotFound) =&gt; // User not in directory
    Err(LdapError::AuthenticationFailed) =&gt; // Invalid password
    Err(LdapError::SearchFailed) =&gt; // LDAP search error
}</code></pre>
<h2 id="spring-security-comparison-28"><a class="header" href="#spring-security-comparison-28">Spring Security Comparison</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Spring Security</th><th>Actix Security</th></tr></thead><tbody>
<tr><td><code>LdapAuthenticationProvider</code></td><td><code>LdapAuthenticator</code></td></tr>
<tr><td><code>LdapContextSource</code></td><td><code>LdapConfig</code></td></tr>
<tr><td><code>LdapUserSearch</code></td><td><code>.user_search_filter()</code></td></tr>
<tr><td><code>DefaultLdapAuthoritiesPopulator</code></td><td><code>.group_role_mapping()</code></td></tr>
<tr><td><code>ActiveDirectoryLdapAuthenticationProvider</code></td><td><code>LdapConfig::active_directory()</code></td></tr>
</tbody></table>
</div>
<h2 id="best-practices-8"><a class="header" href="#best-practices-8">Best Practices</a></h2>
<ol>
<li><strong>Use TLS</strong>: Connect using <code>ldaps://</code> or STARTTLS for production</li>
<li><strong>Service Account</strong>: Use a dedicated service account for binding</li>
<li><strong>Principle of Least Privilege</strong>: Service account should only have read access</li>
<li><strong>Connection Pooling</strong>: Consider connection pooling for high-traffic applications</li>
<li><strong>Timeout Configuration</strong>: Set appropriate timeouts for LDAP operations</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="saml-20-authentication"><a class="header" href="#saml-20-authentication">SAML 2.0 Authentication</a></h1>
<p>SAML 2.0 (Security Assertion Markup Language) enables Single Sign-On (SSO) with enterprise identity providers like Okta, Azure AD, ADFS, and Google Workspace.</p>
<h2 id="enabling-saml-authentication"><a class="header" href="#enabling-saml-authentication">Enabling SAML Authentication</a></h2>
<p>Add the <code>saml</code> feature to your <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[dependencies]
actix-security = { version = "0.2", features = ["saml"] }
</code></pre>
<h2 id="basic-usage-11"><a class="header" href="#basic-usage-11">Basic Usage</a></h2>
<pre><code class="language-rust">use actix_security::http::security::{SamlAuthenticator, SamlConfig};
use actix_web::{App, HttpServer};

#[actix_web::main]
async fn main() -&gt; std::io::Result&lt;()&gt; {
    let saml_config = SamlConfig::new()
        .entity_id("https://myapp.example.com")
        .acs_url("https://myapp.example.com/saml/acs")
        .idp_entity_id("https://idp.example.com")
        .idp_sso_url("https://idp.example.com/sso")
        .idp_certificate(include_str!("../idp_cert.pem"));

    let authenticator = SamlAuthenticator::new(saml_config)
        .expect("Failed to create SAML authenticator");

    HttpServer::new(move || {
        App::new()
            // Configure routes for SAML
            // ...
    })
    .bind("127.0.0.1:8080")?
    .run()
    .await
}</code></pre>
<h2 id="provider-presets"><a class="header" href="#provider-presets">Provider Presets</a></h2>
<p>Use preset configurations for common identity providers:</p>
<h3 id="okta"><a class="header" href="#okta">Okta</a></h3>
<pre><code class="language-rust">let config = SamlConfig::okta(
    "dev-123456",                           // Okta org subdomain
    "0oa1234567890abcdef",                  // App ID
    "https://myapp.example.com",            // SP Entity ID
    "https://myapp.example.com/saml/acs",   // ACS URL
)
.idp_certificate(include_str!("okta_cert.pem"));</code></pre>
<h3 id="azure-ad"><a class="header" href="#azure-ad">Azure AD</a></h3>
<pre><code class="language-rust">let config = SamlConfig::azure_ad(
    "tenant-id-here",                       // Azure tenant ID
    "app-id-here",                          // Azure app ID
    "https://myapp.example.com",            // SP Entity ID
)
.idp_certificate(include_str!("azure_cert.pem"));</code></pre>
<h3 id="google-workspace"><a class="header" href="#google-workspace">Google Workspace</a></h3>
<pre><code class="language-rust">let config = SamlConfig::google_workspace(
    "https://myapp.example.com",            // SP Entity ID
    "https://myapp.example.com/saml/acs",   // ACS URL
)
.idp_certificate(include_str!("google_cert.pem"));</code></pre>
<h3 id="adfs"><a class="header" href="#adfs">ADFS</a></h3>
<pre><code class="language-rust">let config = SamlConfig::adfs(
    "https://adfs.company.com",             // ADFS server URL
    "https://myapp.example.com",            // SP Entity ID
    "https://myapp.example.com/saml/acs",   // ACS URL
)
.idp_certificate(include_str!("adfs_cert.pem"));</code></pre>
<h2 id="configuration-options-9"><a class="header" href="#configuration-options-9">Configuration Options</a></h2>
<pre><code class="language-rust">SamlConfig::new()
    // Service Provider (your application) settings
    .entity_id("https://myapp.example.com")
    .acs_url("https://myapp.example.com/saml/acs")
    .sls_url("https://myapp.example.com/saml/slo")  // Single Logout Service

    // Identity Provider settings
    .idp_entity_id("https://idp.example.com")
    .idp_sso_url("https://idp.example.com/sso")
    .idp_slo_url("https://idp.example.com/slo")
    .idp_certificate("-----BEGIN CERTIFICATE-----...")

    // Request settings
    .name_id_format(NameIdFormat::EmailAddress)
    .authn_context_class(AuthnContextClass::PasswordProtectedTransport)
    .sign_authn_request(false)              // Sign outgoing AuthnRequest
    .want_assertions_signed(true)           // Require signed assertions

    // Attribute mapping
    .role_attribute("groups")               // Attribute containing roles</code></pre>
<h2 id="saml-routes"><a class="header" href="#saml-routes">SAML Routes</a></h2>
<p>You need to set up routes to handle SAML flow:</p>
<pre><code class="language-rust">use actix_security::http::security::SamlAuthenticator;
use actix_web::{web, HttpResponse};
use serde::Deserialize;

#[derive(Deserialize)]
struct SamlResponseForm {
    #[serde(rename = "SAMLResponse")]
    saml_response: String,
}

// Initiate SAML login
async fn saml_login(saml: web::Data&lt;SamlAuthenticator&gt;) -&gt; HttpResponse {
    // initiate_login creates and stores the AuthnRequest, returns redirect URL
    let redirect_url = saml.initiate_login(None);

    HttpResponse::Found()
        .insert_header(("Location", redirect_url))
        .finish()
}

// Handle SAML response (Assertion Consumer Service)
async fn saml_acs(
    saml: web::Data&lt;SamlAuthenticator&gt;,
    form: web::Form&lt;SamlResponseForm&gt;,
) -&gt; HttpResponse {
    match saml.process_response(&amp;form.saml_response) {
        Ok(auth_result) =&gt; {
            // auth_result contains: user, session_index, name_id, attributes
            // Store user in session
            HttpResponse::Found()
                .insert_header(("Location", "/"))
                .finish()
        }
        Err(e) =&gt; HttpResponse::Unauthorized().body(format!("SAML error: {:?}", e))
    }
}

// Configure routes
App::new()
    .route("/saml/login", web::get().to(saml_login))
    .route("/saml/acs", web::post().to(saml_acs))</code></pre>
<h2 id="sp-metadata-generation"><a class="header" href="#sp-metadata-generation">SP Metadata Generation</a></h2>
<p>Generate SAML metadata for your IdP:</p>
<pre><code class="language-rust">// Serve at /saml/metadata
async fn saml_metadata(saml: web::Data&lt;SamlAuthenticator&gt;) -&gt; HttpResponse {
    let metadata = saml.generate_metadata();
    HttpResponse::Ok()
        .content_type("application/xml")
        .body(metadata)
}</code></pre>
<h2 id="assertion-validation"><a class="header" href="#assertion-validation">Assertion Validation</a></h2>
<p>The library validates SAML assertions for:</p>
<ul>
<li><strong>Signature</strong>: Verifies IdP signature using configured certificate</li>
<li><strong>Audience</strong>: Ensures assertion is intended for your SP</li>
<li><strong>Timing</strong>: Checks NotBefore and NotOnOrAfter conditions</li>
<li><strong>Replay</strong>: Validates InResponseTo matches pending request</li>
</ul>
<h2 id="error-handling-3"><a class="header" href="#error-handling-3">Error Handling</a></h2>
<pre><code class="language-rust">use actix_security::http::security::SamlError;

match result {
    Err(SamlError::InvalidSignature) =&gt; // Signature verification failed
    Err(SamlError::AudienceMismatch) =&gt; // Wrong SP entity ID
    Err(SamlError::AssertionExpired) =&gt; // Assertion timing invalid
    Err(SamlError::InvalidRequest) =&gt; // Malformed SAML request
    Err(SamlError::IdpError(msg)) =&gt; // IdP returned an error
}</code></pre>
<h2 id="grouprole-mapping"><a class="header" href="#grouprole-mapping">Group/Role Mapping</a></h2>
<p>Map SAML groups to application roles:</p>
<pre><code class="language-rust">let config = SamlConfig::new()
    // ... base configuration
    .roles_attribute("groups")  // Attribute containing groups
    .role_mapping("IdP-Admins", "ADMIN")
    .role_mapping("IdP-Users", "USER");</code></pre>
<h2 id="single-logout-slo"><a class="header" href="#single-logout-slo">Single Logout (SLO)</a></h2>
<p>Support for SAML Single Logout:</p>
<pre><code class="language-rust">// Initiate logout
async fn saml_logout(saml: web::Data&lt;SamlAuthenticator&gt;) -&gt; HttpResponse {
    let logout_request = saml.create_logout_request(&amp;user);
    let redirect_url = saml.get_slo_redirect_url(&amp;logout_request);

    // Clear local session
    // ...

    HttpResponse::Found()
        .insert_header(("Location", redirect_url))
        .finish()
}</code></pre>
<h2 id="spring-security-comparison-29"><a class="header" href="#spring-security-comparison-29">Spring Security Comparison</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Spring Security</th><th>Actix Security</th></tr></thead><tbody>
<tr><td><code>Saml2LoginConfigurer</code></td><td><code>SamlConfig</code></td></tr>
<tr><td><code>RelyingPartyRegistration</code></td><td><code>SamlConfig</code> builder methods</td></tr>
<tr><td><code>Saml2AuthenticationRequestResolver</code></td><td><code>create_authn_request()</code></td></tr>
<tr><td><code>OpenSaml4AuthenticationProvider</code></td><td><code>SamlAuthenticator</code></td></tr>
<tr><td><code>Saml2MetadataFilter</code></td><td><code>generate_sp_metadata()</code></td></tr>
</tbody></table>
</div>
<h2 id="security-considerations-3"><a class="header" href="#security-considerations-3">Security Considerations</a></h2>
<ol>
<li><strong>Use HTTPS</strong>: Always use HTTPS for ACS URL in production</li>
<li><strong>Validate Signatures</strong>: Never disable signature validation</li>
<li><strong>Certificate Management</strong>: Keep IdP certificates up to date</li>
<li><strong>Clock Synchronization</strong>: Ensure servers have synchronized time</li>
<li><strong>Secure Storage</strong>: Protect SP private keys if using signed requests</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="architecture"><a class="header" href="#architecture">Architecture</a></h1>
<p>Understanding Actix Security's internal architecture.</p>
<h2 id="overview-8"><a class="header" href="#overview-8">Overview</a></h2>
<p>Actix Security follows a <strong>middleware-based architecture</strong> inspired by Spring Security's filter chain. The security flow is:</p>
<pre><code>Request ‚Üí SecurityTransform ‚Üí SecurityService ‚Üí Your Handler ‚Üí Response
              ‚Üì                    ‚Üì
         Authenticator         Authorizer
</code></pre>
<h2 id="core-components"><a class="header" href="#core-components">Core Components</a></h2>
<h3 id="securitytransform"><a class="header" href="#securitytransform">SecurityTransform</a></h3>
<p>The entry point for security. Implements Actix Web's <code>Transform</code> trait.</p>
<pre><code class="language-rust">pub struct SecurityTransform&lt;A, Z&gt;
where
    A: Authenticator,
    Z: Authorizer,
{
    authenticator_factory: Box&lt;dyn Fn() -&gt; A&gt;,
    authorizer_factory: Box&lt;dyn Fn() -&gt; Z&gt;,
}</code></pre>
<p><strong>Responsibilities:</strong></p>
<ul>
<li>Creates <code>SecurityService</code> for each worker</li>
<li>Provides factory functions for authenticator and authorizer</li>
</ul>
<h3 id="securityservice"><a class="header" href="#securityservice">SecurityService</a></h3>
<p>Wraps your service and applies security checks.</p>
<pre><code class="language-rust">pub struct SecurityService&lt;S, A, Z&gt;
where
    A: Authenticator,
    Z: Authorizer,
{
    service: S,
    authenticator: A,
    authorizer: Z,
}</code></pre>
<p><strong>Responsibilities:</strong></p>
<ul>
<li>Extracts user via authenticator</li>
<li>Checks access via authorizer</li>
<li>Sets up SecurityContext</li>
<li>Calls your service if authorized</li>
</ul>
<h3 id="authenticator-trait"><a class="header" href="#authenticator-trait">Authenticator Trait</a></h3>
<p>Defines how to extract user identity from requests.</p>
<pre><code class="language-rust">pub trait Authenticator: Clone + Send + Sync + 'static {
    fn authenticate(&amp;self, req: &amp;ServiceRequest) -&gt; Option&lt;User&gt;;
}</code></pre>
<p><strong>Implementations:</strong></p>
<ul>
<li><code>MemoryAuthenticator</code> - In-memory user store</li>
</ul>
<h3 id="authorizer-trait"><a class="header" href="#authorizer-trait">Authorizer Trait</a></h3>
<p>Defines how to check access permissions.</p>
<pre><code class="language-rust">pub trait Authorizer: Clone + Send + Sync + 'static {
    fn authorize(&amp;self, user: Option&lt;&amp;User&gt;, req: &amp;ServiceRequest) -&gt; AuthorizationResult;
}

pub enum AuthorizationResult {
    Granted,
    Denied,
    LoginRequired,
}</code></pre>
<p><strong>Implementations:</strong></p>
<ul>
<li><code>RequestMatcherAuthorizer</code> - URL pattern-based authorization</li>
</ul>
<h2 id="request-flow"><a class="header" href="#request-flow">Request Flow</a></h2>
<pre><code>1. Request arrives
   ‚Üì
2. SecurityService.call() invoked
   ‚Üì
3. Authenticator.authenticate()
   ‚îú‚îÄ Success: User extracted
   ‚îî‚îÄ Failure: user = None
   ‚Üì
4. Authorizer.authorize(user, request)
   ‚îú‚îÄ Granted: Continue
   ‚îú‚îÄ Denied: 403 Forbidden
   ‚îî‚îÄ LoginRequired: 401 or redirect
   ‚Üì
5. SecurityContext.run_with(user, ...)
   ‚Üì
6. Your handler executes
   ‚îú‚îÄ Method security macros check
   ‚îî‚îÄ Handler code runs
   ‚Üì
7. Response returned
</code></pre>
<h2 id="module-structure"><a class="header" href="#module-structure">Module Structure</a></h2>
<pre><code>actix-security/          # Unified crate (recommended)
‚îú‚îÄ‚îÄ Cargo.toml          # Re-exports core + codegen
‚îî‚îÄ‚îÄ src/lib.rs          # Unified exports

core/                    # actix-security-core
‚îú‚îÄ‚îÄ http/
‚îÇ   ‚îú‚îÄ‚îÄ error.rs         # AuthError type
‚îÇ   ‚îî‚îÄ‚îÄ security/
‚îÇ       ‚îú‚îÄ‚îÄ mod.rs       # Public exports
‚îÇ       ‚îú‚îÄ‚îÄ config.rs    # Traits (Authenticator, Authorizer)
‚îÇ       ‚îú‚îÄ‚îÄ user.rs      # User model
‚îÇ       ‚îú‚îÄ‚îÄ extractor.rs # AuthenticatedUser extractor
‚îÇ       ‚îú‚îÄ‚îÄ context.rs   # SecurityContext
‚îÇ       ‚îú‚îÄ‚îÄ middleware.rs# SecurityTransform, SecurityService
‚îÇ       ‚îú‚îÄ‚îÄ authenticator/
‚îÇ       ‚îÇ   ‚îî‚îÄ‚îÄ memory.rs
‚îÇ       ‚îú‚îÄ‚îÄ authorizer/
‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ access.rs
‚îÇ       ‚îÇ   ‚îî‚îÄ‚îÄ request_matcher.rs
‚îÇ       ‚îú‚îÄ‚îÄ crypto/
‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ argon2.rs
‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ noop.rs
‚îÇ       ‚îÇ   ‚îî‚îÄ‚îÄ delegating.rs
‚îÇ       ‚îú‚îÄ‚îÄ expression/
‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ ast.rs
‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ parser.rs
‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ evaluator.rs
‚îÇ       ‚îÇ   ‚îî‚îÄ‚îÄ root.rs
‚îÇ       ‚îú‚îÄ‚îÄ headers.rs   # SecurityHeaders middleware
‚îÇ       ‚îî‚îÄ‚îÄ manager.rs   # Factory methods

codegen/                 # actix-security-codegen
‚îú‚îÄ‚îÄ lib.rs              # Macro exports
‚îú‚îÄ‚îÄ secured.rs          # #[secured] macro
‚îú‚îÄ‚îÄ pre_authorize.rs    # #[pre_authorize] macro
‚îî‚îÄ‚îÄ simple.rs           # permit_all, deny_all, roles_allowed
</code></pre>
<h2 id="proc-macro-architecture"><a class="header" href="#proc-macro-architecture">Proc Macro Architecture</a></h2>
<h3 id="compile-time-flow"><a class="header" href="#compile-time-flow">Compile-Time Flow</a></h3>
<pre><code>#[pre_authorize("hasRole('ADMIN')")]
        ‚Üì
    Parse expression (compile-time)
        ‚Üì
    Build AST
        ‚Üì
    Generate Rust code
        ‚Üì
    Inject into handler
</code></pre>
<h3 id="expression-compilation"><a class="header" href="#expression-compilation">Expression Compilation</a></h3>
<pre><code class="language-rust">// Input expression
"hasRole('ADMIN') OR hasAuthority('write')"

// Parsed AST
Binary {
    op: Or,
    left: Function("hasRole", ["ADMIN"]),
    right: Function("hasAuthority", ["write"]),
}

// Generated Rust
if !(user.has_role("ADMIN") || user.has_authority("write")) {
    return Err(AuthError::Forbidden);
}</code></pre>
<h2 id="thread-safety-2"><a class="header" href="#thread-safety-2">Thread Safety</a></h2>
<p>All security components are designed to be thread-safe:</p>
<pre><code class="language-rust">// All traits require these bounds
pub trait Authenticator: Clone + Send + Sync + 'static { }
pub trait Authorizer: Clone + Send + Sync + 'static { }</code></pre>
<p><strong>SecurityContext</strong> uses Tokio's task-local storage for safe async access:</p>
<pre><code class="language-rust">tokio::task_local! {
    static SECURITY_CONTEXT: RefCell&lt;Option&lt;User&gt;&gt;;
}</code></pre>
<h2 id="spring-security-comparison-30"><a class="header" href="#spring-security-comparison-30">Spring Security Comparison</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Spring Security</th><th>Actix Security</th></tr></thead><tbody>
<tr><td><code>SecurityFilterChain</code></td><td><code>SecurityTransform</code></td></tr>
<tr><td><code>AuthenticationManager</code></td><td><code>Authenticator</code> trait</td></tr>
<tr><td><code>AuthorizationManager</code></td><td><code>Authorizer</code> trait</td></tr>
<tr><td><code>UserDetails</code></td><td><code>User</code></td></tr>
<tr><td><code>Authentication</code></td><td><code>AuthenticatedUser</code></td></tr>
<tr><td><code>SecurityContext</code></td><td><code>SecurityContext</code></td></tr>
<tr><td><code>MethodSecurityExpressionRoot</code></td><td><code>ExpressionRoot</code> trait</td></tr>
</tbody></table>
</div>
<h2 id="extensibility-points"><a class="header" href="#extensibility-points">Extensibility Points</a></h2>
<ol>
<li><strong>Custom Authenticator</strong> - Implement <code>Authenticator</code> trait</li>
<li><strong>Custom Authorizer</strong> - Implement <code>Authorizer</code> trait</li>
<li><strong>Custom Password Encoder</strong> - Implement <code>PasswordEncoder</code> trait</li>
<li><strong>Custom Expressions</strong> - Implement <code>ExpressionRoot</code> trait</li>
</ol>
<h2 id="design-principles"><a class="header" href="#design-principles">Design Principles</a></h2>
<ol>
<li><strong>Compile-time safety</strong> - Catch errors at compile time</li>
<li><strong>Zero-cost abstractions</strong> - No runtime overhead for unused features</li>
<li><strong>Explicit over implicit</strong> - Clear, readable security configuration</li>
<li><strong>Familiar API</strong> - Similar to Spring Security for easy adoption</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="extending-the-framework"><a class="header" href="#extending-the-framework">Extending the Framework</a></h1>
<p>Actix Security is designed to be extensible. This guide covers the main extension points.</p>
<h2 id="extension-points-overview"><a class="header" href="#extension-points-overview">Extension Points Overview</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Extension Point</th><th>Purpose</th><th>Trait/Type</th></tr></thead><tbody>
<tr><td>Authentication</td><td>Custom user extraction</td><td><code>Authenticator</code></td></tr>
<tr><td>Authorization</td><td>Custom access control</td><td><code>Authorizer</code></td></tr>
<tr><td>Password Encoding</td><td>Custom hashing</td><td><code>PasswordEncoder</code></td></tr>
<tr><td>Expressions</td><td>Custom functions</td><td><code>ExpressionRoot</code></td></tr>
</tbody></table>
</div>
<h2 id="custom-authenticator"><a class="header" href="#custom-authenticator">Custom Authenticator</a></h2>
<p>Extract users from custom sources (database, JWT, OAuth, etc.).</p>
<h3 id="implement-the-trait"><a class="header" href="#implement-the-trait">Implement the Trait</a></h3>
<pre><code class="language-rust">use actix_security::http::security::config::Authenticator;
use actix_security::http::security::User;
use actix_web::dev::ServiceRequest;

#[derive(Clone)]
pub struct DatabaseAuthenticator {
    pool: PgPool,
    encoder: Argon2PasswordEncoder,
}

impl Authenticator for DatabaseAuthenticator {
    fn authenticate(&amp;self, req: &amp;ServiceRequest) -&gt; Option&lt;User&gt; {
        // 1. Extract credentials
        let auth_header = req.headers().get("Authorization")?;
        let (username, password) = self.parse_basic_auth(auth_header)?;

        // 2. Query database (use block_on for sync context)
        let user_record = tokio::task::block_in_place(|| {
            tokio::runtime::Handle::current().block_on(
                self.pool.query_one("SELECT * FROM users WHERE username = $1", &amp;[&amp;username])
            )
        }).ok()?;

        // 3. Verify password
        if !self.encoder.matches(&amp;password, &amp;user_record.password_hash) {
            return None;
        }

        // 4. Build and return User
        Some(User {
            username: user_record.username,
            password: user_record.password_hash,
            roles: user_record.roles.into_iter().collect(),
            authorities: user_record.authorities.into_iter().collect(),
        })
    }
}</code></pre>
<h3 id="register-with-securitytransform"><a class="header" href="#register-with-securitytransform">Register with SecurityTransform</a></h3>
<pre><code class="language-rust">let db_authenticator = DatabaseAuthenticator::new(pool, encoder);

App::new()
    .wrap(
        SecurityTransform::new()
            .config_authenticator(move || db_authenticator.clone())
            .config_authorizer(|| /* ... */)
    )</code></pre>
<h2 id="custom-authorizer"><a class="header" href="#custom-authorizer">Custom Authorizer</a></h2>
<p>Implement custom authorization logic.</p>
<h3 id="implement-the-trait-1"><a class="header" href="#implement-the-trait-1">Implement the Trait</a></h3>
<pre><code class="language-rust">use actix_security::http::security::config::{Authorizer, AuthorizationResult};
use actix_security::http::security::User;
use actix_web::dev::ServiceRequest;

#[derive(Clone)]
pub struct AbacAuthorizer {
    policy_engine: PolicyEngine,
}

impl Authorizer for AbacAuthorizer {
    fn authorize(&amp;self, user: Option&lt;&amp;User&gt;, req: &amp;ServiceRequest) -&gt; AuthorizationResult {
        // Build policy context
        let context = PolicyContext {
            subject: user.map(|u| Subject {
                id: u.username.clone(),
                roles: u.roles.clone(),
                attributes: self.get_user_attributes(user),
            }),
            resource: Resource {
                path: req.path().to_string(),
                method: req.method().to_string(),
            },
            environment: Environment {
                time: chrono::Utc::now(),
                ip: req.peer_addr().map(|a| a.ip()),
            },
        };

        // Evaluate policy
        match self.policy_engine.evaluate(&amp;context) {
            PolicyDecision::Allow =&gt; AuthorizationResult::Granted,
            PolicyDecision::Deny =&gt; AuthorizationResult::Denied,
            PolicyDecision::NotApplicable =&gt; {
                if user.is_some() {
                    AuthorizationResult::Denied
                } else {
                    AuthorizationResult::LoginRequired
                }
            }
        }
    }
}</code></pre>
<h2 id="custom-password-encoder"><a class="header" href="#custom-password-encoder">Custom Password Encoder</a></h2>
<p>Implement custom password hashing.</p>
<h3 id="implement-the-trait-2"><a class="header" href="#implement-the-trait-2">Implement the Trait</a></h3>
<pre><code class="language-rust">use actix_security::http::security::PasswordEncoder;

#[derive(Clone)]
pub struct BcryptEncoder {
    cost: u32,
}

impl PasswordEncoder for BcryptEncoder {
    fn encode(&amp;self, raw_password: &amp;str) -&gt; String {
        bcrypt::hash(raw_password, self.cost).unwrap()
    }

    fn matches(&amp;self, raw_password: &amp;str, encoded_password: &amp;str) -&gt; bool {
        bcrypt::verify(raw_password, encoded_password).unwrap_or(false)
    }
}</code></pre>
<h3 id="use-with-delegatingpasswordencoder"><a class="header" href="#use-with-delegatingpasswordencoder">Use with DelegatingPasswordEncoder</a></h3>
<pre><code class="language-rust">let encoder = DelegatingPasswordEncoder::new()
    .with_encoder("bcrypt", Box::new(BcryptEncoder::new(12)))
    .with_encoder("argon2", Box::new(Argon2PasswordEncoder::new()))
    .default_encoder("argon2");</code></pre>
<h2 id="custom-expression-functions"><a class="header" href="#custom-expression-functions">Custom Expression Functions</a></h2>
<p>Add domain-specific expression functions.</p>
<h3 id="implement-expressionroot"><a class="header" href="#implement-expressionroot">Implement ExpressionRoot</a></h3>
<pre><code class="language-rust">use actix_security::http::security::expression::ExpressionRoot;
use actix_security::http::security::User;

#[derive(Clone)]
pub struct TenantExpressionRoot {
    tenant_service: TenantService,
}

impl ExpressionRoot for TenantExpressionRoot {
    fn evaluate_function(
        &amp;self,
        name: &amp;str,
        args: &amp;[String],
        user: Option&lt;&amp;User&gt;,
    ) -&gt; Option&lt;bool&gt; {
        match name {
            "belongsToTenant" =&gt; {
                let tenant_id = args.get(0)?;
                let user = user?;
                Some(self.tenant_service.user_belongs_to(&amp;user.username, tenant_id))
            }
            "isTenantAdmin" =&gt; {
                let tenant_id = args.get(0)?;
                let user = user?;
                Some(self.tenant_service.is_admin(&amp;user.username, tenant_id))
            }
            "hasTenantPermission" =&gt; {
                let tenant_id = args.get(0)?;
                let permission = args.get(1)?;
                let user = user?;
                Some(self.tenant_service.has_permission(
                    &amp;user.username, tenant_id, permission
                ))
            }
            _ =&gt; None, // Let default handle unknown functions
        }
    }
}</code></pre>
<h3 id="use-in-expressions"><a class="header" href="#use-in-expressions">Use in Expressions</a></h3>
<pre><code class="language-rust">#[pre_authorize("belongsToTenant('acme')")]
async fn tenant_resource() {}

#[pre_authorize("isTenantAdmin('acme') OR hasRole('SUPER_ADMIN')")]
async fn tenant_admin() {}

#[pre_authorize("hasTenantPermission('acme', 'billing:manage')")]
async fn billing() {}</code></pre>
<h2 id="combining-extensions"><a class="header" href="#combining-extensions">Combining Extensions</a></h2>
<pre><code class="language-rust">// Custom components
let db_authenticator = DatabaseAuthenticator::new(pool.clone(), encoder.clone());
let abac_authorizer = AbacAuthorizer::new(policy_engine);
let tenant_root = TenantExpressionRoot::new(tenant_service);

// Create app
App::new()
    .wrap(SecurityHeaders::strict())
    .wrap(
        SecurityTransform::new()
            .config_authenticator(move || db_authenticator.clone())
            .config_authorizer(move || abac_authorizer.clone())
    )
    .app_data(web::Data::new(tenant_root))
    .service(/* ... */)</code></pre>
<h2 id="best-practices-9"><a class="header" href="#best-practices-9">Best Practices</a></h2>
<h3 id="1-clone-efficiently"><a class="header" href="#1-clone-efficiently">1. Clone Efficiently</a></h3>
<p>All extension traits require <code>Clone</code>. Use <code>Arc</code> for shared state:</p>
<pre><code class="language-rust">#[derive(Clone)]
pub struct MyAuthenticator {
    pool: Arc&lt;PgPool&gt;,  // Shared connection pool
    cache: Arc&lt;RwLock&lt;Cache&gt;&gt;,  // Shared cache
}</code></pre>
<h3 id="2-handle-errors-gracefully"><a class="header" href="#2-handle-errors-gracefully">2. Handle Errors Gracefully</a></h3>
<p>Return <code>None</code> or default values on error:</p>
<pre><code class="language-rust">fn authenticate(&amp;self, req: &amp;ServiceRequest) -&gt; Option&lt;User&gt; {
    // Return None on any error
    let header = req.headers().get("Authorization")?;
    let token = header.to_str().ok()?;
    self.validate_token(token).ok()
}</code></pre>
<h3 id="3-log-security-events-1"><a class="header" href="#3-log-security-events-1">3. Log Security Events</a></h3>
<pre><code class="language-rust">fn authorize(&amp;self, user: Option&lt;&amp;User&gt;, req: &amp;ServiceRequest) -&gt; AuthorizationResult {
    let result = self.do_authorize(user, req);

    match &amp;result {
        AuthorizationResult::Denied =&gt; {
            log::warn!(
                "Access denied: user={:?} path={} method={}",
                user.map(|u| &amp;u.username),
                req.path(),
                req.method()
            );
        }
        AuthorizationResult::Granted =&gt; {
            log::debug!("Access granted: user={:?}", user.map(|u| &amp;u.username));
        }
        _ =&gt; {}
    }

    result
}</code></pre>
<h3 id="4-test-extensions"><a class="header" href="#4-test-extensions">4. Test Extensions</a></h3>
<pre><code class="language-rust">#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_custom_authenticator() {
        let auth = TestAuthenticator::new();
        let req = test_request_with_header("Authorization", "Basic dGVzdDp0ZXN0");

        let user = auth.authenticate(&amp;req);
        assert!(user.is_some());
        assert_eq!(user.unwrap().username, "test");
    }

    #[test]
    fn test_custom_expression() {
        let root = TenantExpressionRoot::new(mock_tenant_service());
        let user = test_user();

        let result = root.evaluate_function(
            "belongsToTenant",
            &amp;["acme".to_string()],
            Some(&amp;user),
        );

        assert_eq!(result, Some(true));
    }
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="testing-2"><a class="header" href="#testing-2">Testing</a></h1>
<p>Best practices for testing secured Actix Web applications.</p>
<h2 id="test-setup"><a class="header" href="#test-setup">Test Setup</a></h2>
<h3 id="create-test-helpers"><a class="header" href="#create-test-helpers">Create Test Helpers</a></h3>
<pre><code class="language-rust">// tests/common/mod.rs
use actix_security::http::security::{
    AuthenticationManager, AuthorizationManager, Argon2PasswordEncoder,
    PasswordEncoder, User, Access,
};
use actix_security::http::security::web::{MemoryAuthenticator, RequestMatcherAuthorizer};
use base64::prelude::*;

/// Create test authenticator with predefined users.
pub fn test_authenticator() -&gt; MemoryAuthenticator {
    let encoder = Argon2PasswordEncoder::new();

    AuthenticationManager::in_memory_authentication()
        .password_encoder(encoder.clone())
        .with_user(
            User::with_encoded_password("admin", encoder.encode("admin"))
                .roles(&amp;["ADMIN".into(), "USER".into()])
                .authorities(&amp;["users:read".into(), "users:write".into()])
        )
        .with_user(
            User::with_encoded_password("user", encoder.encode("user"))
                .roles(&amp;["USER".into()])
                .authorities(&amp;["users:read".into()])
        )
        .with_user(
            User::with_encoded_password("guest", encoder.encode("guest"))
                .roles(&amp;["GUEST".into()])
        )
}

/// Create test authorizer.
pub fn test_authorizer() -&gt; RequestMatcherAuthorizer {
    AuthorizationManager::request_matcher()
        .login_url("/login")
        .http_basic()
        .add_matcher("/admin/.*", Access::new().roles(vec!["ADMIN"]))
        .add_matcher("/api/.*", Access::new().authenticated())
}

/// Create Basic Auth header value.
pub fn basic_auth(username: &amp;str, password: &amp;str) -&gt; String {
    let credentials = format!("{}:{}", username, password);
    format!("Basic {}", BASE64_STANDARD.encode(credentials))
}</code></pre>
<h3 id="create-test-app"><a class="header" href="#create-test-app">Create Test App</a></h3>
<pre><code class="language-rust">use actix_web::{test, App};
use actix_security::http::security::middleware::SecurityTransform;

pub async fn create_test_app() -&gt; impl actix_web::dev::Service&lt;
    actix_http::Request,
    Response = actix_web::dev::ServiceResponse,
    Error = actix_web::Error,
&gt; {
    test::init_service(
        App::new()
            .wrap(
                SecurityTransform::new()
                    .config_authenticator(test_authenticator)
                    .config_authorizer(test_authorizer)
            )
            .service(your_handlers)
    )
    .await
}</code></pre>
<h2 id="testing-authentication"><a class="header" href="#testing-authentication">Testing Authentication</a></h2>
<h3 id="test-successful-authentication"><a class="header" href="#test-successful-authentication">Test Successful Authentication</a></h3>
<pre><code class="language-rust">#[actix_web::test]
async fn test_authentication_success() {
    let app = create_test_app().await;

    let req = test::TestRequest::get()
        .uri("/api/resource")
        .insert_header(("Authorization", basic_auth("user", "user")))
        .to_request();

    let resp = test::call_service(&amp;app, req).await;
    assert_eq!(resp.status(), StatusCode::OK);
}</code></pre>
<h3 id="test-invalid-credentials"><a class="header" href="#test-invalid-credentials">Test Invalid Credentials</a></h3>
<pre><code class="language-rust">#[actix_web::test]
async fn test_authentication_invalid_password() {
    let app = create_test_app().await;

    let req = test::TestRequest::get()
        .uri("/api/resource")
        .insert_header(("Authorization", basic_auth("user", "wrong_password")))
        .to_request();

    let resp = test::call_service(&amp;app, req).await;
    assert_eq!(resp.status(), StatusCode::UNAUTHORIZED);
}</code></pre>
<h3 id="test-missing-authentication"><a class="header" href="#test-missing-authentication">Test Missing Authentication</a></h3>
<pre><code class="language-rust">#[actix_web::test]
async fn test_authentication_missing() {
    let app = create_test_app().await;

    let req = test::TestRequest::get()
        .uri("/api/resource")
        .to_request();

    let resp = test::call_service(&amp;app, req).await;
    assert_eq!(resp.status(), StatusCode::UNAUTHORIZED);
}</code></pre>
<h2 id="testing-authorization"><a class="header" href="#testing-authorization">Testing Authorization</a></h2>
<h3 id="test-role-based-access"><a class="header" href="#test-role-based-access">Test Role-Based Access</a></h3>
<pre><code class="language-rust">#[actix_web::test]
async fn test_admin_can_access_admin_endpoint() {
    let app = create_test_app().await;

    let req = test::TestRequest::get()
        .uri("/admin/dashboard")
        .insert_header(("Authorization", basic_auth("admin", "admin")))
        .to_request();

    let resp = test::call_service(&amp;app, req).await;
    assert_eq!(resp.status(), StatusCode::OK);
}

#[actix_web::test]
async fn test_user_cannot_access_admin_endpoint() {
    let app = create_test_app().await;

    let req = test::TestRequest::get()
        .uri("/admin/dashboard")
        .insert_header(("Authorization", basic_auth("user", "user")))
        .to_request();

    let resp = test::call_service(&amp;app, req).await;
    assert_eq!(resp.status(), StatusCode::FORBIDDEN);
}</code></pre>
<h3 id="test-authority-based-access"><a class="header" href="#test-authority-based-access">Test Authority-Based Access</a></h3>
<pre><code class="language-rust">#[actix_web::test]
async fn test_user_with_authority_can_access() {
    let app = create_test_app().await;

    // admin has users:write authority
    let req = test::TestRequest::post()
        .uri("/api/users")
        .insert_header(("Authorization", basic_auth("admin", "admin")))
        .to_request();

    let resp = test::call_service(&amp;app, req).await;
    assert_eq!(resp.status(), StatusCode::OK);
}

#[actix_web::test]
async fn test_user_without_authority_cannot_access() {
    let app = create_test_app().await;

    // user doesn't have users:write authority
    let req = test::TestRequest::post()
        .uri("/api/users")
        .insert_header(("Authorization", basic_auth("user", "user")))
        .to_request();

    let resp = test::call_service(&amp;app, req).await;
    assert_eq!(resp.status(), StatusCode::FORBIDDEN);
}</code></pre>
<h2 id="testing-method-security"><a class="header" href="#testing-method-security">Testing Method Security</a></h2>
<h3 id="test-secured-macro"><a class="header" href="#test-secured-macro">Test @secured Macro</a></h3>
<pre><code class="language-rust">#[actix_web::test]
async fn test_secured_endpoint_with_required_role() {
    let app = create_test_app().await;

    let req = test::TestRequest::get()
        .uri("/secured/admin")
        .insert_header(("Authorization", basic_auth("admin", "admin")))
        .to_request();

    let resp = test::call_service(&amp;app, req).await;
    assert_eq!(resp.status(), StatusCode::OK);
}

#[actix_web::test]
async fn test_secured_endpoint_without_required_role() {
    let app = create_test_app().await;

    let req = test::TestRequest::get()
        .uri("/secured/admin")
        .insert_header(("Authorization", basic_auth("user", "user")))
        .to_request();

    let resp = test::call_service(&amp;app, req).await;
    assert_eq!(resp.status(), StatusCode::FORBIDDEN);
}</code></pre>
<h3 id="test-pre_authorize-expressions"><a class="header" href="#test-pre_authorize-expressions">Test @pre_authorize Expressions</a></h3>
<pre><code class="language-rust">#[actix_web::test]
async fn test_expression_with_and() {
    let app = create_test_app().await;

    // Endpoint: hasRole('USER') AND hasAuthority('users:read')
    // user has both
    let req = test::TestRequest::get()
        .uri("/expr/user-and-read")
        .insert_header(("Authorization", basic_auth("user", "user")))
        .to_request();

    let resp = test::call_service(&amp;app, req).await;
    assert_eq!(resp.status(), StatusCode::OK);
}

#[actix_web::test]
async fn test_expression_with_or() {
    let app = create_test_app().await;

    // Endpoint: hasRole('ADMIN') OR hasAuthority('users:write')
    // admin has ADMIN role
    let req = test::TestRequest::get()
        .uri("/expr/admin-or-write")
        .insert_header(("Authorization", basic_auth("admin", "admin")))
        .to_request();

    let resp = test::call_service(&amp;app, req).await;
    assert_eq!(resp.status(), StatusCode::OK);
}</code></pre>
<h2 id="testing-security-headers"><a class="header" href="#testing-security-headers">Testing Security Headers</a></h2>
<pre><code class="language-rust">#[actix_web::test]
async fn test_security_headers_present() {
    let app = test::init_service(
        App::new()
            .wrap(SecurityHeaders::default())
            .service(test_endpoint)
    ).await;

    let req = test::TestRequest::get().uri("/test").to_request();
    let resp = test::call_service(&amp;app, req).await;

    let headers = resp.headers();

    assert_eq!(headers.get("x-content-type-options").unwrap(), "nosniff");
    assert_eq!(headers.get("x-frame-options").unwrap(), "DENY");
}</code></pre>
<h2 id="testing-security-context"><a class="header" href="#testing-security-context">Testing Security Context</a></h2>
<pre><code class="language-rust">#[tokio::test]
async fn test_security_context() {
    let user = User::new("test".to_string(), "".to_string())
        .roles(&amp;["USER".into()])
        .authorities(&amp;["read".into()]);

    SecurityContext::run_with(Some(user), async {
        assert!(SecurityContext::is_authenticated());
        assert!(SecurityContext::has_role("USER"));
        assert!(SecurityContext::has_authority("read"));
        assert!(!SecurityContext::has_role("ADMIN"));

        let current = SecurityContext::get_user().unwrap();
        assert_eq!(current.username, "test");
    }).await;
}</code></pre>
<h2 id="integration-test-patterns"><a class="header" href="#integration-test-patterns">Integration Test Patterns</a></h2>
<h3 id="test-matrix"><a class="header" href="#test-matrix">Test Matrix</a></h3>
<pre><code class="language-rust">struct TestCase {
    name: &amp;'static str,
    user: Option&lt;(&amp;'static str, &amp;'static str)&gt;,
    path: &amp;'static str,
    expected_status: StatusCode,
}

#[actix_web::test]
async fn test_authorization_matrix() {
    let app = create_test_app().await;

    let test_cases = vec![
        TestCase {
            name: "admin can access admin endpoint",
            user: Some(("admin", "admin")),
            path: "/admin/dashboard",
            expected_status: StatusCode::OK,
        },
        TestCase {
            name: "user cannot access admin endpoint",
            user: Some(("user", "user")),
            path: "/admin/dashboard",
            expected_status: StatusCode::FORBIDDEN,
        },
        TestCase {
            name: "anonymous cannot access admin endpoint",
            user: None,
            path: "/admin/dashboard",
            expected_status: StatusCode::UNAUTHORIZED,
        },
    ];

    for tc in test_cases {
        let mut req = test::TestRequest::get().uri(tc.path);

        if let Some((username, password)) = tc.user {
            req = req.insert_header(("Authorization", basic_auth(username, password)));
        }

        let resp = test::call_service(&amp;app, req.to_request()).await;
        assert_eq!(
            resp.status(),
            tc.expected_status,
            "Failed: {}",
            tc.name
        );
    }
}</code></pre>
<h2 id="best-practices-10"><a class="header" href="#best-practices-10">Best Practices</a></h2>
<ol>
<li><strong>Test all user types</strong> - Admin, regular user, guest, anonymous</li>
<li><strong>Test edge cases</strong> - Invalid credentials, missing headers, malformed tokens</li>
<li><strong>Test both positive and negative cases</strong> - Access granted AND denied</li>
<li><strong>Use descriptive test names</strong> - Clear what's being tested</li>
<li><strong>Keep test helpers DRY</strong> - Share common setup code</li>
<li><strong>Test security headers</strong> - Verify they're present and correct</li>
<li><strong>Test expressions</strong> - Cover AND, OR, NOT combinations</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="api-documentation"><a class="header" href="#api-documentation">API Documentation</a></h1>
<p>Links to the detailed API documentation for each crate.</p>
<h2 id="crate-documentation"><a class="header" href="#crate-documentation">Crate Documentation</a></h2>
<h3 id="actix-security"><a class="header" href="#actix-security">actix-security</a></h3>
<p>Main library providing security middleware, authentication, and authorization.</p>
<p><strong><a href="https://docs.rs/actix-security">View API Docs</a></strong> (when published)</p>
<p>Generate locally:</p>
<pre><code class="language-bash">cargo doc -p actix-security --open
</code></pre>
<h4 id="key-types"><a class="header" href="#key-types">Key Types</a></h4>
<div class="table-wrapper"><table><thead><tr><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>SecurityTransform</code></td><td>Main middleware</td></tr>
<tr><td><code>Authenticator</code></td><td>Authentication trait</td></tr>
<tr><td><code>Authorizer</code></td><td>Authorization trait</td></tr>
<tr><td><code>User</code></td><td>User model</td></tr>
<tr><td><code>AuthenticatedUser</code></td><td>Request extractor</td></tr>
<tr><td><code>SecurityContext</code></td><td>Current user access</td></tr>
<tr><td><code>SecurityHeaders</code></td><td>Security headers middleware</td></tr>
<tr><td><code>PasswordEncoder</code></td><td>Password encoding trait</td></tr>
<tr><td><code>ExpressionRoot</code></td><td>Custom expression trait</td></tr>
<tr><td><code>JwtAuthenticator</code></td><td>JWT authentication (feature: <code>jwt</code>)</td></tr>
<tr><td><code>JwtConfig</code></td><td>JWT configuration (feature: <code>jwt</code>)</td></tr>
<tr><td><code>SessionAuthenticator</code></td><td>Session authentication (feature: <code>session</code>)</td></tr>
<tr><td><code>SessionConfig</code></td><td>Session configuration (feature: <code>session</code>)</td></tr>
</tbody></table>
</div>
<h3 id="procedural-macros"><a class="header" href="#procedural-macros">Procedural Macros</a></h3>
<p>Procedural macros are included in <code>actix-security</code> when the <code>macros</code> feature is enabled (default).</p>
<blockquote>
<p>For the underlying implementation, see the <code>actix-security-codegen</code> crate.</p>
</blockquote>
<h4 id="macros"><a class="header" href="#macros">Macros</a></h4>
<div class="table-wrapper"><table><thead><tr><th>Macro</th><th>Description</th></tr></thead><tbody>
<tr><td><code>#[secured]</code></td><td>Role-based access</td></tr>
<tr><td><code>#[pre_authorize]</code></td><td>Expression-based access</td></tr>
<tr><td><code>#[permit_all]</code></td><td>Public endpoints</td></tr>
<tr><td><code>#[deny_all]</code></td><td>Blocked endpoints</td></tr>
<tr><td><code>#[roles_allowed]</code></td><td>Java EE style</td></tr>
</tbody></table>
</div>
<h2 id="module-reference"><a class="header" href="#module-reference">Module Reference</a></h2>
<h3 id="actix_securityhttpsecurity"><a class="header" href="#actix_securityhttpsecurity">actix_security::http::security</a></h3>
<p>Main security module.</p>
<pre><code class="language-rust">use actix_security::http::security::{
    // Traits
    Authenticator,
    Authorizer,
    PasswordEncoder,

    // Types
    User,
    AuthenticatedUser,
    OptionalUser,
    SecurityContext,
    SecurityHeaders,

    // Implementations
    MemoryAuthenticator,
    RequestMatcherAuthorizer,
    Access,
    Argon2PasswordEncoder,
    NoOpPasswordEncoder,
    DelegatingPasswordEncoder,

    // Factory methods
    AuthenticationManager,
    AuthorizationManager,
};</code></pre>
<h3 id="actix_securityhttpsecuritymiddleware"><a class="header" href="#actix_securityhttpsecuritymiddleware">actix_security::http::security::middleware</a></h3>
<p>Middleware types.</p>
<pre><code class="language-rust">use actix_security::http::security::middleware::SecurityTransform;</code></pre>
<h3 id="actix_securityhttpsecurityexpression"><a class="header" href="#actix_securityhttpsecurityexpression">actix_security::http::security::expression</a></h3>
<p>Expression language types.</p>
<pre><code class="language-rust">use actix_security::http::security::expression::{
    Expression,
    BinaryOp,
    UnaryOp,
    ExpressionEvaluator,
    ExpressionRoot,
    DefaultExpressionRoot,
    SecurityExpression,
    ParseError,
};</code></pre>
<h3 id="actix_securityhttpsecurityjwt"><a class="header" href="#actix_securityhttpsecurityjwt">actix_security::http::security::jwt</a></h3>
<p>JWT authentication types (feature: <code>jwt</code>).</p>
<pre><code class="language-rust">use actix_security::http::security::jwt::{
    JwtAuthenticator,
    JwtConfig,
    JwtTokenService,
    Claims,
    JwtError,
    Algorithm,
};</code></pre>
<h3 id="actix_securityhttpsecuritysession"><a class="header" href="#actix_securityhttpsecuritysession">actix_security::http::security::session</a></h3>
<p>Session authentication types (feature: <code>session</code>).</p>
<pre><code class="language-rust">use actix_security::http::security::session::{
    SessionAuthenticator,
    SessionConfig,
    SessionUser,
    SessionLoginService,
    SessionError,
};</code></pre>
<h3 id="actix_securityhttpsecurityheaders"><a class="header" href="#actix_securityhttpsecurityheaders">actix_security::http::security::headers</a></h3>
<p>Security headers types.</p>
<pre><code class="language-rust">use actix_security::http::security::headers::{
    SecurityHeaders,
    FrameOptions,
    ReferrerPolicy,
};</code></pre>
<h3 id="actix_securityhttperror"><a class="header" href="#actix_securityhttperror">actix_security::http::error</a></h3>
<p>Error types.</p>
<pre><code class="language-rust">use actix_security::http::error::AuthError;</code></pre>
<h2 id="quick-reference-1"><a class="header" href="#quick-reference-1">Quick Reference</a></h2>
<h3 id="creating-users-1"><a class="header" href="#creating-users-1">Creating Users</a></h3>
<pre><code class="language-rust">// With encoded password
User::with_encoded_password("username", encoder.encode("password"))
    .roles(&amp;["ROLE".into()])
    .authorities(&amp;["auth".into()])

// Plain (for testing only)
User::new("username".to_string(), "password".to_string())
    .roles(&amp;["ROLE".into()])</code></pre>
<h3 id="configuring-authentication"><a class="header" href="#configuring-authentication">Configuring Authentication</a></h3>
<pre><code class="language-rust">AuthenticationManager::in_memory_authentication()
    .password_encoder(encoder)
    .with_user(user)</code></pre>
<h3 id="configuring-authorization"><a class="header" href="#configuring-authorization">Configuring Authorization</a></h3>
<pre><code class="language-rust">AuthorizationManager::request_matcher()
    .login_url("/login")
    .http_basic()
    .add_matcher("/admin/.*", Access::new().roles(vec!["ADMIN"]))
    .add_matcher("/api/.*", Access::new().authenticated())</code></pre>
<h3 id="access-configuration"><a class="header" href="#access-configuration">Access Configuration</a></h3>
<pre><code class="language-rust">Access::new()
    .roles(vec!["ROLE1", "ROLE2"])
    .authorities(vec!["auth1", "auth2"])
    .authenticated()
    .deny_all()</code></pre>
<h3 id="security-headers-1"><a class="header" href="#security-headers-1">Security Headers</a></h3>
<pre><code class="language-rust">SecurityHeaders::new()
    .frame_options(FrameOptions::Deny)
    .content_security_policy("default-src 'self'")
    .hsts(true, 31536000)
    .referrer_policy(ReferrerPolicy::NoReferrer)

SecurityHeaders::default()  // Safe defaults
SecurityHeaders::strict()   // Maximum security</code></pre>
<h3 id="password-encoding-1"><a class="header" href="#password-encoding-1">Password Encoding</a></h3>
<pre><code class="language-rust">let encoder = Argon2PasswordEncoder::new();
let encoded = encoder.encode("password");
let matches = encoder.matches("password", &amp;encoded);</code></pre>
<h3 id="security-context-1"><a class="header" href="#security-context-1">Security Context</a></h3>
<pre><code class="language-rust">SecurityContext::get_user()        // Option&lt;User&gt;
SecurityContext::has_role("ROLE")  // bool
SecurityContext::has_authority("auth")  // bool
SecurityContext::is_authenticated()     // bool</code></pre>
<h2 id="feature-flags-1"><a class="header" href="#feature-flags-1">Feature Flags</a></h2>
<h3 id="actix-security-1"><a class="header" href="#actix-security-1">actix-security</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Feature</th><th>Default</th><th>Description</th></tr></thead><tbody>
<tr><td><code>argon2</code></td><td>Yes</td><td>Argon2 password encoder</td></tr>
<tr><td><code>http-basic</code></td><td>Yes</td><td>HTTP Basic authentication</td></tr>
<tr><td><code>jwt</code></td><td>No</td><td>JWT authentication</td></tr>
<tr><td><code>session</code></td><td>No</td><td>Session-based authentication</td></tr>
<tr><td><code>full</code></td><td>No</td><td>All features enabled</td></tr>
</tbody></table>
</div>
<pre><code class="language-toml"># Default features (argon2, http-basic)
actix-security = "0.2"

# Minimal
actix-security = { version = "0.2", default-features = false }

# With JWT
actix-security = { version = "0.2", features = ["jwt"] }

# With Session
actix-security = { version = "0.2", features = ["session"] }

# All features
actix-security = { version = "0.2", features = ["full"] }
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="spring-security-comparison-31"><a class="header" href="#spring-security-comparison-31">Spring Security Comparison</a></h1>
<p>A comprehensive mapping between Spring Security and Actix Security concepts.</p>
<h2 id="annotations--macros"><a class="header" href="#annotations--macros">Annotations / Macros</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Spring Security</th><th>Actix Security</th><th>Notes</th></tr></thead><tbody>
<tr><td><code>@Secured("ROLE_ADMIN")</code></td><td><code>#[secured("ADMIN")]</code></td><td>No ROLE_ prefix in Actix</td></tr>
<tr><td><code>@PreAuthorize("...")</code></td><td><code>#[pre_authorize("...")]</code></td><td>Similar expression syntax</td></tr>
<tr><td><code>@PermitAll</code></td><td><code>#[permit_all]</code></td><td>Identical purpose</td></tr>
<tr><td><code>@DenyAll</code></td><td><code>#[deny_all]</code></td><td>Identical purpose</td></tr>
<tr><td><code>@RolesAllowed({"A", "B"})</code></td><td><code>#[roles_allowed("A", "B")]</code></td><td>Java EE style</td></tr>
</tbody></table>
</div>
<h2 id="expression-language"><a class="header" href="#expression-language">Expression Language</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Spring Security</th><th>Actix Security</th></tr></thead><tbody>
<tr><td><code>hasRole('ADMIN')</code></td><td><code>hasRole('ADMIN')</code></td></tr>
<tr><td><code>hasAnyRole('A', 'B')</code></td><td><code>hasAnyRole('A', 'B')</code></td></tr>
<tr><td><code>hasAuthority('read')</code></td><td><code>hasAuthority('read')</code></td></tr>
<tr><td><code>hasAnyAuthority('a', 'b')</code></td><td><code>hasAnyAuthority('a', 'b')</code></td></tr>
<tr><td><code>isAuthenticated()</code></td><td><code>isAuthenticated()</code></td></tr>
<tr><td><code>permitAll()</code></td><td><code>permitAll()</code></td></tr>
<tr><td><code>denyAll()</code></td><td><code>denyAll()</code></td></tr>
<tr><td><code>and</code> / <code>&amp;&amp;</code></td><td><code>AND</code></td></tr>
<tr><td><code>or</code> / <code>||</code></td><td><code>OR</code></td></tr>
<tr><td><code>!</code> / <code>not</code></td><td><code>NOT</code></td></tr>
</tbody></table>
</div>
<h2 id="configuration-classes"><a class="header" href="#configuration-classes">Configuration Classes</a></h2>
<h3 id="authentication-2"><a class="header" href="#authentication-2">Authentication</a></h3>
<p><strong>Spring Security:</strong></p>
<pre><code class="language-java">@Bean
public UserDetailsService userDetailsService() {
    InMemoryUserDetailsManager manager = new InMemoryUserDetailsManager();
    manager.createUser(User.withDefaultPasswordEncoder()
        .username("admin")
        .password("admin")
        .roles("ADMIN", "USER")
        .build());
    return manager;
}
</code></pre>
<p><strong>Actix Security:</strong></p>
<pre><code class="language-rust">let encoder = Argon2PasswordEncoder::new();

AuthenticationManager::in_memory_authentication()
    .password_encoder(encoder.clone())
    .with_user(
        User::with_encoded_password("admin", encoder.encode("admin"))
            .roles(&amp;["ADMIN".into(), "USER".into()])
    )</code></pre>
<h3 id="authorization-2"><a class="header" href="#authorization-2">Authorization</a></h3>
<p><strong>Spring Security:</strong></p>
<pre><code class="language-java">@Bean
public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
    http.authorizeHttpRequests(auth -&gt; auth
        .requestMatchers("/admin/**").hasRole("ADMIN")
        .requestMatchers("/api/**").authenticated()
        .anyRequest().permitAll()
    );
    return http.build();
}
</code></pre>
<p><strong>Actix Security:</strong></p>
<pre><code class="language-rust">AuthorizationManager::request_matcher()
    .add_matcher("/admin/.*", Access::new().roles(vec!["ADMIN"]))
    .add_matcher("/api/.*", Access::new().authenticated())
    // No matcher = permit all</code></pre>
<h3 id="password-encoding-2"><a class="header" href="#password-encoding-2">Password Encoding</a></h3>
<p><strong>Spring Security:</strong></p>
<pre><code class="language-java">@Bean
public PasswordEncoder passwordEncoder() {
    return new BCryptPasswordEncoder();
}

// Or delegating
@Bean
public PasswordEncoder passwordEncoder() {
    return PasswordEncoderFactories.createDelegatingPasswordEncoder();
}
</code></pre>
<p><strong>Actix Security:</strong></p>
<pre><code class="language-rust">let encoder = Argon2PasswordEncoder::new();

// Or delegating
let encoder = DelegatingPasswordEncoder::new()
    .with_encoder("argon2", Box::new(Argon2PasswordEncoder::new()))
    .with_encoder("noop", Box::new(NoOpPasswordEncoder::new()))
    .default_encoder("argon2");</code></pre>
<h3 id="http-basic"><a class="header" href="#http-basic">HTTP Basic</a></h3>
<p><strong>Spring Security:</strong></p>
<pre><code class="language-java">http.httpBasic(Customizer.withDefaults());
</code></pre>
<p><strong>Actix Security:</strong></p>
<pre><code class="language-rust">AuthorizationManager::request_matcher()
    .http_basic()</code></pre>
<h3 id="security-headers-2"><a class="header" href="#security-headers-2">Security Headers</a></h3>
<p><strong>Spring Security:</strong></p>
<pre><code class="language-java">http.headers(headers -&gt; headers
    .frameOptions(frame -&gt; frame.deny())
    .contentSecurityPolicy(csp -&gt; csp
        .policyDirectives("default-src 'self'"))
);
</code></pre>
<p><strong>Actix Security:</strong></p>
<pre><code class="language-rust">SecurityHeaders::new()
    .frame_options(FrameOptions::Deny)
    .content_security_policy("default-src 'self'")</code></pre>
<h2 id="core-interfaces--traits"><a class="header" href="#core-interfaces--traits">Core Interfaces / Traits</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Spring Security</th><th>Actix Security</th></tr></thead><tbody>
<tr><td><code>AuthenticationManager</code></td><td><code>Authenticator</code> trait</td></tr>
<tr><td><code>UserDetailsService</code></td><td><code>Authenticator.authenticate()</code></td></tr>
<tr><td><code>UserDetails</code></td><td><code>User</code></td></tr>
<tr><td><code>Authentication</code></td><td><code>AuthenticatedUser</code></td></tr>
<tr><td><code>AuthorizationManager</code></td><td><code>Authorizer</code> trait</td></tr>
<tr><td><code>SecurityContext</code></td><td><code>SecurityContext</code></td></tr>
<tr><td><code>PasswordEncoder</code></td><td><code>PasswordEncoder</code> trait</td></tr>
<tr><td><code>SecurityExpressionRoot</code></td><td><code>ExpressionRoot</code> trait</td></tr>
</tbody></table>
</div>
<h2 id="extension-points"><a class="header" href="#extension-points">Extension Points</a></h2>
<h3 id="custom-authentication"><a class="header" href="#custom-authentication">Custom Authentication</a></h3>
<p><strong>Spring Security:</strong></p>
<pre><code class="language-java">public class CustomAuthenticationProvider implements AuthenticationProvider {
    @Override
    public Authentication authenticate(Authentication auth) {
        // Custom logic
    }
}
</code></pre>
<p><strong>Actix Security:</strong></p>
<pre><code class="language-rust">impl Authenticator for CustomAuthenticator {
    fn authenticate(&amp;self, req: &amp;ServiceRequest) -&gt; Option&lt;User&gt; {
        // Custom logic
    }
}</code></pre>
<h3 id="custom-authorization"><a class="header" href="#custom-authorization">Custom Authorization</a></h3>
<p><strong>Spring Security:</strong></p>
<pre><code class="language-java">public class CustomAuthorizationManager implements AuthorizationManager&lt;RequestAuthorizationContext&gt; {
    @Override
    public AuthorizationDecision check(Supplier&lt;Authentication&gt; auth, RequestAuthorizationContext ctx) {
        // Custom logic
    }
}
</code></pre>
<p><strong>Actix Security:</strong></p>
<pre><code class="language-rust">impl Authorizer for CustomAuthorizer {
    fn authorize(&amp;self, user: Option&lt;&amp;User&gt;, req: &amp;ServiceRequest) -&gt; AuthorizationResult {
        // Custom logic
    }
}</code></pre>
<h3 id="custom-expression-functions-1"><a class="header" href="#custom-expression-functions-1">Custom Expression Functions</a></h3>
<p><strong>Spring Security:</strong></p>
<pre><code class="language-java">public class CustomSecurityExpressionRoot extends SecurityExpressionRoot {
    public boolean customFunction() {
        return true;
    }
}
</code></pre>
<p><strong>Actix Security:</strong></p>
<pre><code class="language-rust">impl ExpressionRoot for CustomRoot {
    fn evaluate_function(&amp;self, name: &amp;str, args: &amp;[String], user: Option&lt;&amp;User&gt;) -&gt; Option&lt;bool&gt; {
        match name {
            "customFunction" =&gt; Some(true),
            _ =&gt; None,
        }
    }
}</code></pre>
<h2 id="key-differences"><a class="header" href="#key-differences">Key Differences</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Aspect</th><th>Spring Security</th><th>Actix Security</th></tr></thead><tbody>
<tr><td><strong>Role prefix</strong></td><td>Adds <code>ROLE_</code> automatically</td><td>No prefix</td></tr>
<tr><td><strong>Expression operators</strong></td><td><code>and</code>, <code>or</code>, <code>!</code></td><td><code>AND</code>, <code>OR</code>, <code>NOT</code></td></tr>
<tr><td><strong>String quotes</strong></td><td>Double quotes <code>"</code></td><td>Single quotes <code>'</code></td></tr>
<tr><td><strong>Compile-time</strong></td><td>Runtime expression parsing</td><td>Compile-time parsing</td></tr>
<tr><td><strong>Async</strong></td><td>Synchronous by default</td><td>Async-first</td></tr>
</tbody></table>
</div>
<h2 id="migration-checklist"><a class="header" href="#migration-checklist">Migration Checklist</a></h2>
<ul>
<li><input disabled="" type="checkbox"/>
Remove <code>ROLE_</code> prefix from role names</li>
<li><input disabled="" type="checkbox"/>
Change <code>and</code>/<code>or</code> to <code>AND</code>/<code>OR</code> in expressions</li>
<li><input disabled="" type="checkbox"/>
Change double quotes to single quotes in expressions</li>
<li><input disabled="" type="checkbox"/>
Replace <code>@PreAuthorize</code> with <code>#[pre_authorize]</code></li>
<li><input disabled="" type="checkbox"/>
Replace <code>@Secured</code> with <code>#[secured]</code></li>
<li><input disabled="" type="checkbox"/>
Replace <code>BCryptPasswordEncoder</code> with <code>Argon2PasswordEncoder</code></li>
<li><input disabled="" type="checkbox"/>
Update security configuration to builder pattern</li>
<li><input disabled="" type="checkbox"/>
Add <code>AuthenticatedUser</code> parameter to secured handlers</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="migration-guide"><a class="header" href="#migration-guide">Migration Guide</a></h1>
<h2 id="migrating-from-spring-security"><a class="header" href="#migrating-from-spring-security">Migrating from Spring Security</a></h2>
<p>This guide helps Spring Security developers transition to Actix Security.</p>
<h3 id="step-1-update-dependencies"><a class="header" href="#step-1-update-dependencies">Step 1: Update Dependencies</a></h3>
<p><strong>Before (Maven/Gradle):</strong></p>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<p><strong>After (Cargo.toml):</strong></p>
<pre><code class="language-toml">[dependencies]
actix-security = { version = "0.2", features = ["argon2", "http-basic"] }
actix-security = "0.2"
</code></pre>
<h3 id="step-2-update-annotations"><a class="header" href="#step-2-update-annotations">Step 2: Update Annotations</a></h3>
<p><strong>Before (Java):</strong></p>
<pre><code class="language-java">@Secured("ROLE_ADMIN")
@GetMapping("/admin")
public String admin() { ... }

@PreAuthorize("hasRole('USER') and hasAuthority('posts:write')")
@PostMapping("/posts")
public String createPost() { ... }

@PermitAll
@GetMapping("/public")
public String publicEndpoint() { ... }
</code></pre>
<p><strong>After (Rust):</strong></p>
<pre><code class="language-rust">#[secured("ADMIN")]  // No ROLE_ prefix
#[get("/admin")]
async fn admin(user: AuthenticatedUser) -&gt; impl Responder { ... }

#[pre_authorize("hasRole('USER') AND hasAuthority('posts:write')")]  // AND not and
#[post("/posts")]
async fn create_post(user: AuthenticatedUser) -&gt; impl Responder { ... }

#[permit_all]
#[get("/public")]
async fn public_endpoint() -&gt; impl Responder { ... }  // No AuthenticatedUser needed</code></pre>
<h3 id="step-3-update-configuration"><a class="header" href="#step-3-update-configuration">Step 3: Update Configuration</a></h3>
<p><strong>Before (Java):</strong></p>
<pre><code class="language-java">@Configuration
@EnableWebSecurity
public class SecurityConfig {

    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http
            .httpBasic(Customizer.withDefaults())
            .authorizeHttpRequests(auth -&gt; auth
                .requestMatchers("/admin/**").hasRole("ADMIN")
                .requestMatchers("/api/**").authenticated()
                .anyRequest().permitAll()
            );
        return http.build();
    }

    @Bean
    public UserDetailsService userDetailsService() {
        var admin = User.withDefaultPasswordEncoder()
            .username("admin")
            .password("admin")
            .roles("ADMIN")
            .build();
        return new InMemoryUserDetailsManager(admin);
    }
}
</code></pre>
<p><strong>After (Rust):</strong></p>
<pre><code class="language-rust">use actix_security::http::security::{
    AuthenticationManager, AuthorizationManager,
    Argon2PasswordEncoder, PasswordEncoder, User, Access,
};
use actix_security::http::security::middleware::SecurityTransform;

fn configure_security(encoder: Argon2PasswordEncoder) -&gt; SecurityTransform&lt;...&gt; {
    SecurityTransform::new()
        .config_authenticator(move || {
            AuthenticationManager::in_memory_authentication()
                .password_encoder(encoder.clone())
                .with_user(
                    User::with_encoded_password("admin", encoder.encode("admin"))
                        .roles(&amp;["ADMIN".into()])
                )
        })
        .config_authorizer(|| {
            AuthorizationManager::request_matcher()
                .http_basic()
                .add_matcher("/admin/.*", Access::new().roles(vec!["ADMIN"]))
                .add_matcher("/api/.*", Access::new().authenticated())
        })
}</code></pre>
<h3 id="step-4-update-expression-syntax"><a class="header" href="#step-4-update-expression-syntax">Step 4: Update Expression Syntax</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Spring Security</th><th>Actix Security</th></tr></thead><tbody>
<tr><td><code>hasRole("ADMIN")</code></td><td><code>hasRole('ADMIN')</code> or <code>has_role('ADMIN')</code></td></tr>
<tr><td><code>hasRole('ADMIN')</code></td><td><code>hasRole('ADMIN')</code> or <code>has_role('ADMIN')</code></td></tr>
<tr><td><code>expr1 and expr2</code></td><td><code>expr1 AND expr2</code> or <code>expr1 &amp;&amp; expr2</code></td></tr>
<tr><td><code>expr1 or expr2</code></td><td><code>expr1 OR expr2</code> or <code>expr1 || expr2</code></td></tr>
<tr><td><code>!expr</code></td><td><code>NOT expr</code> or <code>!expr</code></td></tr>
<tr><td><code>not expr</code></td><td><code>NOT expr</code> or <code>!expr</code></td></tr>
</tbody></table>
</div>
<blockquote>
<p><strong>Note:</strong> Since v0.2.2, both Spring-style (camelCase, AND/OR/NOT) and Rust-style (snake_case, &amp;&amp;/||/!) are supported.</p>
</blockquote>
<h3 id="step-5-update-custom-expressions"><a class="header" href="#step-5-update-custom-expressions">Step 5: Update Custom Expressions</a></h3>
<p><strong>Before (Java):</strong></p>
<pre><code class="language-java">public class CustomSecurityExpressionRoot extends SecurityExpressionRoot
    implements MethodSecurityExpressionOperations {

    public boolean isPremium() {
        return premiumService.isPremium(getAuthentication().getName());
    }
}
</code></pre>
<p><strong>After (Rust):</strong></p>
<pre><code class="language-rust">impl ExpressionRoot for CustomExpressionRoot {
    fn evaluate_function(
        &amp;self,
        name: &amp;str,
        args: &amp;[String],
        user: Option&lt;&amp;User&gt;,
    ) -&gt; Option&lt;bool&gt; {
        match name {
            "isPremium" =&gt; {
                let user = user?;
                Some(self.premium_service.is_premium(&amp;user.username))
            }
            _ =&gt; None,
        }
    }
}</code></pre>
<h3 id="step-6-update-password-encoding"><a class="header" href="#step-6-update-password-encoding">Step 6: Update Password Encoding</a></h3>
<p><strong>Before (Java):</strong></p>
<pre><code class="language-java">@Bean
public PasswordEncoder passwordEncoder() {
    return new BCryptPasswordEncoder();
}
</code></pre>
<p><strong>After (Rust):</strong></p>
<pre><code class="language-rust">let encoder = Argon2PasswordEncoder::new();</code></pre>
<h3 id="step-7-update-security-context-access"><a class="header" href="#step-7-update-security-context-access">Step 7: Update Security Context Access</a></h3>
<p><strong>Before (Java):</strong></p>
<pre><code class="language-java">Authentication auth = SecurityContextHolder.getContext().getAuthentication();
String username = auth.getName();

if (auth.getAuthorities().stream()
        .anyMatch(a -&gt; a.getAuthority().equals("ROLE_ADMIN"))) {
    // Admin logic
}
</code></pre>
<p><strong>After (Rust):</strong></p>
<pre><code class="language-rust">if let Some(user) = SecurityContext::get_user() {
    let username = &amp;user.username;

    if SecurityContext::has_role("ADMIN") {
        // Admin logic
    }
}</code></pre>
<h2 id="common-migration-issues"><a class="header" href="#common-migration-issues">Common Migration Issues</a></h2>
<h3 id="issue-role_-prefix-not-working"><a class="header" href="#issue-role_-prefix-not-working">Issue: ROLE_ prefix not working</a></h3>
<p><strong>Problem:</strong> <code>#[secured("ROLE_ADMIN")]</code> doesn't match users with "ADMIN" role.</p>
<p><strong>Solution:</strong> Actix Security doesn't use the ROLE_ prefix. Use <code>#[secured("ADMIN")]</code> instead.</p>
<h3 id="issue-expression-operators-not-recognized"><a class="header" href="#issue-expression-operators-not-recognized">Issue: Expression operators not recognized</a></h3>
<p><strong>Problem:</strong> <code>#[pre_authorize("hasRole('ADMIN') &amp;&amp; hasAuthority('write')")]</code> fails.</p>
<p><strong>Solution:</strong> Since v0.2.2, both Rust-style (<code>&amp;&amp;</code>/<code>||</code>/<code>!</code>) and Spring-style (<code>AND</code>/<code>OR</code>/<code>NOT</code>) operators are supported. If you're using an older version, upgrade to 0.2.2+ or use <code>AND</code>/<code>OR</code>/<code>NOT</code>.</p>
<h3 id="issue-double-quotes-in-expressions"><a class="header" href="#issue-double-quotes-in-expressions">Issue: Double quotes in expressions</a></h3>
<p><strong>Problem:</strong> <code>#[pre_authorize("hasRole(\"ADMIN\")")]</code> fails.</p>
<p><strong>Solution:</strong> Use single quotes: <code>#[pre_authorize("hasRole('ADMIN')")]</code>.</p>
<h3 id="issue-missing-authenticateduser"><a class="header" href="#issue-missing-authenticateduser">Issue: Missing AuthenticatedUser</a></h3>
<p><strong>Problem:</strong> Handler doesn't compile with security macro.</p>
<p><strong>Solution:</strong> Add <code>AuthenticatedUser</code> parameter to secured handlers:</p>
<pre><code class="language-rust">#[secured("USER")]
#[get("/profile")]
async fn profile(user: AuthenticatedUser) -&gt; impl Responder { ... }</code></pre>
<h3 id="issue-permit_all-still-requires-auth"><a class="header" href="#issue-permit_all-still-requires-auth">Issue: permit_all still requires auth</a></h3>
<p><strong>Problem:</strong> <code>#[permit_all]</code> endpoint returns 401.</p>
<p><strong>Solution:</strong> Check URL-based authorization rules. If your URL matcher requires authentication for that path, remove the matcher or add an exception.</p>
<h2 id="testing-migration"><a class="header" href="#testing-migration">Testing Migration</a></h2>
<pre><code class="language-rust">#[actix_web::test]
async fn test_migrated_security() {
    let app = create_test_app().await;

    // Test role check
    let req = test::TestRequest::get()
        .uri("/admin")
        .insert_header(("Authorization", basic_auth("admin", "admin")))
        .to_request();
    let resp = test::call_service(&amp;app, req).await;
    assert_eq!(resp.status(), StatusCode::OK);

    // Test expression
    let req = test::TestRequest::post()
        .uri("/posts")
        .insert_header(("Authorization", basic_auth("user", "user")))
        .to_request();
    let resp = test::call_service(&amp;app, req).await;
    // Check expected status based on user's roles/authorities
}</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>



        <script>
            window.playground_line_numbers = true;
        </script>

        <script>
            window.playground_copyable = true;
        </script>

        <script src="ace.js"></script>
        <script src="editor.js"></script>
        <script src="mode-rust.js"></script>
        <script src="theme-dawn.js"></script>
        <script src="theme-tomorrow_night.js"></script>

        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="theme/pagetoc.js"></script>
        <script src="theme/version-selector.js"></script>

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
